--- kernel/uvm/nvidia_uvm_lite.c	2015-11-09 08:44:53.000000000 +0300
+++ kernel/uvm/nvidia_uvm_lite.c	2016-05-07 13:04:54.000000000 +0300
@@ -42,7 +42,6 @@
 #error "Building uvmlite code without RM enabled!"
 #endif
 
-
 static struct cdev g_uvmlite_cdev;
 
 // table of attached GUIDS
@@ -785,7 +784,8 @@
         // a reference so that the fault handling logic is correct:
         //
         get_page(pTracking->uvmPage);
-        retValue = VM_FAULT_MINOR;
+        // VM_FAULT_MINOR was dropped, hardcode 0
+        retValue = 0;
     }
 
     pRecord->isMapped = NV_TRUE;
--- kernel/os-mlock.c	2015-11-09 08:44:53.000000000 +0300
+++ kernel/os-mlock.c	2016-05-07 13:04:54.000000000 +0300
@@ -45,7 +45,11 @@
     }
 
     down_read(&mm->mmap_sem);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
     ret = get_user_pages(current, mm, (unsigned long)address,
+#else
+    ret = get_user_pages_remote(current, mm, (unsigned long)address,
+#endif
             page_count, write, force, user_pages, NULL);
     up_read(&mm->mmap_sem);
     pinned = ret;
@@ -58,7 +62,11 @@
     else if (pinned < page_count)
     {
         for (i = 0; i < pinned; i++)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
             page_cache_release(user_pages[i]);
+#else
+            put_page(user_pages[i]);
+#endif
         os_free_mem(user_pages);
         return RM_ERR_INVALID_ADDRESS;
     }
@@ -85,7 +93,11 @@
     {
         if (write)
             set_page_dirty_lock(user_pages[i]);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 6, 0)
         page_cache_release(user_pages[i]);
+#else
+        put_page(user_pages[i]);
+#endif
     }
 
     os_free_mem(user_pages);
