diff -ru --new-file blender-2.76b.old/intern/cycles/app/cycles_xml.cpp blender-2.76b/intern/cycles/app/cycles_xml.cpp
--- blender-2.76b.old/intern/cycles/app/cycles_xml.cpp	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/intern/cycles/app/cycles_xml.cpp	2016-01-13 23:17:25.143702239 +0300
@@ -294,7 +294,18 @@
 		xml_read_bool(&integrator->sample_all_lights_direct, node, "sample_all_lights_direct");
 		xml_read_bool(&integrator->sample_all_lights_indirect, node, "sample_all_lights_indirect");
 	}
-	
+
+    /* Metropolis Path Path */
+    bool metropolis = false;
+    xml_read_bool(&metropolis, node, "metropolis");
+
+    if(metropolis) {
+        integrator->method = Integrator::METROPOLIS_PATH;
+        xml_read_float(&integrator->image_mutation_range, "image_mutation_range");
+        xml_read_float(&integrator->large_mutation_chance, "large_mutation_chance");
+        xml_read_int(&integrator->max_consecutive_rejects, "max_consecutive_rejects");
+    }
+
 	/* Bounces */
 	xml_read_int(&integrator->min_bounce, node, "min_bounce");
 	xml_read_int(&integrator->max_bounce, node, "max_bounce");
diff -ru --new-file blender-2.76b.old/intern/cycles/blender/addon/presets.py blender-2.76b/intern/cycles/blender/addon/presets.py
--- blender-2.76b.old/intern/cycles/blender/addon/presets.py	2015-10-27 19:57:22.000000000 +0300
+++ blender-2.76b/intern/cycles/blender/addon/presets.py	2016-01-13 23:18:02.889254647 +0300
@@ -60,6 +60,9 @@
 
     preset_values = [
         "cycles.samples",
+        "cycles.max_consecutive_rejects",
+        "cycles.image_mutation_range",
+        "cycles.large_mutation_chance",
         "cycles.preview_samples",
         "cycles.aa_samples",
         "cycles.preview_aa_samples",
diff -ru --new-file blender-2.76b.old/intern/cycles/blender/addon/properties.py blender-2.76b/intern/cycles/blender/addon/properties.py
--- blender-2.76b.old/intern/cycles/blender/addon/properties.py	2015-11-04 13:02:14.000000000 +0300
+++ blender-2.76b/intern/cycles/blender/addon/properties.py	2016-01-14 15:22:35.768692183 +0300
@@ -107,6 +107,7 @@
 enum_integrator = (
     ('BRANCHED_PATH', "Branched Path Tracing", "Path tracing integrator that branches on the first bounce, giving more control over the number of light and material samples"),
     ('PATH', "Path Tracing", "Pure path tracing integrator"),
+    ('METROPOLIS_PATH', "Metropolis Path Tracing", "Path tracing integrator with Metropolis sampling"),
     )
 
 enum_volume_sampling = (
@@ -182,6 +183,36 @@
                 default=False,
                 )
 
+        cls.max_consecutive_rejects = IntProperty(
+                name="Max. consecutive rejects",
+                description="Number of rejected mutations before the next mutation is forced to be accepted",
+                min=1, max=10000,
+                default=512,
+                )
+        cls.image_mutation_range = FloatProperty(
+                name="Image mutation range",
+                description="Range of the pixel position mutation",
+                min=0.0, max=65536.0,
+                default=0.1,
+                )
+        cls.warmup_samples = IntProperty(
+                name="Warmup sample count",
+                description="Number of warmup samples per tile. Increase this when tile borders become visible.",
+                min=0, max=65536,
+                default=10,
+                )
+        cls.importance_equalisation = BoolProperty(
+                name="Use Importance Equalisation",
+                description="Uses Importance Equalisation to distribute samples more evenly, by default brighter areas are sampled more",
+                default=False
+        )
+        cls.metropolis_chain_number = IntProperty(
+                name="Number of Metropolis chains",
+                description="How many independent Metropolis samplers are used. On CPU, this should be similar to the thread number, while for GPU values > 1000 are faster. 0 means automatic",
+                min=0, max=65536,
+                default=0,
+        )
+
         cls.aa_samples = IntProperty(
                 name="AA Samples",
                 description="Number of antialiasing samples to render for each pixel",
@@ -484,6 +515,13 @@
                 default=False,
                 )
 
+        cls.num_progressive_samples = IntProperty(
+                name="Number of progressive samples",
+                description="Number of progressive samples to take",
+                min=1, max=2147483647,
+                default=1,
+                )
+
         cls.bake_type = EnumProperty(
             name="Bake Type",
             default='COMBINED',
@@ -524,6 +562,30 @@
                 min=0.0, max=5.0
                 )
 
+        cls.adaptive_stopping_threshold = FloatProperty(
+                name="Tolerated error",
+                description="Amount of error that is tolerated in a tile. If 0, adaptive stopping is disabled",
+                min=0, max=5.0,
+                default=0,
+                )
+        cls.use_adaptive_sampling = BoolProperty(
+                name="Use adaptive sampling",
+                description="Take more samples in noisy areas instead of a uniform distribution over the image",
+                default=False,
+                )
+        cls.adaptive_map_interval = IntProperty(
+                name="Adaptive map update rate",
+                description="Number of samples that is taken before the adaptive map is updated",
+                min=1, max=2147483647,
+                default=25,
+                )
+        cls.adaptive_error_power = FloatProperty(
+                name="Exponent of the power mean used in error estimation",
+                description="A value of 2 will give an average, higher values will put more emphasis on the extreme values",
+                min=2, max=100,
+                default=4,
+                )
+
     @classmethod
     def unregister(cls):
         del bpy.types.Scene.cycles
diff -ru --new-file blender-2.76b.old/intern/cycles/blender/addon/ui.py blender-2.76b/intern/cycles/blender/addon/ui.py
--- blender-2.76b.old/intern/cycles/blender/addon/ui.py	2015-11-04 13:02:14.000000000 +0300
+++ blender-2.76b/intern/cycles/blender/addon/ui.py	2016-01-14 15:22:50.458909950 +0300
@@ -76,6 +76,10 @@
         aa = cscene.samples
         if cscene.use_square_samples:
             aa = aa * aa
+    elif integrator == 'METROPOLIS_PATH':
+        aa = cscene.samples
+        if cscene.use_square_samples:
+            aa = aa * aa
     else:
         aa = cscene.aa_samples
         d = cscene.diffuse_samples
@@ -135,6 +139,14 @@
         sub.prop(cscene, "progressive", text="")
         row.prop(cscene, "use_square_samples")
 
+        if cscene.progressive == 'METROPOLIS_PATH':
+            mrow = layout.column()
+            mrow.label("Metropolis:")
+            mrow.prop(cscene, "max_consecutive_rejects", text="Max. consecutive rejects")
+            mrow.prop(cscene, "image_mutation_range", text="Image mutation range")
+            mrow.prop(cscene, "warmup_samples", text="Warmup sample count")
+            #mrow.prop(cscene, "importance_equalisation", text="Use Importance Equalisation")
+
         split = layout.split()
 
         col = split.column()
@@ -154,6 +166,12 @@
             sub.label(text="Samples:")
             sub.prop(cscene, "samples", text="Render")
             sub.prop(cscene, "preview_samples", text="Preview")
+        elif cscene.progressive == 'METROPOLIS_PATH':
+            col = split.column()
+            sub = col.column(align=True)
+            sub.label(text="Samples:")
+            sub.prop(cscene, "samples", text="Render")
+            sub.prop(cscene, "preview_samples", text="Preview")
         else:
             sub.label(text="AA Samples:")
             sub.prop(cscene, "aa_samples", text="Render")
@@ -317,6 +335,12 @@
         sub.prop(rd, "tile_y", text="Y")
 
         sub.prop(cscene, "use_progressive_refine")
+        subsub = sub.column(align=True)
+        subsub.enabled = cscene.use_progressive_refine
+        subsub.prop(cscene, "num_progressive_samples")
+        if cscene.progressive == 'METROPOLIS_PATH':
+            sub.label(text="Metropolis chains:")
+            sub.prop(cscene, "metropolis_chain_number")
 
         subsub = sub.column(align=True)
         subsub.enabled = not rd.use_border
@@ -337,6 +361,19 @@
 
         col.separator()
 
+        col.label(text="Adaptive sampling:")
+        col.prop(cscene, "adaptive_stopping_threshold")
+        if cscene.adaptive_stopping_threshold > 0:
+            col.prop(cscene, "adaptive_error_power")
+        if cscene.progressive != 'METROPOLIS_PATH':
+            col.prop(cscene, "use_adaptive_sampling")
+        #sub = col.column(align=True)
+        #sub.enabled = cscene.use_adaptive_sampling or cscene.adaptive_stopping_threshold > 0 or (cscene.importance_equalisation and cscene.progressive == 'METROPOLIS_PATH')
+        if cscene.use_adaptive_sampling or cscene.adaptive_stopping_threshold > 0 or (cscene.importance_equalisation and cscene.progressive == 'METROPOLIS_PATH'):
+            col.prop(cscene, "adaptive_map_interval")
+
+        col.separator()
+
         col.label(text="Acceleration structure:")
         col.prop(cscene, "debug_use_spatial_splits")
 
diff -ru --new-file blender-2.76b.old/intern/cycles/blender/blender_session.cpp blender-2.76b/intern/cycles/blender/blender_session.cpp
--- blender-2.76b.old/intern/cycles/blender/blender_session.cpp	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/intern/cycles/blender/blender_session.cpp	2016-01-13 23:25:27.471760564 +0300
@@ -142,7 +142,7 @@
 	BufferParams buffer_params = BlenderSync::get_buffer_params(b_render, b_v3d, b_rv3d, scene->camera, width, height);
 	session->reset(buffer_params, session_params.samples);
 
-	b_engine.use_highlight_tiles(session_params.progressive_refine == false);
+    b_engine.use_highlight_tiles(session_params.progressive_refine == false || session_params.error_progressive);
 }
 
 void BlenderSession::reset_session(BL::BlendData b_data_, BL::Scene b_scene_)
@@ -447,6 +447,11 @@
 		/* add passes */
 		vector<Pass> passes;
 		Pass::add(PASS_COMBINED, passes);
+        if (session_params.stopping_threshold > 0.0f || session_params.adaptive || session_params.metropolis)
+            Pass::add(PASS_SAMPLES, passes);
+
+        if (session_params.stopping_threshold > 0.0f || session_params.adaptive)
+            Pass::add(PASS_VARIANCE, passes);
 
 		if(session_params.device.advanced_shading) {
 
diff -ru --new-file blender-2.76b.old/intern/cycles/blender/blender_sync.cpp blender-2.76b/intern/cycles/blender/blender_sync.cpp
--- blender-2.76b.old/intern/cycles/blender/blender_sync.cpp	2015-11-04 13:02:14.000000000 +0300
+++ blender-2.76b/intern/cycles/blender/blender_sync.cpp	2016-01-13 23:29:48.010571991 +0300
@@ -36,6 +36,7 @@
 #include "util_debug.h"
 #include "util_foreach.h"
 #include "util_opengl.h"
+#include "util_system.h"
 #include "util_hash.h"
 
 CCL_NAMESPACE_BEGIN
@@ -226,9 +227,15 @@
 #endif
 
 	integrator->method = (Integrator::Method)get_enum(cscene, "progressive");
+    if (preview && integrator->method == Integrator::METROPOLIS_PATH)
+        integrator->method = Integrator::PATH;
 
-	integrator->sample_all_lights_direct = get_boolean(cscene, "sample_all_lights_direct");
-	integrator->sample_all_lights_indirect = get_boolean(cscene, "sample_all_lights_indirect");
+    integrator->sample_all_lights_direct = get_boolean(cscene, "sample_all_lights_direct") && (integrator->method != Integrator::METROPOLIS_PATH);
+    integrator->sample_all_lights_indirect = get_boolean(cscene, "sample_all_lights_indirect") && (integrator->method != Integrator::METROPOLIS_PATH);
+    
+    integrator->max_consecutive_rejects = get_int(cscene, "max_consecutive_rejects");
+    integrator->image_mutation_range = get_float(cscene, "image_mutation_range");
+    integrator->map_interval = get_boolean(cscene, "importance_equalisation") ? get_int(cscene, "adaptive_map_interval") : 0;
 
 	int diffuse_samples = get_int(cscene, "diffuse_samples");
 	int glossy_samples = get_int(cscene, "glossy_samples");
@@ -567,7 +574,18 @@
 	params.reset_timeout = get_float(cscene, "debug_reset_timeout");
 	params.text_timeout = get_float(cscene, "debug_text_timeout");
 
-	params.progressive_refine = get_boolean(cscene, "use_progressive_refine");
+    params.progressive_refine = get_boolean(cscene, "use_progressive_refine") | get_boolean(cscene, "importance_equalisation");
+    params.num_progressive_samples = min(get_int(cscene, "num_progressive_samples"), get_int(cscene, "adaptive_map_interval"));
+    params.stopping_threshold = get_float(cscene, "adaptive_stopping_threshold");
+    params.adaptive = get_boolean(cscene, "use_adaptive_sampling");
+    params.map_interval = get_int(cscene, "adaptive_map_interval");
+    params.adaptive_error_power = get_float(cscene, "adaptive_error_power");
+    params.error_progressive = get_boolean(cscene, "use_progressive_refine") && params.stopping_threshold > 0;
+
+    params.metropolis = (Integrator::Method)get_enum(cscene, "progressive") == Integrator::METROPOLIS_PATH && background;
+    params.importance_equalisation = get_boolean(cscene, "importance_equalisation");
+    params.warmup_samples = get_int(cscene, "warmup_samples");
+    params.num_metro_chains = get_int(cscene, "metropolis_chain_number");
 
 	if(background) {
 		if(params.progressive_refine)
diff -ru --new-file blender-2.76b.old/intern/cycles/device/device_cpu.cpp blender-2.76b/intern/cycles/device/device_cpu.cpp
--- blender-2.76b.old/intern/cycles/device/device_cpu.cpp	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/intern/cycles/device/device_cpu.cpp	2016-01-14 15:52:32.099462959 +0300
@@ -16,6 +16,7 @@
 
 #include <stdlib.h>
 #include <string.h>
+#include <algorithm>
 
 /* So ImathMath is included before our kernel_cpu_compat. */
 #ifdef WITH_OSL
@@ -52,6 +53,12 @@
 #include "util_progress.h"
 #include "util_system.h"
 #include "util_thread.h"
+#include "util_color.h"
+#include "util_hash.h"
+#include "util_importance.h"
+#include "util_metropolis.h"
+
+#include "session.h"
 
 CCL_NAMESPACE_BEGIN
 
@@ -60,7 +67,6 @@
 public:
 	TaskPool task_pool;
 	KernelGlobals kernel_globals;
-
 #ifdef WITH_OSL
 	OSLGlobals osl_globals;
 #endif
@@ -164,6 +170,8 @@
 	{
 		if(task->type == DeviceTask::PATH_TRACE)
 			thread_path_trace(*task);
+		else if(task->type == DeviceTask::METROPOLIS_TRACE)
+			thread_metropolis(*task);
 		else if(task->type == DeviceTask::FILM_CONVERT)
 			thread_film_convert(*task);
 		else if(task->type == DeviceTask::SHADER)
@@ -178,7 +186,157 @@
 			run = function_bind(&CPUDevice::thread_run, device, this);
 		}
 	};
+	
+	void thread_metropolis(DeviceTask& task) {
+		if(task_pool.canceled()) {
+			if(task.need_finish_queue == false)
+				return;
+	    }
+		
+	    KernelGlobals kg = kernel_globals;
 
+#ifdef WITH_OSL
+	    OSLShader::thread_init(&kg, &kernel_globals, &osl_globals);
+#endif
+	    RenderTile tile;
+	    while(task.acquire_tile(this, tile)) {
+		    float *render_buffer = (float*)tile.buffer;
+            uint *rng_state = (uint*)tile.rng_state;
+            int start_sample = tile.start_sample;
+            int end_sample = tile.start_sample + tile.num_samples;
+            tile.sample = tile.start_sample;
+            if (tile.buffers->metro_shared_params == NULL) {
+                tile.buffers->metro_shared_params = new double[8];
+                memset(tile.buffers->metro_shared_params, 0, sizeof(double)*8);
+            }
+            int numChains = task.num_metro_chains;
+            MetropolisChain** metroChains = new MetropolisChain*[numChains];
+            int samplesPerChain = tile.w*tile.h / task.num_metro_chains;
+            for (int i = 0; i < numChains; i++) {
+                metroChains[i] = (MetropolisChain*) malloc(sizeof(MetropolisChain) + 2*task.metro_sample_size*sizeof(uint) + 3*task.metro_sample_size*sizeof(float));
+                kernel_metro_init_chain(&kg, metroChains[i]);
+            }
+            if (start_sample == 0) {
+                for(int y = tile.y; y < tile.y + tile.h; y++) //Fill in ID, UV and normal passes
+                    for(int x = tile.x; x < tile.x + tile.w; x++)
+                        kernel_cpu_metropolis_first_pass(&kg, render_buffer, tile.buffers->metro_shared_params, rng_state, x, y, tile.offset, tile.stride);
+            }
+            for (int i = 0; i < task.warmup_samples; i++) {
+#ifdef WITH_CYCLES_OPTIMIZED_KERNEL_AVX2
+                if(system_cpu_support_avx2())
+                    for(int y = tile.y; y < tile.y + tile.h; y++) //Fill in ID, UV and normal passes
+                        for(int x = tile.x; x < tile.x + tile.w; x++)
+                            kernel_cpu_avx2_metropolis_warmup(&kg, rng_state, tile.buffers->metro_shared_params, i + tile.start_sample, x, y, tile.offset, tile.stride);
+                else
+#endif
+#ifdef WITH_CYCLES_OPTIMIZED_KERNEL_AVX
+                if(system_cpu_support_avx())
+                    for(int y = tile.y; y < tile.y + tile.h; y++) //Fill in ID, UV and normal passes
+                        for(int x = tile.x; x < tile.x + tile.w; x++)
+                            kernel_cpu_avx_metropolis_warmup(&kg, rng_state, tile.buffers->metro_shared_params, i + tile.start_sample, x, y, tile.offset, tile.stride);
+                else
+#endif
+#ifdef WITH_CYCLES_OPTIMIZED_KERNEL_SSE41
+                if(system_cpu_support_sse41())
+                    for(int y = tile.y; y < tile.y + tile.h; y++) //Fill in ID, UV and normal passes
+                        for(int x = tile.x; x < tile.x + tile.w; x++)
+                            kernel_cpu_sse41_metropolis_warmup(&kg, rng_state, tile.buffers->metro_shared_params, i + tile.start_sample, x, y, tile.offset, tile.stride);
+                else
+#endif
+#ifdef WITH_CYCLES_OPTIMIZED_KERNEL_SSE3
+                if(system_cpu_support_sse3())
+                    for(int y = tile.y; y < tile.y + tile.h; y++) //Fill in ID, UV and normal passes
+                        for(int x = tile.x; x < tile.x + tile.w; x++)
+                            kernel_cpu_sse3_metropolis_warmup(&kg, rng_state, tile.buffers->metro_shared_params, i + tile.start_sample, x, y, tile.offset, tile.stride);
+                else
+#endif
+#ifdef WITH_CYCLES_OPTIMIZED_KERNEL_SSE2
+                if(system_cpu_support_sse2())
+                    for(int y = tile.y; y < tile.y + tile.h; y++) //Fill in ID, UV and normal passes
+                        for(int x = tile.x; x < tile.x + tile.w; x++)
+                            kernel_cpu_sse2_metropolis_warmup(&kg, rng_state, tile.buffers->metro_shared_params, i + tile.start_sample, x, y, tile.offset, tile.stride);
+                else
+#endif
+				for(int y = tile.y; y < tile.y + tile.h; y++) //Fill in ID, UV and normal passes
+					for(int x = tile.x; x < tile.x + tile.w; x++)
+						kernel_cpu_metropolis_warmup(&kg, rng_state, tile.buffers->metro_shared_params, i + tile.start_sample, x, y, tile.offset, tile.stride);
+		    }
+
+            /*Metropolis m(&kg, &tile.buffers->totalImportance, &tile.buffers->sampleCount, &tile);
+            PassData pd;*/
+            for(int sample = start_sample; sample < end_sample; sample++) {
+                if (task.get_cancel() || task_pool.canceled()) {
+                    if(task.need_finish_queue == false)
+                        break;
+                }
+#ifdef WITH_CYCLES_OPTIMIZED_KERNEL_AVX2
+                if(system_cpu_support_avx2())
+                    for(uint i = 0; i < numChains; i++)
+                        for(uint j = 0; j < samplesPerChain; j++)
+                            kernel_cpu_avx2_metropolis_step(&kg, render_buffer, metroChains[i], tile.buffers->metro_shared_params,
+                                tile.x, tile.y, tile.w, tile.h, tile.offset, tile.stride);
+                else
+#endif
+#ifdef WITH_CYCLES_OPTIMIZED_KERNEL_AVX
+                if(system_cpu_support_avx())
+                    for(uint i = 0; i < numChains; i++)
+                        for(uint j = 0; j < samplesPerChain; j++)
+                            kernel_cpu_avx_metropolis_step(&kg, render_buffer, metroChains[i], tile.buffers->metro_shared_params,
+                                tile.x, tile.y, tile.w, tile.h, tile.offset, tile.stride);
+                else
+#endif
+#ifdef WITH_CYCLES_OPTIMIZED_KERNEL_SSE41
+                if(system_cpu_support_sse41())
+                    for(uint i = 0; i < numChains; i++)
+                        for(uint j = 0; j < samplesPerChain; j++)
+                            kernel_cpu_sse41_metropolis_step(&kg, render_buffer, metroChains[i], tile.buffers->metro_shared_params,
+                                tile.x, tile.y, tile.w, tile.h, tile.offset, tile.stride);
+                else
+#endif
+#ifdef WITH_CYCLES_OPTIMIZED_KERNEL_SSE3
+                if(system_cpu_support_sse3())
+                    for(uint i = 0; i < numChains; i++)
+                        for(uint j = 0; j < samplesPerChain; j++)
+                            kernel_cpu_sse3_metropolis_step(&kg, render_buffer, metroChains[i], tile.buffers->metro_shared_params,
+                                tile.x, tile.y, tile.w, tile.h, tile.offset, tile.stride);
+                else
+#endif
+#ifdef WITH_CYCLES_OPTIMIZED_KERNEL_SSE2
+                if(system_cpu_support_sse2())
+                    for(uint i = 0; i < numChains; i++)
+                        for(uint j = 0; j < samplesPerChain; j++)
+                            kernel_cpu_sse2_metropolis_step(&kg, render_buffer, metroChains[i], tile.buffers->metro_shared_params,
+                                tile.x, tile.y, tile.w, tile.h, tile.offset, tile.stride);
+                else
+#endif
+                for(uint i = 0; i < numChains; i++)
+                    for(uint j = 0; j < samplesPerChain; j++)
+                        kernel_cpu_metropolis_step(&kg, render_buffer, metroChains[i], tile.buffers->metro_shared_params,
+                            tile.x, tile.y, tile.w, tile.h, tile.offset, tile.stride);
+
+                tile.sample = sample + 1;
+                task.update_progress(&tile);
+
+                if (task.stopping_threshold > 0.0f && tile_converged(tile, &task))
+                    break;
+		    }
+          
+            for (int i = 0; i < numChains; i++)
+                delete metroChains[i];
+
+            task.release_tile(tile);
+
+            if(task_pool.canceled()) {
+                if(task.need_finish_queue == false)
+                    break;
+            }
+	    }
+
+#ifdef WITH_OSL
+		OSLShader::thread_free(&kg);
+#endif
+	}
+	
 	void thread_path_trace(DeviceTask& task)
 	{
 		if(task_pool.canceled()) {
@@ -221,15 +379,24 @@
 			path_trace_kernel = kernel_cpu_sse2_path_trace;
 		else
 #endif
-			path_trace_kernel = kernel_cpu_path_trace;
+        path_trace_kernel = kernel_cpu_path_trace;
 		
 		while(task.acquire_tile(this, tile)) {
 			float *render_buffer = (float*)tile.buffer;
 			uint *rng_state = (uint*)tile.rng_state;
 			int start_sample = tile.start_sample;
 			int end_sample = tile.start_sample + tile.num_samples;
+			tile.sample = tile.start_sample;
+			CDF_2D *importance_map = NULL;
 
 			for(int sample = start_sample; sample < end_sample; sample++) {
+                if (task.adaptive && sample >= task.map_interval && (sample % task.map_interval == 0 || !importance_map)) {
+                    if (importance_map) delete importance_map;
+                        build_importance(tile);
+                        importance_map = new CDF_2D(tile.buffers->importance_map + tile.offset + tile.x + tile.y * tile.stride, tile.w, tile.h, tile.stride);   
+                    }
+                    if (task.stopping_threshold > 0.0f && tile_converged(tile, &task))
+                        break;
 				if(task.get_cancel() || task_pool.canceled()) {
 					if(task.need_finish_queue == false)
 						break;
@@ -241,11 +408,22 @@
 						                  sample, x, y, tile.offset, tile.stride);
 					}
 				}
+                
+                for (int y = 0; y < tile.h; y++) {
+					for (int x = 0; x < tile.w; x++) {
+						int px = x, py = y;
+						if (importance_map)
+							importance_map->sample_02_jittered(sample - task.map_interval, px, py, px, py);
+						path_trace_kernel(&kg, render_buffer, rng_state, sample, px + tile.x, py + tile.y, tile.offset,
+										  tile.stride);
+					}
+				}
 
 				tile.sample = sample + 1;
-
 				task.update_progress(&tile);
 			}
+            
+            if (importance_map) delete importance_map;
 
 			task.release_tile(tile);
 
@@ -407,8 +585,9 @@
 		else
 			task.split(tasks, TaskScheduler::num_threads());
 
-		foreach(DeviceTask& task, tasks)
+		foreach(DeviceTask& task, tasks) {
 			task_pool.push(new CPUDeviceTask(this, task));
+		}
 	}
 
 	void task_wait()
diff -ru --new-file blender-2.76b.old/intern/cycles/device/device_cuda.cpp blender-2.76b/intern/cycles/device/device_cuda.cpp
--- blender-2.76b.old/intern/cycles/device/device_cuda.cpp	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/intern/cycles/device/device_cuda.cpp	2016-01-14 16:03:28.039330937 +0300
@@ -27,12 +27,14 @@
 #include "util_debug.h"
 #include "util_logging.h"
 #include "util_map.h"
+#include "util_metropolis.h"
 #include "util_opengl.h"
 #include "util_path.h"
 #include "util_string.h"
 #include "util_system.h"
 #include "util_types.h"
 #include "util_time.h"
+#include "util_importance.h"
 
 CCL_NAMESPACE_BEGIN
 
@@ -48,6 +50,10 @@
 	int cuDevArchitecture;
 	bool first_error;
 	bool use_texture_storage;
+	
+	device_vector<int2> threads_to_pixels;
+	device_vector<uchar> metropolis_chains;
+	device_vector<double> metropolis_shared_params;
 
 	struct PixelMem {
 		GLuint cuPBO;
@@ -580,7 +586,7 @@
 		}
 	}
 
-	void path_trace(RenderTile& rtile, int sample, bool branched)
+	void path_trace(RenderTile& rtile, int sample, bool branched, device_ptr thread_to_pixel_mem)
 	{
 		if(have_error())
 			return;
@@ -590,6 +596,7 @@
 		CUfunction cuPathTrace;
 		CUdeviceptr d_buffer = cuda_device_ptr(rtile.buffer);
 		CUdeviceptr d_rng_state = cuda_device_ptr(rtile.rng_state);
+		CUdeviceptr d_thread_to_pixel_mem = cuda_device_ptr(thread_to_pixel_mem);
 
 		/* get kernel function */
 		if(branched) {
@@ -605,6 +612,7 @@
 		/* pass in parameters */
 		void *args[] = {&d_buffer,
 						 &d_rng_state,
+                         &d_thread_to_pixel_mem,
 						 &sample,
 						 &rtile.x,
 						 &rtile.y,
@@ -612,7 +620,7 @@
 						 &rtile.h,
 						 &rtile.offset,
 						 &rtile.stride};
-
+        
 		/* launch kernel */
 		int threads_per_block;
 		cuda_assert(cuFuncGetAttribute(&threads_per_block, CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK, cuPathTrace));
@@ -634,12 +642,240 @@
 								   xblocks , yblocks, 1, /* blocks */
 								   xthreads, ythreads, 1, /* threads */
 								   0, 0, args, 0));
+		
+		cuda_assert(cuCtxSynchronize());
+
+		cuda_pop_context();
+	}
 
+    void metropolis_first_pass(RenderTile& rtile, int numChains)
+    {
+		if(have_error())
+			return;
+		
+		cuda_push_context();
+		
+		CUfunction cuFirstPass;
+		CUdeviceptr d_buffer = cuda_device_ptr(rtile.buffer);
+		CUdeviceptr d_rng_state = cuda_device_ptr(rtile.rng_state);
+		CUdeviceptr d_shared_params = cuda_device_ptr(metropolis_shared_params.device_pointer);
+		CUdeviceptr d_metro_chains = cuda_device_ptr(metropolis_chains.device_pointer);
+		
+		/* get kernel function */
+		cuda_assert(cuModuleGetFunction(&cuFirstPass, cuModule, "kernel_cuda_metropolis_first_pass"));
+		
+		if(have_error())
+			return;
+		
+		/* pass in parameters */
+		int offset = 0;
+		
+		cuda_assert(cuParamSetv(cuFirstPass, offset, &d_buffer, sizeof(d_buffer)));
+		offset += sizeof(d_buffer);
+		
+		cuda_assert(cuParamSetv(cuFirstPass, offset, &d_rng_state, sizeof(d_rng_state)));
+		offset += sizeof(d_rng_state);
+		
+		cuda_assert(cuParamSetv(cuFirstPass, offset, &d_shared_params, sizeof(d_shared_params)));
+		offset += sizeof(d_shared_params);
+		
+		cuda_assert(cuParamSetv(cuFirstPass, offset, &d_metro_chains, sizeof(d_metro_chains)));
+		offset += sizeof(d_metro_chains);
+		
+		offset = align_up(offset, __alignof(int));
+		
+		cuda_assert(cuParamSeti(cuFirstPass, offset, rtile.x));
+		offset += sizeof(rtile.x);
+		
+		cuda_assert(cuParamSeti(cuFirstPass, offset, rtile.y));
+		offset += sizeof(rtile.y);
+		
+		cuda_assert(cuParamSeti(cuFirstPass, offset, rtile.w));
+		offset += sizeof(rtile.w);
+		
+		cuda_assert(cuParamSeti(cuFirstPass, offset, rtile.h));
+		offset += sizeof(rtile.h);
+		
+		cuda_assert(cuParamSeti(cuFirstPass, offset, rtile.offset));
+		offset += sizeof(rtile.offset);
+		
+		cuda_assert(cuParamSeti(cuFirstPass, offset, rtile.stride));
+		offset += sizeof(rtile.stride);
+		
+		cuda_assert(cuParamSeti(cuFirstPass, offset, numChains));
+		offset += sizeof(numChains);
+		
+		cuda_assert(cuParamSetSize(cuFirstPass, offset));
+		
+		/* launch kernel */
+		int threads_per_block;
+		cuda_assert(cuFuncGetAttribute(&threads_per_block, CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK, cuFirstPass));
+		
+		/*int num_registers;
+		cuda_assert(cuFuncGetAttribute(&num_registers, CU_FUNC_ATTRIBUTE_NUM_REGS, cuPathTrace));
+		
+		printf("threads_per_block %d\n", threads_per_block);
+		printf("num_registers %d\n", num_registers);*/
+		
+		int xthreads = (int)sqrt((float)threads_per_block);
+		int ythreads = (int)sqrt((float)threads_per_block);
+		int xblocks = (rtile.w + xthreads - 1)/xthreads;
+		int height = max(rtile.h, (numChains + rtile.w - 1) / rtile.w); //Run at least one thread per chain
+		int yblocks = (height + ythreads - 1)/ythreads;
+		
+		cuda_assert(cuFuncSetCacheConfig(cuFirstPass, CU_FUNC_CACHE_PREFER_L1));
+		cuda_assert(cuFuncSetBlockShape(cuFirstPass, xthreads, ythreads, 1));
+		cuda_assert(cuLaunchGrid(cuFirstPass, xblocks, yblocks));
+		
 		cuda_assert(cuCtxSynchronize());
+		
+		cuda_pop_context();
+	}
+
+	void metropolis_warmup(RenderTile& rtile, int i)
+	{
+		if(have_error())
+			return;
 
+		cuda_push_context();
+		
+		CUfunction cuWarmup;
+		CUdeviceptr d_rng_state = cuda_device_ptr(rtile.rng_state);
+		CUdeviceptr d_shared_params = cuda_device_ptr(metropolis_shared_params.device_pointer);
+		
+		/* get kernel function */
+		cuda_assert(cuModuleGetFunction(&cuWarmup, cuModule, "kernel_cuda_metropolis_warmup"));
+		
+		if(have_error())
+			return;
+		
+		/* pass in parameters */
+		int offset = 0;
+		
+		cuda_assert(cuParamSetv(cuWarmup, offset, &d_rng_state, sizeof(d_rng_state)));
+		offset += sizeof(d_rng_state);
+		
+		cuda_assert(cuParamSetv(cuWarmup, offset, &d_shared_params, sizeof(d_shared_params)));
+		offset += sizeof(d_shared_params);
+		
+		offset = align_up(offset, __alignof(int));
+		
+		cuda_assert(cuParamSeti(cuWarmup, offset, i));
+		offset += sizeof(i);
+		
+		cuda_assert(cuParamSeti(cuWarmup, offset, rtile.w));
+		offset += sizeof(rtile.w);
+		
+		cuda_assert(cuParamSeti(cuWarmup, offset, rtile.h));
+		offset += sizeof(rtile.h);
+		
+		cuda_assert(cuParamSeti(cuWarmup, offset, rtile.offset));
+		offset += sizeof(rtile.offset);
+		
+		cuda_assert(cuParamSeti(cuWarmup, offset, rtile.stride));
+		offset += sizeof(rtile.stride);
+		
+		cuda_assert(cuParamSetSize(cuWarmup, offset));
+		
+		/* launch kernel */
+		int threads_per_block;
+		cuda_assert(cuFuncGetAttribute(&threads_per_block, CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK, cuWarmup));
+		
+		/*int num_registers;
+		cuda_assert(cuFuncGetAttribute(&num_registers, CU_FUNC_ATTRIBUTE_NUM_REGS, cuPathTrace));
+		
+		printf("threads_per_block %d\n", threads_per_block);
+		printf("num_registers %d\n", num_registers);*/
+		
+		int xthreads = (int)sqrt((float)threads_per_block);
+		int ythreads = (int)sqrt((float)threads_per_block);
+		int xblocks = (rtile.w + xthreads - 1)/xthreads;
+		int yblocks = (rtile.h + ythreads - 1)/ythreads;
+		
+		cuda_assert(cuFuncSetCacheConfig(cuWarmup, CU_FUNC_CACHE_PREFER_L1));
+		cuda_assert(cuFuncSetBlockShape(cuWarmup, xthreads, ythreads, 1));
+		cuda_assert(cuLaunchGrid(cuWarmup, xblocks, yblocks));
+		
+		cuda_assert(cuCtxSynchronize());
+		
 		cuda_pop_context();
 	}
 
+	void metropolis_step(RenderTile& rtile, int sample, int numChains)
+	{
+		if(have_error())
+			return;
+
+		cuda_push_context();
+		
+		CUfunction cuMetroStep;
+		CUdeviceptr d_buffer = cuda_device_ptr(rtile.buffer);
+		CUdeviceptr d_shared_params = cuda_device_ptr(metropolis_shared_params.device_pointer);
+		CUdeviceptr d_metro_chains = cuda_device_ptr(metropolis_chains.device_pointer);
+		
+		/* get kernel function */
+		cuda_assert(cuModuleGetFunction(&cuMetroStep, cuModule, "kernel_cuda_metropolis_step"));
+		
+		if(have_error())
+			return;
+		
+		/* pass in parameters */
+		int offset = 0;
+		 
+		cuda_assert(cuParamSetv(cuMetroStep, offset, &d_buffer, sizeof(d_buffer)));
+		offset += sizeof(d_buffer);
+		 
+		cuda_assert(cuParamSetv(cuMetroStep, offset, &d_shared_params, sizeof(d_shared_params)));
+		offset += sizeof(d_shared_params);
+		
+		cuda_assert(cuParamSetv(cuMetroStep, offset, &d_metro_chains, sizeof(d_metro_chains)));
+		offset += sizeof(d_metro_chains);
+		
+		offset = align_up(offset, __alignof(int));
+		
+		cuda_assert(cuParamSeti(cuMetroStep, offset, numChains));
+		offset += sizeof(numChains);
+		
+		cuda_assert(cuParamSeti(cuMetroStep, offset, rtile.x));
+		offset += sizeof(rtile.x);
+		
+		cuda_assert(cuParamSeti(cuMetroStep, offset, rtile.y));
+		offset += sizeof(rtile.y);
+		
+		cuda_assert(cuParamSeti(cuMetroStep, offset, rtile.w));
+		offset += sizeof(rtile.w);
+		
+		cuda_assert(cuParamSeti(cuMetroStep, offset, rtile.h));
+		offset += sizeof(rtile.h);
+		
+		cuda_assert(cuParamSeti(cuMetroStep, offset, rtile.offset));
+		offset += sizeof(rtile.offset);
+		
+		cuda_assert(cuParamSeti(cuMetroStep, offset, rtile.stride));
+		offset += sizeof(rtile.stride);
+		
+		cuda_assert(cuParamSetSize(cuMetroStep, offset));
+		
+		/* launch kernel */
+		int threads_per_block;
+		cuda_assert(cuFuncGetAttribute(&threads_per_block, CU_FUNC_ATTRIBUTE_MAX_THREADS_PER_BLOCK, cuMetroStep));
+		
+		/*int num_registers;
+		cuda_assert(cuFuncGetAttribute(&num_registers, CU_FUNC_ATTRIBUTE_NUM_REGS, cuPathTrace));
+		
+		printf("threads_per_block %d\n", threads_per_block);
+		printf("num_registers %d\n", num_registers);*/
+		
+		int blocks = (numChains + threads_per_block - 1) / threads_per_block;
+		
+		cuda_assert(cuFuncSetCacheConfig(cuMetroStep, CU_FUNC_CACHE_PREFER_L1));
+		cuda_assert(cuFuncSetBlockShape(cuMetroStep, threads_per_block, 1, 1));
+		cuda_assert(cuLaunchGrid(cuMetroStep, blocks, 1));
+		cuda_assert(cuCtxSynchronize());
+		cuda_pop_context();
+	}
+
+
 	void film_convert(DeviceTask& task, device_ptr buffer, device_ptr rgba_byte, device_ptr rgba_half)
 	{
 		if(have_error())
@@ -1004,21 +1240,98 @@
 			while(task->acquire_tile(this, tile)) {
 				int start_sample = tile.start_sample;
 				int end_sample = tile.start_sample + tile.num_samples;
+				tile.sample = tile.start_sample;
+				CDF_2D *importance_map = NULL;
 
 				for(int sample = start_sample; sample < end_sample; sample++) {
+					if (task->adaptive && sample >= task->map_interval && (sample % task->map_interval == 0 || !importance_map)) {
+						if (importance_map) delete importance_map;
+						build_importance(tile);
+						importance_map = new CDF_2D(tile.buffers->importance_map + tile.offset + tile.x + tile.y * tile.stride, tile.w, tile.h, tile.stride);
+					}
+
+					if (task->stopping_threshold > 0.0f && tile_converged(tile, task))
+						break;
+
 					if(task->get_cancel()) {
 						if(task->need_finish_queue == false)
 							break;
 					}
 
-					path_trace(tile, sample, branched);
+					if (importance_map) {
+						threads_to_pixels.resize(tile.h*tile.w);
+						mem_free(threads_to_pixels);
+						mem_alloc(threads_to_pixels, MEM_READ_ONLY);
+						for (int y = 0; y < tile.h; y++)
+							for (int x = 0; x < tile.w; x++) {
+								int px = x, py = y;
+								importance_map->sample_02_jittered(sample, px, py, px, py);
+								((int*) threads_to_pixels.data_pointer)[2*(y*tile.w + x)] = px;
+								((int*) threads_to_pixels.data_pointer)[2*(y*tile.w + x) + 1] = py;
+							}
+						mem_copy_to(threads_to_pixels);
+					}
+
+					path_trace(tile, sample, branched, importance_map ? threads_to_pixels.device_pointer : (device_ptr)NULL);
+
+					tile.sample = sample + 1;
+
+					task->update_progress(&tile);
+				}
+                task->release_tile(tile);
+            }
+		}
+		else if(task->type == DeviceTask::METROPOLIS_TRACE) {
+			RenderTile tile;
+			
+			/* keep rendering tiles until done */
+			while(task->acquire_tile(this, tile)) {
+				int start_sample = tile.start_sample;
+				int end_sample = tile.start_sample + tile.num_samples;
+				tile.sample = tile.start_sample;
+                if (tile.buffers->metro_shared_params == NULL) {
+                    tile.buffers->metro_shared_params = new double[8];
+                    memset(tile.buffers->metro_shared_params, 0, sizeof(double)*8);
+                }
+				
+				metropolis_chains.resize(metro_get_size(task->num_metro_chains, task->metro_sample_size));
+				if (!metropolis_chains.device_pointer)
+					mem_alloc(metropolis_chains, MEM_READ_WRITE);
+
+                metropolis_shared_params.resize(8);
+				if (!metropolis_shared_params.device_pointer)
+					mem_alloc(metropolis_shared_params, MEM_READ_WRITE);
+                memcpy((void*) metropolis_shared_params.data_pointer, tile.buffers->metro_shared_params, 8*sizeof(double));
+                mem_copy_to(metropolis_shared_params);
+
+				if (start_sample == 0)
+					metropolis_first_pass(tile, task->num_metro_chains);
+
+                for (int i = 0; i < task->warmup_samples; i++)
+                    metropolis_warmup(tile, i);
+
+				for(int sample = start_sample; sample < end_sample; sample++) {
+					if (task->get_cancel()) {
+						if(task->need_finish_queue == false)
+							break;
+					}
+
+                    int numSteps = (tile.w*tile.h + task->num_metro_chains - 1)/task->num_metro_chains;
+                    for (int i = 0; i < numSteps; i++)
+                        metropolis_step(tile, sample*numSteps + i + 1, task->num_metro_chains);
+
 
 					tile.sample = sample + 1;
 
 					task->update_progress(&tile);
+					if (task->stopping_threshold > 0.0f && tile_converged(tile, task))
+						break;
 				}
+				mem_copy_from(metropolis_shared_params, 0, 8, 1, sizeof(double));
+				memcpy(tile.buffers->metro_shared_params, (void*) metropolis_shared_params.data_pointer, 8*sizeof(double));
 
 				task->release_tile(tile);
+				mem_free(metropolis_chains);
 			}
 		}
 		else if(task->type == DeviceTask::SHADER) {
@@ -1156,7 +1469,7 @@
 		info.extended_images = (major >= 3);
 		info.pack_images = false;
 
-		/* if device has a kernel timeout, assume it is used for display */
+		/* if device has a KernelGlobals timeout, assume it is used for display */
 		if(cuDeviceGetAttribute(&attr, CU_DEVICE_ATTRIBUTE_KERNEL_EXEC_TIMEOUT, num) == CUDA_SUCCESS && attr == 1) {
 			info.display_device = true;
 			display_devices.push_back(info);
diff -ru --new-file blender-2.76b.old/intern/cycles/device/device.h blender-2.76b/intern/cycles/device/device.h
--- blender-2.76b.old/intern/cycles/device/device.h	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/intern/cycles/device/device.h	2016-01-13 23:30:17.262999885 +0300
@@ -33,6 +33,7 @@
 
 class Progress;
 class RenderTile;
+class Session;
 
 /* Device Types */
 
diff -ru --new-file blender-2.76b.old/intern/cycles/device/device_memory.h blender-2.76b/intern/cycles/device/device_memory.h
--- blender-2.76b.old/intern/cycles/device/device_memory.h	2015-11-04 13:02:14.000000000 +0300
+++ blender-2.76b/intern/cycles/device/device_memory.h	2016-01-14 01:23:56.320037712 +0300
@@ -17,6 +17,8 @@
 #ifndef __DEVICE_MEMORY_H__
 #define __DEVICE_MEMORY_H__
 
+#include <stdio.h>
+
 /* Device Memory
  *
  * This file defines data types that can be used in device memory arrays, and
@@ -48,6 +50,7 @@
 	TYPE_UINT,
 	TYPE_INT,
 	TYPE_FLOAT,
+	TYPE_DOUBLE,
 	TYPE_HALF
 };
 
@@ -56,6 +59,7 @@
 	switch(datatype) {
 		case TYPE_UCHAR: return sizeof(uchar);
 		case TYPE_FLOAT: return sizeof(float);
+		case TYPE_DOUBLE: return sizeof(double);
 		case TYPE_UINT: return sizeof(uint);
 		case TYPE_INT: return sizeof(int);
 		case TYPE_HALF: return sizeof(half);
@@ -150,6 +154,11 @@
 	static const int num_elements = 4;
 };
 
+template<> struct device_type_traits<double> {
+	static const DataType data_type = TYPE_DOUBLE;
+	static const int num_elements = 1;
+};
+
 template<> struct device_type_traits<half4> {
 	static const DataType data_type = TYPE_HALF;
 	static const int num_elements = 4;
@@ -177,7 +186,7 @@
 
 protected:
 	device_memory() {}
-	virtual ~device_memory() { assert(!device_pointer); }
+	virtual ~device_memory() { /*assert(!device_pointer);*/ }
 
 	/* no copying */
 	device_memory(const device_memory&);
diff -ru --new-file blender-2.76b.old/intern/cycles/device/device_opencl.cpp blender-2.76b/intern/cycles/device/device_opencl.cpp
--- blender-2.76b.old/intern/cycles/device/device_opencl.cpp	2015-11-04 13:02:14.000000000 +0300
+++ blender-2.76b/intern/cycles/device/device_opencl.cpp	2016-01-14 01:24:55.356904970 +0300
@@ -35,6 +35,7 @@
 #include "util_opengl.h"
 #include "util_path.h"
 #include "util_time.h"
+#include "util_importance.h"
 
 CCL_NAMESPACE_BEGIN
 
@@ -1772,8 +1773,12 @@
 			while(task->acquire_tile(this, tile)) {
 				int start_sample = tile.start_sample;
 				int end_sample = tile.start_sample + tile.num_samples;
+				tile.sample = tile.start_sample;
 
 				for(int sample = start_sample; sample < end_sample; sample++) {
+					if (task->stopping_threshold > 0.0f && tile_converged(tile, task))
+						break;
+
 					if(task->get_cancel()) {
 						if(task->need_finish_queue == false)
 							break;
diff -ru --new-file blender-2.76b.old/intern/cycles/device/device_task.cpp blender-2.76b/intern/cycles/device/device_task.cpp
--- blender-2.76b.old/intern/cycles/device/device_task.cpp	2015-10-27 19:57:22.000000000 +0300
+++ blender-2.76b/intern/cycles/device/device_task.cpp	2016-01-14 15:57:37.327051511 +0300
@@ -16,6 +16,7 @@
 
 #include <stdlib.h>
 #include <string.h>
+#include <stdio.h>
 
 #include "device_task.h"
 
@@ -84,6 +85,10 @@
 		for(int i = 0; i < num; i++)
 			tasks.push_back(*this);
 	}
+	else if(type == METROPOLIS_TRACE) {
+		for(int i = 0; i < num; i++)
+			tasks.push_back(*this);
+	}
 	else {
 		for(int i = 0; i < num; i++) {
 			int ty = y + (h/num)*i;
@@ -102,6 +107,7 @@
 void DeviceTask::update_progress(RenderTile *rtile)
 {
 	if((type != PATH_TRACE) &&
+       (type != METROPOLIS_TRACE) &&
 	   (type != SHADER))
 		return;
 
diff -ru --new-file blender-2.76b.old/intern/cycles/device/device_task.h blender-2.76b/intern/cycles/device/device_task.h
--- blender-2.76b.old/intern/cycles/device/device_task.h	2015-10-27 19:57:22.000000000 +0300
+++ blender-2.76b/intern/cycles/device/device_task.h	2016-01-14 01:29:57.863348169 +0300
@@ -34,7 +34,7 @@
 
 class DeviceTask : public Task {
 public:
-	typedef enum { PATH_TRACE, FILM_CONVERT, SHADER } Type;
+	typedef enum { PATH_TRACE, METROPOLIS_TRACE, FILM_CONVERT, SHADER } Type;
 	Type type;
 
 	int x, y, w, h;
@@ -65,6 +65,17 @@
 
 	bool need_finish_queue;
 	bool integrator_branched;
+	bool integrator_metropolis;
+	bool importance_equalisation;
+	int num_metro_chains;
+	int metro_sample_size;
+	int warmup_samples;
+
+	bool adaptive;
+	int map_interval;
+	float stopping_threshold;
+	float adaptive_error_power;
+	bool error_progressive;
 	int2 requested_tile_size;
 protected:
 	double last_update_time;
diff -ru --new-file blender-2.76b.old/intern/cycles/kernel/CMakeLists.txt blender-2.76b/intern/cycles/kernel/CMakeLists.txt
--- blender-2.76b.old/intern/cycles/kernel/CMakeLists.txt	2015-11-04 13:02:14.000000000 +0300
+++ blender-2.76b/intern/cycles/kernel/CMakeLists.txt	2016-01-14 01:31:48.562971920 +0300
@@ -44,6 +44,7 @@
 	kernel_jitter.h
 	kernel_light.h
 	kernel_math.h
+	kernel_metropolis.h
 	kernel_montecarlo.h
 	kernel_passes.h
 	kernel_path.h
@@ -158,6 +159,7 @@
 	../util/util_atomic.h
 	../util/util_color.h
 	../util/util_half.h
+    ../util/util_hash.h
 	../util/util_math.h
 	../util/util_math_fast.h
 	../util/util_transform.h
diff -ru --new-file blender-2.76b.old/intern/cycles/kernel/kernel_camera.h blender-2.76b/intern/cycles/kernel/kernel_camera.h
--- blender-2.76b.old/intern/cycles/kernel/kernel_camera.h	2015-11-04 13:02:14.000000000 +0300
+++ blender-2.76b/intern/cycles/kernel/kernel_camera.h	2016-01-14 01:45:11.167740743 +0300
@@ -280,7 +280,7 @@
 
 /* Common */
 
-ccl_device void camera_sample(KernelGlobals *kg, int x, int y, float filter_u, float filter_v,
+ccl_device void camera_sample(KernelGlobals *kg, float x, float y, float filter_u, float filter_v,
 	float lens_u, float lens_v, float time, ccl_addr_space Ray *ray)
 {
 	/* pixel filter */
diff -ru --new-file blender-2.76b.old/intern/cycles/kernel/kernel_compat_cpu.h blender-2.76b/intern/cycles/kernel/kernel_compat_cpu.h
--- blender-2.76b.old/intern/cycles/kernel/kernel_compat_cpu.h	2015-11-04 13:02:14.000000000 +0300
+++ blender-2.76b/intern/cycles/kernel/kernel_compat_cpu.h	2016-01-14 15:31:05.574249672 +0300
@@ -467,6 +467,42 @@
 
 #define kernel_data (kg->__data)
 
+#ifdef __GNUC__
+#define atomicCASD(x, y, z) __sync_val_compare_and_swap(x, y, z)
+#define atomicCASF(x, y, z) __sync_val_compare_and_swap(x, y, z)
+#define atomicExch(x, y) __sync_lock_test_and_set(x, y)
+#elif defined(_WIN32)
+#define atomicCASD(x, y, z) _InterlockedCompareExchange64((volatile long long int *)x, z, y)
+#define atomicCASF(x, y, z) _InterlockedCompareExchange((volatile long int *)x, z, y)
+#define atomicExch(x, y) _InterlockedExchange(x, y)
+#else
+#error No CAS operation for this Compiler!
+#endif
+
+inline double atomicAddD(double* address, double val)
+{
+	unsigned long long int* address_as_ull = (unsigned long long int*)address;
+	unsigned long long int old = *address_as_ull, assumed, newV;
+	do {
+		assumed = old;
+		*((double*) &newV) = val + *((double*) &assumed);
+		old = atomicCASD(address_as_ull, assumed, newV);
+	} while (assumed != old);
+	return *((double*) &old);
+}
+
+inline float atomicAddF(float* address, float val)
+{
+	unsigned int* address_as_ull = (unsigned int*)address;
+	unsigned int old = *address_as_ull, assumed, newV;
+	do {
+		assumed = old;
+		*((float*) &newV) = val + *((float*) &assumed);
+		old = atomicCASF(address_as_ull, assumed, newV);
+	} while (assumed != old);
+	return *((float*) &old);
+}
+
 #ifdef __KERNEL_SSE2__
 typedef vector3<sseb> sse3b;
 typedef vector3<ssef> sse3f;
diff -ru --new-file blender-2.76b.old/intern/cycles/kernel/kernel_compat_cuda.h blender-2.76b/intern/cycles/kernel/kernel_compat_cuda.h
--- blender-2.76b.old/intern/cycles/kernel/kernel_compat_cuda.h	2015-10-27 19:57:22.000000000 +0300
+++ blender-2.76b/intern/cycles/kernel/kernel_compat_cuda.h	2016-01-14 01:49:25.049472615 +0300
@@ -91,4 +91,32 @@
 #define logf(x) __logf(((float)(x)))
 #define expf(x) __expf(((float)(x)))
 
+__device__ __inline__ double atomicAddD(double* address, double val)
+{
+	unsigned long long int* address_as_ull =
+										(unsigned long long int*)address;
+	unsigned long long int old = *address_as_ull, assumed;
+	do {
+		assumed = old;
+		old = atomicCAS(address_as_ull, assumed, 
+			__double_as_longlong(val + 
+			__longlong_as_double(assumed)));
+	} while (assumed != old);
+	return __longlong_as_double(old);
+}
+
+__device__ __inline__ float atomicAddF(float* address, float val)
+{
+	unsigned int* address_as_u =
+							(unsigned int*)address;
+	unsigned int old = *address_as_u, assumed;
+	do {
+		assumed = old;
+		old = atomicCAS(address_as_u, assumed, 
+			__float_as_int(val + 
+			__int_as_float(assumed)));
+	} while (assumed != old);
+	return __int_as_float(old);
+}
+
 #endif /* __KERNEL_COMPAT_CUDA_H__ */
diff -ru --new-file blender-2.76b.old/intern/cycles/kernel/kernel.h blender-2.76b/intern/cycles/kernel/kernel.h
--- blender-2.76b.old/intern/cycles/kernel/kernel.h	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/intern/cycles/kernel/kernel.h	2016-01-14 01:41:09.000190137 +0300
@@ -24,6 +24,8 @@
 CCL_NAMESPACE_BEGIN
 
 struct KernelGlobals;
+struct PassData;
+struct MetropolisChain;
 
 KernelGlobals *kernel_globals_create();
 void kernel_globals_free(KernelGlobals *kg);
@@ -43,6 +45,12 @@
 
 void kernel_cpu_path_trace(KernelGlobals *kg, float *buffer, unsigned int *rng_state,
 	int sample, int x, int y, int offset, int stride);
+void kernel_cpu_metropolis_first_pass(KernelGlobals *kg, ccl_global float *buffer, double *sharedParams, ccl_global uint *rng_state,
+	int x, int y, int offset, int stride);
+void kernel_cpu_metropolis_warmup(KernelGlobals *kg, ccl_global uint *rng_state, double *sharedParams, int sample, int x, int y, int offset, int stride);
+void kernel_metro_init_chain(KernelGlobals *kg, MetropolisChain *m);
+void kernel_cpu_metropolis_step(KernelGlobals *kg, float *rbuffer, MetropolisChain *metro, double *sharedParams,
+	int x, int y, int w, int h, int offset, int stride);
 void kernel_cpu_convert_to_byte(KernelGlobals *kg, uchar4 *rgba, float *buffer,
 	float sample_scale, int x, int y, int offset, int stride);
 void kernel_cpu_convert_to_half_float(KernelGlobals *kg, uchar4 *rgba, float *buffer,
@@ -53,6 +61,11 @@
 #ifdef WITH_CYCLES_OPTIMIZED_KERNEL_SSE2
 void kernel_cpu_sse2_path_trace(KernelGlobals *kg, float *buffer, unsigned int *rng_state,
 	int sample, int x, int y, int offset, int stride);
+void kernel_cpu_sse2_metropolis_step(KernelGlobals *kg, float *rbuffer, MetropolisChain *metro, double *sharedParams,
+	int x, int y, int w, int h, int offset, int stride);
+void kernel_cpu_sse2_metropolis_first_pass(KernelGlobals *kg, ccl_global float *buffer, double *sharedParams, ccl_global uint *rng_state,
+	int x, int y, int offset, int stride);
+void kernel_cpu_sse2_metropolis_warmup(KernelGlobals *kg, ccl_global uint *rng_state, double *sharedParams, int sample, int x, int y, int offset, int stride);
 void kernel_cpu_sse2_convert_to_byte(KernelGlobals *kg, uchar4 *rgba, float *buffer,
 	float sample_scale, int x, int y, int offset, int stride);
 void kernel_cpu_sse2_convert_to_half_float(KernelGlobals *kg, uchar4 *rgba, float *buffer,
@@ -64,6 +77,11 @@
 #ifdef WITH_CYCLES_OPTIMIZED_KERNEL_SSE3
 void kernel_cpu_sse3_path_trace(KernelGlobals *kg, float *buffer, unsigned int *rng_state,
 	int sample, int x, int y, int offset, int stride);
+void kernel_cpu_sse3_metropolis_step(KernelGlobals *kg, float *rbuffer, MetropolisChain *metro, double *sharedParams,
+	int x, int y, int w, int h, int offset, int stride);
+void kernel_cpu_sse3_metropolis_first_pass(KernelGlobals *kg, ccl_global float *buffer, double *sharedParams, ccl_global uint *rng_state,
+	int x, int y, int offset, int stride);
+void kernel_cpu_sse3_metropolis_warmup(KernelGlobals *kg, ccl_global uint *rng_state, double *sharedParams, int sample, int x, int y, int offset, int stride);
 void kernel_cpu_sse3_convert_to_byte(KernelGlobals *kg, uchar4 *rgba, float *buffer,
 	float sample_scale, int x, int y, int offset, int stride);
 void kernel_cpu_sse3_convert_to_half_float(KernelGlobals *kg, uchar4 *rgba, float *buffer,
@@ -75,6 +93,11 @@
 #ifdef WITH_CYCLES_OPTIMIZED_KERNEL_SSE41
 void kernel_cpu_sse41_path_trace(KernelGlobals *kg, float *buffer, unsigned int *rng_state,
 	int sample, int x, int y, int offset, int stride);
+void kernel_cpu_sse41_metropolis_step(KernelGlobals *kg, float *rbuffer, MetropolisChain *metro, double *sharedParams,
+	int x, int y, int w, int h, int offset, int stride);
+void kernel_cpu_sse41_metropolis_first_pass(KernelGlobals *kg, ccl_global float *buffer, double *sharedParams, ccl_global uint *rng_state,
+	int x, int y, int offset, int stride);
+void kernel_cpu_sse41_metropolis_warmup(KernelGlobals *kg, ccl_global uint *rng_state, double *sharedParams, int sample, int x, int y, int offset, int stride);
 void kernel_cpu_sse41_convert_to_byte(KernelGlobals *kg, uchar4 *rgba, float *buffer,
 	float sample_scale, int x, int y, int offset, int stride);
 void kernel_cpu_sse41_convert_to_half_float(KernelGlobals *kg, uchar4 *rgba, float *buffer,
@@ -86,6 +109,11 @@
 #ifdef WITH_CYCLES_OPTIMIZED_KERNEL_AVX
 void kernel_cpu_avx_path_trace(KernelGlobals *kg, float *buffer, unsigned int *rng_state,
 	int sample, int x, int y, int offset, int stride);
+void kernel_cpu_avx_metropolis_step(KernelGlobals *kg, float *rbuffer, MetropolisChain *metro, double *sharedParams,
+	int x, int y, int w, int h, int offset, int stride);
+void kernel_cpu_avx_metropolis_first_pass(KernelGlobals *kg, ccl_global float *buffer, double *sharedParams, ccl_global uint *rng_state,
+	int x, int y, int offset, int stride);
+void kernel_cpu_avx_metropolis_warmup(KernelGlobals *kg, ccl_global uint *rng_state, double *sharedParams, int sample, int x, int y, int offset, int stride);
 void kernel_cpu_avx_convert_to_byte(KernelGlobals *kg, uchar4 *rgba, float *buffer,
 	float sample_scale, int x, int y, int offset, int stride);
 void kernel_cpu_avx_convert_to_half_float(KernelGlobals *kg, uchar4 *rgba, float *buffer,
@@ -97,6 +125,11 @@
 #ifdef WITH_CYCLES_OPTIMIZED_KERNEL_AVX2
 void kernel_cpu_avx2_path_trace(KernelGlobals *kg, float *buffer, unsigned int *rng_state,
 	int sample, int x, int y, int offset, int stride);
+void kernel_cpu_avx2_metropolis_step(KernelGlobals *kg, float *rbuffer, MetropolisChain *metro, double *sharedParams,
+	int x, int y, int w, int h, int offset, int stride);
+void kernel_cpu_avx2_metropolis_first_pass(KernelGlobals *kg, ccl_global float *buffer, double *sharedParams, ccl_global uint *rng_state,
+	int x, int y, int offset, int stride);
+void kernel_cpu_avx2_metropolis_warmup(KernelGlobals *kg, ccl_global uint *rng_state, double *sharedParams, int sample, int x, int y, int offset, int stride);
 void kernel_cpu_avx2_convert_to_byte(KernelGlobals *kg, uchar4 *rgba, float *buffer,
 	float sample_scale, int x, int y, int offset, int stride);
 void kernel_cpu_avx2_convert_to_half_float(KernelGlobals *kg, uchar4 *rgba, float *buffer,
diff -ru --new-file blender-2.76b.old/intern/cycles/kernel/kernel_metropolis.h blender-2.76b/intern/cycles/kernel/kernel_metropolis.h
--- blender-2.76b.old/intern/cycles/kernel/kernel_metropolis.h	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/intern/cycles/kernel/kernel_metropolis.h	2016-01-14 01:50:21.954309413 +0300
@@ -0,0 +1,268 @@
+/*
+ * Copyright 2011-2013 Blender Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+
+#ifndef __KERNEL_METROPOLIS_H__
+#define __KERNEL_METROPOLIS_H__
+#include "kernel_types.h"
+#include "util_hash.h"
+
+CCL_NAMESPACE_BEGIN
+
+//Based on SmallLuxGPU Code
+
+ccl_device_inline float metro_get_large_step_prob(double *sharedParams) {
+    if (sharedParams[5] == 0)
+        return 0.5;
+    double eta_l = sharedParams[2]/sharedParams[3];
+    double eta_s = sharedParams[4]/sharedParams[5];
+    double eta_0 = sharedParams[6]/sharedParams[7];
+    if (eta_l / eta_0 > 0.1)
+        return clamp(0.5f * (float) (eta_s / (eta_s - eta_l)), 0.1f, 0.9f);
+    else return 0.25f;
+}
+
+ccl_device float metro_mutate(const float x, const float randomValue)
+{
+   const float s1 = 1.0f / 512.0f, s2 = 1.0f / 16.0f;
+
+   const float dx = s1 / (s1 / s2 + fabsf(2.0f * randomValue - 1.0f)) -
+           s1 / (s1 / s2 + 1.0f);
+
+   if (randomValue < 0.5f) {
+       float mutatedX = x + dx;
+       return (mutatedX < 1.0f) ? mutatedX : mutatedX - 1.0f;
+   } else {
+       float mutatedX = x - dx;
+       return (mutatedX < 0.0f) ? mutatedX + 1.0f : mutatedX;
+   }
+}
+
+ccl_device float metro_mutate_scaled(const float x, const float range, const float randomValue)
+{
+   const float s1 = 32.0f;
+   
+   const float dx = range / (s1 / (1.0f + s1) + (s1 * s1) / (1.0f + s1) *
+       fabsf(2.0f * randomValue - 1.0f)) - range / s1;
+
+   float mutatedX = x;
+   if (randomValue < 0.5f) {
+       mutatedX += dx;
+       return (mutatedX < 1.0f) ? mutatedX : (mutatedX - 1.0f);
+   } else {
+       mutatedX -= dx;
+       return (mutatedX < 0.0f) ? (mutatedX + 1.0f) : mutatedX;
+   }
+}
+
+ccl_device float metro_get_mcqmc(KernelGlobals *kg, uint rngPos, uint j, float *rot) {
+    float v = kernel_tex_fetch(__metropolis_mcqmc, (rngPos + j) % METRO_RNG_N) + rot[j];
+    return v - floorf(v);
+}
+
+ccl_device float metro_get_sample(KernelGlobals *kg, MetropolisChain *metro, int dimension)
+{
+   uint sampleStamp = metro->proposedSampleStamps[dimension];
+   float s;
+   if (sampleStamp == 0) {
+       s = metro_get_mcqmc(kg, metro->rngPos, dimension, metro->rngRotation);
+       sampleStamp = 1;
+   } else s = metro->proposedSamples[dimension];
+
+   for (uint st = sampleStamp; st < metro->proposedStamp; ++st)
+       s = metro_mutate(s, metro_get_mcqmc(kg, metro->rngPos, dimension, metro->rngRotation));
+
+   if (s >= 1.f) s = 1.f-FLT_EPSILON;
+   if (s < 0.f) s = 0.f;
+
+   metro->proposedSamples[dimension] = s;
+   metro->proposedSampleStamps[dimension] = metro->proposedStamp;
+   return s;
+}
+
+ccl_device void metro_next_sample(KernelGlobals *kg, MetropolisChain *metro, int width, int height)
+{
+   metro->rngPos += metro->sampleSize;
+   if (metro->rngPos >= METRO_RNG_N)
+       metro->rngPos -= METRO_RNG_N;
+   if (metro->rngPos == 0) {
+       for (int j = 0; j < metro->sampleSize; j++)
+           metro->rngRotation[j] = lcg_step_float(&metro->rng); //Rebuild Cranley-Patterson rotation
+   }
+   //Always mutate the image pixels since they are always needed
+   //The other dimensions are sampled when they are needed to avoid wasting time
+   for (uint j = 0; j < 2; j++) {
+       uint sampleStamp = metro->proposedSampleStamps[j];
+       float s;
+       if (sampleStamp == 0) { //Large step ( => new Sample)?
+           s = metro_get_mcqmc(kg, metro->rngPos, j, metro->rngRotation);
+           sampleStamp = 1;
+       } else s = metro->proposedSamples[j]; //Small step (mutate previous sample)
+
+       for (uint st = sampleStamp; st < metro->proposedStamp; ++st) {
+            float val = metro_get_mcqmc(kg, metro->rngPos, j, metro->rngRotation);
+            float span = j?height:width;
+            float mutation_range = min(kernel_data.integrator.image_mutation_range, span);
+            s = metro_mutate_scaled(s, mutation_range / span, val);
+        }
+
+       if (s >= 1.f) s = 1.f-FLT_EPSILON;
+       if (s < 0.f) s = 0.f;
+
+       metro->proposedSamples[j] = s;
+       metro->proposedSampleStamps[j] = metro->proposedStamp;
+   }
+}
+
+ccl_device void metro_reject_sample(MetropolisChain *metro)
+{
+   metro->proposedStamp = metro->currentStamp;
+   metro->consecRejects++;
+   for (int i = 0; i < metro->sampleSize; i++) {
+       metro->proposedSamples[i] = metro->currentSamples[i];
+       metro->proposedSampleStamps[i] = metro->currentSampleStamps[i];
+   }
+}
+
+ccl_device void metro_accept_sample(MetropolisChain *metro, float newWeight, float newImportance, PassData &pd, float4 &L)
+{
+   metro->weight = newWeight;
+   metro->currentStamp = metro->proposedStamp;
+   metro->currentImportance = newImportance;
+   metro->consecRejects = 0;
+   metro->currentSampleResult = pd;
+   metro->currentL = L;
+   for (int i = 0; i < metro->sampleSize; i++) {
+       metro->currentSamples[i] = metro->proposedSamples[i];
+       metro->currentSampleStamps[i] = metro->proposedSampleStamps[i];
+   }
+}
+
+ccl_device bool metro_consider_sample(KernelGlobals* kg, MetropolisChain *metro, double *sharedParams, float newImportance, float4 L, float *buffer, float *currentBuffer, PassData &pd)
+{
+   const float meanIntensity = (sharedParams[0] > 0.0) ? (float) (sharedParams[0] / sharedParams[1]) : 1.0f;
+
+   float acceptChance;
+   if ((metro->currentImportance > 0.0f) && (metro->consecRejects < kernel_data.integrator.max_consecutive_rejects))
+       acceptChance = min(1.0f, (float) (newImportance / metro->currentImportance));
+   else acceptChance = 1.0f;
+
+   const float newWeight = acceptChance + (metro->isLargeMutation ? 1.0f : 0.0f);
+   metro->weight += 1.0f - acceptChance;
+
+   if ((acceptChance == 1.0f) || (lcg_step_float(&metro->rng) < acceptChance)) { //Accept sample
+       const float norm = metro->weight / (metro->currentImportance / meanIntensity + metro->largeStepProb);
+
+       if (norm > 0.f)
+            kernel_write_pass_data(kg, &metro->currentSampleResult, currentBuffer, 0xffffffff, norm, false, true, metro->currentL, true, true);
+
+       metro_accept_sample(metro, newWeight, newImportance, pd, L);
+        return true;
+   } else { //Reject sample
+       const float norm = newWeight / (newImportance / meanIntensity + metro->largeStepProb);
+   
+       if (norm > 0.f)
+            kernel_write_pass_data(kg, &pd, buffer, 0xffffffff, norm, false, true, L, true, true);
+
+       metro_reject_sample(metro);
+        return false;
+   }
+}
+
+ccl_device void metro_end_sample(KernelGlobals *kg, MetropolisChain *metro, double *sharedParams, int pixelCount)
+{
+    if (metro->cooldown) { //During cooldown, more large mutations are made
+        if (sharedParams[1] > pixelCount) {
+            metro->cooldown = false;
+            metro->largeStepProb = metro_get_large_step_prob(sharedParams);
+        }
+    } else
+        metro->largeStepProb = metro_get_large_step_prob(sharedParams);
+    metro->isLargeMutation = (lcg_step_float(&metro->rng) < metro->largeStepProb);
+
+    if (metro->isLargeMutation) {
+        metro->proposedStamp = 1;
+        for (int i = 0; i < metro->sampleSize; i++)
+            metro->proposedSampleStamps[i] = 0;
+    } else
+        metro->proposedStamp++;
+}
+
+ccl_device void metro_init_chain(KernelGlobals *kg, MetropolisChain *m) {
+    m->sampleSize = PRNG_BASE_NUM + (kernel_data.integrator.max_bounce + kernel_data.integrator.transparent_max_bounce + 3)*PRNG_BOUNCE_NUM;
+    m->rng = lcg_init(hash_int_2d(kernel_data.integrator.seed, (uint) (((unsigned long) m) & 0xffffffff)));
+    m->rngPos = METRO_RNG_N - m->sampleSize; //Init the position so that it is 0 for the first sample
+    m->isLargeMutation = true;
+    m->largeStepProb = 0.5f;
+    m->cooldown = true;
+    m->weight = 0.0f;
+    m->consecRejects = 0;
+    m->proposedStamp = 1;
+    m->currentStamp = 1;
+    m->currentImportance = 0.0f;
+    for (int i = 0; i < sizeof(PassData) / 4; i++)
+            ((float*) &m->currentSampleResult)[i] = 0.0f;
+    m->currentL = make_float4(0.0f, 0.0f, 0.0f, 0.0f);
+    m->currentSamples = (float*) (m + 1);
+    m->proposedSamples = m->currentSamples + m->sampleSize;
+    m->rngRotation = m->proposedSamples + m->sampleSize;
+    m->currentSampleStamps = (int*) (m->rngRotation + m->sampleSize);
+    m->proposedSampleStamps = m->currentSampleStamps + m->sampleSize;
+    //No need to setup current sample arrays since currentImportance = 0 so the first sample is always accepted
+    for (int i = 0; i < m->sampleSize; i++)
+        m->proposedSampleStamps[i] = 0;
+}
+
+ccl_device_inline void metro_update_shared(double *sharedParams, double newImportance, bool sampled, bool largeStep, bool accepted, bool nonzero) {
+    if (largeStep) {
+        atomicAddD(&sharedParams[0], newImportance);
+        atomicAddD(&sharedParams[1], 1.0);
+    }
+    if (sampled) {
+        if (largeStep) {
+            atomicAddD(&sharedParams[2], accepted?1.0:0.0);
+            atomicAddD(&sharedParams[3], 1.0);
+        } else {
+            atomicAddD(&sharedParams[4], accepted?1.0:0.0);
+            atomicAddD(&sharedParams[5], 1.0);
+        }
+    }
+    atomicAddD(&sharedParams[6], nonzero?1.0:0.0);
+    atomicAddD(&sharedParams[7], 1.0);
+/*#ifdef __KERNEL_CPU__
+    while (atomicExch((int*) &sharedParams[3], 1) != 0);
+    *((char*) &sharedParams[3]) = 0;
+    double oldMean = (sharedParams[1] > 0)?(sharedParams[0]/sharedParams[1]):0;
+    sharedParams[0] += newImportance;
+    sharedParams[1] += 1.0;
+    sharedParams[2] += (newImportance - oldMean) * (newImportance - (sharedParams[0]/sharedParams[1]));
+#else
+    if ((threadIdx.x % 32) == 0)
+        while (atomicExch((int*) &sharedParams[3], 1) != 0);
+    for (int i = 0; i < 32; i++)
+        if (i == (threadIdx.x % 32)) {
+            *((char*) &sharedParams[3]) = 0;
+            double oldMean = (sharedParams[1] > 0)?(sharedParams[0]/sharedParams[1]):0;
+            double newImportanceD = (double) newImportance;
+            sharedParams[0] += newImportanceD;
+            sharedParams[1] += 1.0;
+            sharedParams[2] += (newImportanceD - oldMean) * (newImportanceD - (sharedParams[0]/sharedParams[1]));
+        }
+#endif*/
+}
+
+CCL_NAMESPACE_END
+
+#endif
diff -ru --new-file blender-2.76b.old/intern/cycles/kernel/kernel_passes.h blender-2.76b/intern/cycles/kernel/kernel_passes.h
--- blender-2.76b.old/intern/cycles/kernel/kernel_passes.h	2015-10-27 19:57:22.000000000 +0300
+++ blender-2.76b/intern/cycles/kernel/kernel_passes.h	2016-01-14 19:37:07.801395954 +0300
@@ -18,16 +18,35 @@
 
 ccl_device_inline void kernel_write_pass_float(ccl_global float *buffer, int sample, float value)
 {
+	if (!buffer) return;
+#if defined(__SPLIT_KERNEL__) && defined(__WORK_STEALING__)
+	ccl_global float *buf_x = buffer + 0;
+
+	atomic_add_float(buf_x, value.x);
+#else
 	ccl_global float *buf = buffer;
+	*buf = (sample == 0)? value: *buf + value;
+#endif // __SPLIT_KERNEL__ && __WORK_STEALING__
+}
+
+ccl_device_inline void kernel_write_pass_float2(ccl_global float *buffer, int sample, float2 value)
+{
+	if (!buffer) return;
 #if defined(__SPLIT_KERNEL__) && defined(__WORK_STEALING__)
-	atomic_add_float(buf, value);
+	ccl_global float *buf_x = buffer + 0;
+	ccl_global float *buf_y = buffer + 1;
+
+	atomic_add_float(buf_x, value.x);
+	atomic_add_float(buf_y, value.y);
 #else
+	ccl_global float2 *buf = (ccl_global float2*)buffer;
 	*buf = (sample == 0)? value: *buf + value;
 #endif // __SPLIT_KERNEL__ && __WORK_STEALING__
 }
 
 ccl_device_inline void kernel_write_pass_float3(ccl_global float *buffer, int sample, float3 value)
 {
+	if (!buffer) return;
 #if defined(__SPLIT_KERNEL__) && defined(__WORK_STEALING__)
 	ccl_global float *buf_x = buffer + 0;
 	ccl_global float *buf_y = buffer + 1;
@@ -44,6 +63,7 @@
 
 ccl_device_inline void kernel_write_pass_float4(ccl_global float *buffer, int sample, float4 value)
 {
+	if (!buffer) return;
 #if defined(__SPLIT_KERNEL__) && defined(__WORK_STEALING__)
 	ccl_global float *buf_x = buffer + 0;
 	ccl_global float *buf_y = buffer + 1;
@@ -60,8 +80,226 @@
 #endif // __SPLIT_KERNEL__ && __WORK_STEALING__
 }
 
-ccl_device_inline void kernel_write_data_passes(KernelGlobals *kg, ccl_global float *buffer, PathRadiance *L,
-	ShaderData *sd, int sample, ccl_addr_space PathState *state, float3 throughput)
+ccl_device_inline void kernel_write_pass_float_atomic(ccl_global float *buffer, int sample, float value)
+{
+	if (!buffer) return;
+	ccl_global float *buf = buffer;
+	if (sample == 0)
+		*buf = value;
+	else
+		atomicAddF(buf, value);
+}
+
+ccl_device_inline void kernel_write_pass_float2_atomic(ccl_global float *buffer, int sample, float2 value)
+{
+	if (!buffer) return;
+	ccl_global float2 *buf = (ccl_global float2*)buffer;
+	if (sample == 0)
+		*buf = value;
+	else {
+		atomicAddF(&buf->x, value.x);
+		atomicAddF(&buf->y, value.y);
+	}
+}
+
+ccl_device_inline void kernel_write_pass_float3_atomic(ccl_global float *buffer, int sample, float3 value)
+{
+	if (!buffer) return;
+	ccl_global float3 *buf = (ccl_global float3*)buffer;
+	if (sample == 0)
+		*buf = value;
+	else {
+		atomicAddF(&buf->x, value.x);
+		atomicAddF(&buf->y, value.y);
+		atomicAddF(&buf->z, value.z);
+	}
+}
+
+ccl_device_inline void kernel_write_pass_float4_atomic(ccl_global float *buffer, int sample, float4 value)
+{
+	if (!buffer) return;
+	ccl_global float4 *buf = (ccl_global float4*)buffer;
+	if (sample == 0)
+		*buf = value;
+	else {
+		atomicAddF(&buf->x, value.x);
+		atomicAddF(&buf->y, value.y);
+		atomicAddF(&buf->z, value.z);
+		atomicAddF(&buf->w, value.w);
+	}
+}
+
+ccl_device_inline void kernel_setup_pass_data(KernelGlobals *kg, PassData* pd) {
+	int flag = kernel_data.film.pass_flag;
+	if(flag & PASS_DEPTH)
+		pd->pass_depth = 0.0f;
+	if(flag & PASS_OBJECT_ID)
+		pd->pass_object_id = 0.0f;
+	if(flag & PASS_MATERIAL_ID)
+		pd->pass_material_id = 0.0f;
+
+	if(flag & PASS_NORMAL)
+		pd->pass_normal = make_float3(0.0f, 0.0f, 0.0f);
+	if(flag & PASS_MOTION)
+		pd->pass_motion = make_float4(0.0f, 0.0f, 0.0f, 0.0f);
+	if(flag & PASS_MOTION_WEIGHT)
+		pd->pass_motion_weight = 0.0f;
+	if(flag & PASS_UV)
+		pd->pass_uv = make_float3(0.0f, 0.0f, 0.0f);
+
+	if(flag & PASS_DIFFUSE_INDIRECT)
+		pd->pass_diffuse_indirect = make_float3(0.0f, 0.0f, 0.0f);
+	if(flag & PASS_GLOSSY_INDIRECT)
+		pd->pass_glossy_indirect = make_float3(0.0f, 0.0f, 0.0f);
+	if(flag & PASS_TRANSMISSION_INDIRECT)
+		pd->pass_transmission_indirect = make_float3(0.0f, 0.0f, 0.0f);
+	if(flag & PASS_SUBSURFACE_INDIRECT)
+		pd->pass_subsurface_indirect = make_float3(0.0f, 0.0f, 0.0f);
+	if(flag & PASS_DIFFUSE_DIRECT)
+		pd->pass_diffuse_direct = make_float3(0.0f, 0.0f, 0.0f);
+	if(flag & PASS_GLOSSY_DIRECT)
+		pd->pass_glossy_direct = make_float3(0.0f, 0.0f, 0.0f);
+	if(flag & PASS_TRANSMISSION_DIRECT)
+		pd->pass_transmission_direct = make_float3(0.0f, 0.0f, 0.0f);
+	if(flag & PASS_SUBSURFACE_DIRECT)
+		pd->pass_subsurface_direct = make_float3(0.0f, 0.0f, 0.0f);
+	if(flag & PASS_DIFFUSE_COLOR)
+		pd->pass_diffuse_color = make_float3(0.0f, 0.0f, 0.0f);
+	if(flag & PASS_GLOSSY_COLOR)
+		pd->pass_glossy_color = make_float3(0.0f, 0.0f, 0.0f);
+	if(flag & PASS_TRANSMISSION_COLOR)
+		pd->pass_transmission_color = make_float3(0.0f, 0.0f, 0.0f);
+	if(flag & PASS_SUBSURFACE_COLOR)
+		pd->pass_subsurface_color = make_float3(0.0f, 0.0f, 0.0f);
+
+	if(flag & PASS_EMISSION)
+		pd->pass_emission = make_float3(0.0f, 0.0f, 0.0f);
+	if(flag & PASS_BACKGROUND)
+		pd->pass_background = make_float3(0.0f, 0.0f, 0.0f);
+	if(flag & PASS_AO)
+		pd->pass_ao = make_float3(0.0f, 0.0f, 0.0f);
+
+	if(flag & PASS_SHADOW) 
+		pd->pass_shadow = make_float4(0.0f, 0.0f, 0.0f, 0.0f);
+	if(flag & PASS_MIST)
+		pd->pass_mist = 0.0f;
+}
+
+
+#define write_float(p, s, v) {if (write_atomic) kernel_write_pass_float_atomic(p, s, v); else kernel_write_pass_float(p, s, v);}
+#define write_float2(p, s, v) {if (write_atomic) kernel_write_pass_float_atomic2(p, s, v); else kernel_write_pass_float2(p, s, v);}
+#define write_float3(p, s, v) {if (write_atomic) kernel_write_pass_float_atomic3(p, s, v); else kernel_write_pass_float3(p, s, v);}
+#define write_float4(p, s, v) {if (write_atomic) kernel_write_pass_float_atomic4(p, s, v); else kernel_write_pass_float4(p, s, v);}
+
+ccl_device_inline void kernel_write_pass_data(KernelGlobals *kg, PassData* pd, ccl_global float* buffer, int sample,
+	float weight, bool writeConstData, bool writeVarData, float4 L, bool writeSamples, bool write_atomic) {
+	int flag = kernel_data.film.pass_flag;
+	if(writeConstData) { //Data that is not sample-dependent
+		if(flag & PASS_DEPTH)
+			kernel_write_pass_float (buffer + kernel_data.film.pass_depth,
+									 sample, pd->pass_depth * weight);
+		if(flag & PASS_OBJECT_ID)
+			kernel_write_pass_float (buffer + kernel_data.film.pass_object_id,
+									 sample, pd->pass_object_id * weight);
+		if(flag & PASS_MATERIAL_ID)
+			kernel_write_pass_float (buffer + kernel_data.film.pass_material_id,
+									 sample, pd->pass_material_id * weight);
+		if(flag & PASS_UV)
+			kernel_write_pass_float3(buffer + kernel_data.film.pass_uv,
+									 sample, pd->pass_uv * weight);
+		if(flag & PASS_NORMAL)
+			kernel_write_pass_float3(buffer + kernel_data.film.pass_normal,
+									 sample, pd->pass_normal * weight);
+		if(flag & PASS_MOTION)
+			kernel_write_pass_float4(buffer + kernel_data.film.pass_motion,
+									 sample, pd->pass_motion * weight);
+		if(flag & PASS_MOTION_WEIGHT)
+			kernel_write_pass_float (buffer + kernel_data.film.pass_motion_weight,
+									 sample, pd->pass_motion_weight * weight);
+	}
+
+	if(writeVarData) { //Data that varies according to sample
+		float s = *(buffer + kernel_data.film.pass_samples);
+		float3 oldMean;
+		if (flag & PASS_VARIANCE)
+			oldMean = (s == 0)?(make_float3(0.0f, 0.0f, 0.0f)):(*((float3*) buffer) / s);
+		kernel_write_pass_float4(buffer, sample, L * weight);
+		if(flag & PASS_DIFFUSE_COLOR)
+			kernel_write_pass_float3(buffer + kernel_data.film.pass_diffuse_color,
+									 sample, pd->pass_diffuse_color * weight);
+		if(flag & PASS_GLOSSY_COLOR)
+			kernel_write_pass_float3(buffer + kernel_data.film.pass_glossy_color,
+									 sample, pd->pass_glossy_color * weight);
+		if(flag & PASS_TRANSMISSION_COLOR)
+			kernel_write_pass_float3(buffer + kernel_data.film.pass_transmission_color,
+									 sample, pd->pass_transmission_color * weight);
+		if(flag & PASS_SUBSURFACE_COLOR)
+			kernel_write_pass_float3(buffer + kernel_data.film.pass_subsurface_color,
+									 sample, pd->pass_subsurface_color * weight);
+
+		if(flag & PASS_DIFFUSE_INDIRECT)
+			kernel_write_pass_float3(buffer + kernel_data.film.pass_diffuse_indirect,
+									 sample, pd->pass_diffuse_indirect * weight);
+		if(flag & PASS_GLOSSY_INDIRECT)
+			kernel_write_pass_float3(buffer + kernel_data.film.pass_glossy_indirect,
+									 sample, pd->pass_glossy_indirect * weight);
+		if(flag & PASS_TRANSMISSION_INDIRECT)
+			kernel_write_pass_float3(buffer + kernel_data.film.pass_transmission_indirect,
+									 sample, pd->pass_transmission_indirect * weight);
+		if(flag & PASS_SUBSURFACE_INDIRECT)
+			kernel_write_pass_float3(buffer + kernel_data.film.pass_subsurface_indirect,
+									 sample, pd->pass_subsurface_indirect * weight);
+
+		if(flag & PASS_DIFFUSE_DIRECT)
+			kernel_write_pass_float3(buffer + kernel_data.film.pass_diffuse_direct,
+									 sample, pd->pass_diffuse_direct * weight);
+		if(flag & PASS_GLOSSY_DIRECT)
+			kernel_write_pass_float3(buffer + kernel_data.film.pass_glossy_direct,
+									 sample, pd->pass_glossy_direct * weight);
+		if(flag & PASS_TRANSMISSION_DIRECT)
+			kernel_write_pass_float3(buffer + kernel_data.film.pass_transmission_direct,
+									 sample, pd->pass_transmission_direct * weight);
+		if(flag & PASS_SUBSURFACE_DIRECT)
+			kernel_write_pass_float3(buffer + kernel_data.film.pass_subsurface_direct,
+									 sample, pd->pass_subsurface_direct * weight);
+
+		if(flag & PASS_EMISSION)
+			kernel_write_pass_float3(buffer + kernel_data.film.pass_emission,
+									 sample, pd->pass_emission * weight);
+		if(flag & PASS_BACKGROUND)
+			kernel_write_pass_float3(buffer + kernel_data.film.pass_background,
+									 sample, pd->pass_background * weight);
+		if(flag & PASS_BACKGROUND)
+			kernel_write_pass_float3(buffer + kernel_data.film.pass_background,
+									 sample, pd->pass_background * weight);
+		if(flag & PASS_AO)
+			kernel_write_pass_float3(buffer + kernel_data.film.pass_ao,
+									 sample, pd->pass_ao * weight);
+
+		if(flag & PASS_SHADOW && writeSamples)
+			kernel_write_pass_float4(buffer + kernel_data.film.pass_shadow,
+									 sample, make_float4(1.0f, 1.0f, 1.0f, 1.0f));
+		if(flag & PASS_MIST)
+			kernel_write_pass_float (buffer + kernel_data.film.pass_mist,
+									 sample, pd->pass_mist * weight);
+		if(flag & PASS_VARIANCE && s > 0.0f) {
+			float3 L3 = make_float3(L.x, L.y, L.z);
+			float3 newMean = *((float3*) buffer) / (*(buffer + kernel_data.film.pass_samples) + weight);
+			kernel_write_pass_float3(buffer + kernel_data.film.pass_variance,
+									 sample, (L3 - newMean) * (L3 - oldMean) * weight);
+		}
+		if(flag & PASS_SAMPLES && writeSamples)
+			kernel_write_pass_float(buffer + kernel_data.film.pass_samples,
+									 sample, weight);
+	}
+}
+
+#undef write_float
+#undef write_float2
+#undef write_float3
+#undef write_float4
+
+ccl_device_inline void kernel_write_data_passes(KernelGlobals *kg, PathRadiance *L, ShaderData *sd, int sample, PathState *state, float3 throughput, PassData* pd)
 {
 #ifdef __PASSES__
 	int path_flag = state->flag;
@@ -81,32 +319,22 @@
 		{
 
 			if(sample == 0) {
-				if(flag & PASS_DEPTH) {
-					float depth = camera_distance(kg, ccl_fetch(sd, P));
-					kernel_write_pass_float(buffer + kernel_data.film.pass_depth, sample, depth);
-				}
-				if(flag & PASS_OBJECT_ID) {
-					float id = object_pass_id(kg, ccl_fetch(sd, object));
-					kernel_write_pass_float(buffer + kernel_data.film.pass_object_id, sample, id);
-				}
-				if(flag & PASS_MATERIAL_ID) {
-					float id = shader_pass_id(kg, sd);
-					kernel_write_pass_float(buffer + kernel_data.film.pass_material_id, sample, id);
-				}
-			}
-
-			if(flag & PASS_NORMAL) {
-				float3 normal = ccl_fetch(sd, N);
-				kernel_write_pass_float3(buffer + kernel_data.film.pass_normal, sample, normal);
-			}
-			if(flag & PASS_UV) {
-				float3 uv = primitive_uv(kg, sd);
-				kernel_write_pass_float3(buffer + kernel_data.film.pass_uv, sample, uv);
+				if(flag & PASS_DEPTH)
+					pd->pass_depth = camera_distance(kg, sd->P);
+				if(flag & PASS_OBJECT_ID)
+					pd->pass_object_id = object_pass_id(kg, sd->object);
+				if(flag & PASS_MATERIAL_ID)
+					pd->pass_material_id = shader_pass_id(kg, sd);
 			}
+			
+			if(flag & PASS_NORMAL)
+				pd->pass_normal = sd->N;
+			if(flag & PASS_UV)
+				pd->pass_uv = primitive_uv(kg, sd);
 			if(flag & PASS_MOTION) {
 				float4 speed = primitive_motion_vector(kg, sd);
-				kernel_write_pass_float4(buffer + kernel_data.film.pass_motion, sample, speed);
-				kernel_write_pass_float(buffer + kernel_data.film.pass_motion_weight, sample, 1.0f);
+				pd->pass_motion = primitive_motion_vector(kg, sd);
+				pd->pass_motion_weight = 1;
 			}
 
 			state->flag |= PATH_RAY_SINGLE_PASS_DONE;
@@ -149,7 +377,7 @@
 #endif
 }
 
-ccl_device_inline void kernel_write_light_passes(KernelGlobals *kg, ccl_global float *buffer, PathRadiance *L, int sample)
+ccl_device_inline void kernel_write_light_passes(KernelGlobals *kg, PathRadiance *L, int sample, PassData* pd)
 {
 #ifdef __PASSES__
 	int flag = kernel_data.film.pass_flag;
@@ -158,44 +386,44 @@
 		return;
 	
 	if(flag & PASS_DIFFUSE_INDIRECT)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_diffuse_indirect, sample, L->indirect_diffuse);
+		pd->pass_diffuse_indirect = L->indirect_diffuse;
 	if(flag & PASS_GLOSSY_INDIRECT)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_glossy_indirect, sample, L->indirect_glossy);
+		pd->pass_glossy_indirect = L->indirect_glossy;
 	if(flag & PASS_TRANSMISSION_INDIRECT)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_transmission_indirect, sample, L->indirect_transmission);
+		pd->pass_transmission_indirect = L->indirect_transmission;
 	if(flag & PASS_SUBSURFACE_INDIRECT)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_subsurface_indirect, sample, L->indirect_subsurface);
+		pd->pass_subsurface_indirect = L->indirect_subsurface;
 	if(flag & PASS_DIFFUSE_DIRECT)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_diffuse_direct, sample, L->direct_diffuse);
+		pd->pass_diffuse_direct = L->direct_diffuse;
 	if(flag & PASS_GLOSSY_DIRECT)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_glossy_direct, sample, L->direct_glossy);
+		pd->pass_glossy_direct = L->direct_glossy;
 	if(flag & PASS_TRANSMISSION_DIRECT)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_transmission_direct, sample, L->direct_transmission);
+		pd->pass_transmission_direct = L->direct_transmission;
 	if(flag & PASS_SUBSURFACE_DIRECT)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_subsurface_direct, sample, L->direct_subsurface);
+		pd->pass_subsurface_direct = L->direct_subsurface;
 
 	if(flag & PASS_EMISSION)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_emission, sample, L->emission);
+		pd->pass_emission = L->emission;
 	if(flag & PASS_BACKGROUND)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_background, sample, L->background);
+		pd->pass_background = L->background;
 	if(flag & PASS_AO)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_ao, sample, L->ao);
+		pd->pass_ao = L->ao;
 
 	if(flag & PASS_DIFFUSE_COLOR)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_diffuse_color, sample, L->color_diffuse);
+		pd->pass_diffuse_color = L->color_diffuse;
 	if(flag & PASS_GLOSSY_COLOR)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_glossy_color, sample, L->color_glossy);
+		pd->pass_glossy_color = L->color_glossy;
 	if(flag & PASS_TRANSMISSION_COLOR)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_transmission_color, sample, L->color_transmission);
+		pd->pass_transmission_color = L->color_transmission;
 	if(flag & PASS_SUBSURFACE_COLOR)
-		kernel_write_pass_float3(buffer + kernel_data.film.pass_subsurface_color, sample, L->color_subsurface);
+		pd->pass_subsurface_color = L->color_subsurface;
 	if(flag & PASS_SHADOW) {
 		float4 shadow = L->shadow;
 		shadow.w = kernel_data.film.pass_shadow_scale;
-		kernel_write_pass_float4(buffer + kernel_data.film.pass_shadow, sample, shadow);
+		pd->pass_shadow = shadow;
 	}
 	if(flag & PASS_MIST)
-		kernel_write_pass_float(buffer + kernel_data.film.pass_mist, sample, 1.0f - L->mist);
+		pd->pass_mist = 1.0f - L->mist;
 #endif
 }
 
diff -ru --new-file blender-2.76b.old/intern/cycles/kernel/kernel_path_branched.h blender-2.76b/intern/cycles/kernel/kernel_path_branched.h
--- blender-2.76b.old/intern/cycles/kernel/kernel_path_branched.h	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/intern/cycles/kernel/kernel_path_branched.h	2016-01-14 19:56:35.805407857 +0300
@@ -180,7 +180,7 @@
 }
 #endif
 
-ccl_device float4 kernel_branched_path_integrate(KernelGlobals *kg, RNG *rng, int sample, Ray ray, ccl_global float *buffer)
+ccl_device float4 kernel_branched_path_integrate(KernelGlobals *kg, RNG *rng, int sample, Ray ray, PassData* pd)
 {
 	/* initialize */
 	PathRadiance L;
@@ -280,8 +280,8 @@
 					/* scatter sample. if we use distance sampling and take just one
 					 * sample for direct and indirect light, we could share this
 					 * computation, but makes code a bit complex */
-					float rphase = path_state_rng_1D_for_decision(kg, &tmp_rng, &ps, PRNG_PHASE);
-					float rscatter = path_state_rng_1D_for_decision(kg, &tmp_rng, &ps, PRNG_SCATTER_DISTANCE);
+					float rphase = path_state_rng_1D_for_decision(kg, kernel_data.integrator.metropolis?rng:&tmp_rng, &ps, PRNG_PHASE);
+					float rscatter = path_state_rng_1D_for_decision(kg, kernel_data.integrator.metropolis?rng:&tmp_rng, &ps, PRNG_SCATTER_DISTANCE);
 
 					VolumeIntegrateResult result = kernel_volume_decoupled_scatter(kg,
 						&ps, &pray, &volume_sd, &tp, rphase, rscatter, &volume_segment, NULL, false);
@@ -398,7 +398,7 @@
 #endif
 
 		/* holdout mask objects do not write data passes */
-		kernel_write_data_passes(kg, buffer, &L, &sd, sample, &state, throughput);
+		kernel_write_data_passes(kg, &L, &sd, sample, &state, throughput, pd);
 
 #ifdef __EMISSION__
 		/* emission */
@@ -488,7 +488,7 @@
 
 	float3 L_sum = path_radiance_clamp_and_sum(kg, &L);
 
-	kernel_write_light_passes(kg, buffer, &L, sample);
+	kernel_write_light_passes(kg, &L, sample, pd);
 
 #ifdef __KERNEL_DEBUG__
 	kernel_write_debug_passes(kg, buffer, &state, &debug_data, sample);
@@ -508,6 +508,9 @@
 	rng_state += index;
 	buffer += index*pass_stride;
 
+	if (kernel_data.film.pass_flag & PASS_SAMPLES)
+		sample = (int) *(buffer + kernel_data.film.pass_samples);
+
 	/* initialize random numbers and ray */
 	RNG rng;
 	Ray ray;
@@ -516,16 +519,18 @@
 
 	/* integrate */
 	float4 L;
+	PassData pd;
+	kernel_setup_pass_data(kg, &pd);
 
 	if(ray.t != 0.0f)
-		L = kernel_branched_path_integrate(kg, &rng, sample, ray, buffer);
+		L = kernel_branched_path_integrate(kg, &rng, sample, ray, &pd);
 	else
 		L = make_float4(0.0f, 0.0f, 0.0f, 0.0f);
 
 	/* accumulate result in output buffer */
-	kernel_write_pass_float4(buffer, sample, L);
+	kernel_write_pass_data(kg, &pd, buffer, sample, 1.0f, sample == 0, true, L, true, false);
 
-	path_rng_end(kg, rng_state, rng);
+	path_rng_end(kg, rng_state, &rng);
 }
 
 #endif  /* __BRANCHED_PATH__ */
diff -ru --new-file blender-2.76b.old/intern/cycles/kernel/kernel_path.h blender-2.76b/intern/cycles/kernel/kernel_path.h
--- blender-2.76b.old/intern/cycles/kernel/kernel_path.h	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/intern/cycles/kernel/kernel_path.h	2016-01-14 20:02:29.355212968 +0300
@@ -39,6 +39,8 @@
 #include "kernel_volume.h"
 #endif
 
+#include "kernel_metropolis.h"
+
 #include "kernel_path_state.h"
 #include "kernel_shadow.h"
 #include "kernel_emission.h"
@@ -393,7 +395,7 @@
 }
 #endif
 
-ccl_device float4 kernel_path_integrate(KernelGlobals *kg, RNG *rng, int sample, Ray ray, ccl_global float *buffer)
+ccl_device float4 kernel_path_integrate(KernelGlobals *kg, RNG *rng, int sample, Ray ray, PassData* pd)
 {
 	/* initialize */
 	PathRadiance L;
@@ -597,7 +599,7 @@
 #endif
 
 		/* holdout mask objects do not write data passes */
-		kernel_write_data_passes(kg, buffer, &L, &sd, sample, &state, throughput);
+		kernel_write_data_passes(kg, &L, &sd, sample, &state, throughput, pd);
 
 		/* blurring of bsdf after bounces, for rays that have a small likelihood
 		 * of following this particular path (diffuse, rough glossy) */
@@ -662,7 +664,7 @@
 
 	float3 L_sum = path_radiance_clamp_and_sum(kg, &L);
 
-	kernel_write_light_passes(kg, buffer, &L, sample);
+	kernel_write_light_passes(kg, &L, sample, pd);
 
 #ifdef __KERNEL_DEBUG__
 	kernel_write_debug_passes(kg, buffer, &state, &debug_data, sample);
@@ -682,6 +684,9 @@
 	rng_state += index;
 	buffer += index*pass_stride;
 
+	if (kernel_data.film.pass_flag & PASS_SAMPLES)
+		sample = (int) *(buffer + kernel_data.film.pass_samples);
+
 	/* initialize random numbers and ray */
 	RNG rng;
 	Ray ray;
@@ -690,17 +695,93 @@
 
 	/* integrate */
 	float4 L;
+	PassData pd;
+	kernel_setup_pass_data(kg, &pd);
 
 	if(ray.t != 0.0f)
-		L = kernel_path_integrate(kg, &rng, sample, ray, buffer);
+		L = kernel_path_integrate(kg, &rng, sample, ray, &pd);
 	else
 		L = make_float4(0.0f, 0.0f, 0.0f, 0.0f);
 
 	/* accumulate result in output buffer */
-	kernel_write_pass_float4(buffer, sample, L);
+	kernel_write_pass_data(kg, &pd, buffer, sample, 1.0f, sample == 0, true, L, true, false);
 
-	path_rng_end(kg, rng_state, rng);
+	path_rng_end(kg, rng_state, &rng);
 }
 
-CCL_NAMESPACE_END
+#ifdef __METROPOLIS__
+ccl_device void kernel_metropolis_first_pass(KernelGlobals *kg, ccl_global float *buffer, double *sharedParams, ccl_global uint *rng_state, int x, int y, int offset, int stride)
+{
+	int index = offset + x + y*stride;
+	int pass_stride = kernel_data.film.pass_stride;
+	rng_state += index;
+	buffer += index*pass_stride;
+	
+	RNG rng;
+	Ray ray;
+	PassData pd;
+	kernel_path_trace_setup(kg, rng_state, 0, x, y, &rng, &ray);
+	kernel_setup_pass_data(kg, &pd);
+	
+	float4 L = kernel_path_integrate(kg, &rng, 0, ray, &pd);
+	
+	kernel_write_pass_data(kg, &pd, buffer, 0, 1.0f, true, true, make_float4(0.0f, 0.0f, 0.0f, 0.0f), false, false);
+	path_rng_end(kg, rng_state, &rng);
+	metro_update_shared(sharedParams, linear_rgb_to_gray(L), false, false, false, !(L == make_float4(0.0f, 0.0f, 0.0f, 0.0f)));
+}
+
+ccl_device void kernel_metropolis_warmup(KernelGlobals *kg, ccl_global uint *rng_state, double *sharedParams, int sample, int x, int y, int offset, int stride) {
+	int index = offset + x + y*stride;
+	rng_state += index;
+	RNG rng;
+	Ray ray;
+	PassData pd;
+	kernel_path_trace_setup(kg, rng_state, sample, x, y, &rng, &ray);
+	kernel_setup_pass_data(kg, &pd);
+	float4 L = kernel_path_integrate(kg, &rng, sample, ray, &pd);
+	path_rng_end(kg, rng_state, &rng);
+	metro_update_shared(sharedParams, linear_rgb_to_gray(L), false, false, false, !(L == make_float4(0.0f, 0.0f, 0.0f, 0.0f)));
+}
+
+ccl_device bool kernel_metropolis_step(KernelGlobals *kg, float *rbuffer, MetropolisChain *metro, double *sharedParams, int sx, int sy, int w, int h, int offset, int stride)
+{
+	metro_next_sample(kg, metro, w, h);
+
+	//Evaluate samples
+	float4 L;
+	int x, y, cx, cy;
+	x = (int) (metro->proposedSamples[0]*w) + sx;
+	y = (int) (metro->proposedSamples[1]*h) + sy;
+	cx = (int) (metro->currentSamples[0]*w) + sx;
+	cy = (int) (metro->currentSamples[1]*h) + sy;
 
+	Ray ray;
+	PassData pd;
+	camera_sample(kg, x, y, metro->proposedSamples[0]*w - x + sx, //Fractional parts of the pixel coords
+							metro->proposedSamples[1]*h - y + sy,
+							metro_get_sample(kg, metro, PRNG_LENS_U),
+							metro_get_sample(kg, metro, PRNG_LENS_V),
+							metro_get_sample(kg, metro, PRNG_TIME), &ray);
+	kernel_setup_pass_data(kg, &pd);
+
+	if(ray.t != 0.0f)
+		L = kernel_path_integrate(kg, (RNG*) metro, 0xffffffff, ray, &pd); //0xffffffff means "use metropolis rng"
+	else
+		L = make_float4(0.0f, 0.0f, 0.0f, 0.0f);
+
+	float newImportance = linear_rgb_to_gray(L);
+	/*if ((kernel_data.integrator.map_interval > 0) && sample >= kernel_data.integrator.map_interval)
+		newImportance *= tile.buffers->importance_map[((int) (m.proposedSamples[1]*tile.h))*tile.w + ((int) (m.proposedSamples[0]*tile.w))];*/
+
+	float  *buffer = rbuffer + (offset +  y*stride +  x)*kernel_data.film.pass_stride;
+	float *cbuffer = rbuffer + (offset + cy*stride + cx)*kernel_data.film.pass_stride;
+	bool accepted = metro_consider_sample(kg, metro, sharedParams, newImportance, L, buffer, cbuffer, pd);
+
+	metro_update_shared(sharedParams, newImportance, true, metro->isLargeMutation, accepted, !(L == make_float4(0.0f, 0.0f, 0.0f, 0.0f)));
+
+	metro_end_sample(kg, metro, sharedParams, w*h);
+	return accepted;
+}
+#endif
+
+CCL_NAMESPACE_END
diff -ru --new-file blender-2.76b.old/intern/cycles/kernel/kernel_random.h blender-2.76b/intern/cycles/kernel/kernel_random.h
--- blender-2.76b.old/intern/cycles/kernel/kernel_random.h	2015-10-27 19:57:22.000000000 +0300
+++ blender-2.76b/intern/cycles/kernel/kernel_random.h	2016-01-14 15:33:49.937686317 +0300
@@ -18,6 +18,10 @@
 
 CCL_NAMESPACE_BEGIN
 
+#ifdef __METROPOLIS__
+ccl_device float metro_get_sample(KernelGlobals *kg, MetropolisChain *metro, int dimension);
+#endif
+
 #ifdef __SOBOL__
 
 /* skip initial numbers that are not as well distributed, especially the
@@ -100,6 +104,11 @@
 
 ccl_device_inline float path_rng_1D(KernelGlobals *kg, ccl_addr_space RNG *rng, int sample, int num_samples, int dimension)
 {
+#ifdef __METROPOLIS__
+	if(kernel_data.integrator.metropolis && sample == 0xffffffff)
+		return metro_get_sample(kg, (MetropolisChain*) rng, dimension);
+#endif
+
 #ifdef __CMJ__
 	if(kernel_data.integrator.sampling_pattern == SAMPLING_PATTERN_CMJ) {
 		/* correlated multi-jittered */
@@ -134,6 +143,13 @@
 
 ccl_device_inline void path_rng_2D(KernelGlobals *kg, ccl_addr_space RNG *rng, int sample, int num_samples, int dimension, float *fx, float *fy)
 {
+#ifdef __METROPOLIS__
+	if(kernel_data.integrator.metropolis && sample == 0xffffffff) {
+		*fx = metro_get_sample(kg, (MetropolisChain*) rng, dimension);
+		*fy = metro_get_sample(kg, (MetropolisChain*) rng, dimension + 1);
+	}
+	else
+#endif
 #ifdef __CMJ__
 	if(kernel_data.integrator.sampling_pattern == SAMPLING_PATTERN_CMJ) {
 		/* correlated multi-jittered */
@@ -184,7 +200,7 @@
 #endif
 }
 
-ccl_device void path_rng_end(KernelGlobals *kg, ccl_global uint *rng_state, RNG rng)
+ccl_device void path_rng_end(KernelGlobals *kg, ccl_global uint *rng_state, RNG* rng)
 {
 	/* nothing to do */
 }
@@ -193,14 +209,14 @@
 
 /* Linear Congruential Generator */
 
-ccl_device_inline float path_rng_1D(KernelGlobals *kg, RNG& rng, int sample, int num_samples, int dimension)
+ccl_device_inline float path_rng_1D(KernelGlobals *kg, RNG* rng, int sample, int num_samples, int dimension)
 {
 	/* implicit mod 2^32 */
-	rng = (1103515245*(rng) + 12345);
-	return (float)rng * (1.0f/(float)0xFFFFFFFF);
+	*rng = (1103515245*(*rng) + 12345);
+	return (float)*rng * (1.0f/(float)0xFFFFFFFF);
 }
 
-ccl_device_inline void path_rng_2D(KernelGlobals *kg, RNG& rng, int sample, int num_samples, int dimension, float *fx, float *fy)
+ccl_device_inline void path_rng_2D(KernelGlobals *kg, RNG* rng, int sample, int num_samples, int dimension, float *fx, float *fy)
 {
 	*fx = path_rng_1D(kg, rng, sample, num_samples, dimension);
 	*fy = path_rng_1D(kg, rng, sample, num_samples, dimension + 1);
@@ -222,10 +238,10 @@
 	}
 }
 
-ccl_device void path_rng_end(KernelGlobals *kg, ccl_global uint *rng_state, RNG rng)
+ccl_device void path_rng_end(KernelGlobals *kg, ccl_global uint *rng_state, RNG *rng)
 {
 	/* store state for next sample */
-	*rng_state = rng;
+	*rng_state = *rng;
 }
 
 #endif
diff -ru --new-file blender-2.76b.old/intern/cycles/kernel/kernels/cpu/kernel_avx2.cpp blender-2.76b/intern/cycles/kernel/kernels/cpu/kernel_avx2.cpp
--- blender-2.76b.old/intern/cycles/kernel/kernels/cpu/kernel_avx2.cpp	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/intern/cycles/kernel/kernels/cpu/kernel_avx2.cpp	2016-01-14 01:44:05.984785075 +0300
@@ -56,6 +56,21 @@
 		kernel_path_trace(kg, buffer, rng_state, sample, x, y, offset, stride);
 }
 
+void kernel_cpu_avx2_metropolis_step(KernelGlobals *kg, float *rbuffer, MetropolisChain *metro, double *sharedParams,
+	int x, int y, int w, int h, int offset, int stride)
+{
+	kernel_metropolis_step(kg, rbuffer, metro, sharedParams, x, y, w, h, offset, stride);
+}
+
+void kernel_cpu_avx2_metropolis_first_pass(KernelGlobals *kg, ccl_global float *buffer, double *sharedParams, ccl_global uint *rng_state, int x, int y, int offset, int stride)
+{
+	kernel_metropolis_first_pass(kg, buffer, sharedParams, rng_state, x, y, offset, stride);
+}
+
+void kernel_cpu_avx2_metropolis_warmup(KernelGlobals *kg, ccl_global uint *rng_state, double *sharedParams, int sample, int x, int y, int offset, int stride) {
+	kernel_metropolis_warmup(kg, rng_state, sharedParams, sample, x, y, offset, stride);
+}
+
 /* Film */
 
 void kernel_cpu_avx2_convert_to_byte(KernelGlobals *kg, uchar4 *rgba, float *buffer, float sample_scale, int x, int y, int offset, int stride)
diff -ru --new-file blender-2.76b.old/intern/cycles/kernel/kernels/cpu/kernel_avx.cpp blender-2.76b/intern/cycles/kernel/kernels/cpu/kernel_avx.cpp
--- blender-2.76b.old/intern/cycles/kernel/kernels/cpu/kernel_avx.cpp	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/intern/cycles/kernel/kernels/cpu/kernel_avx.cpp	2016-01-14 01:42:57.283777803 +0300
@@ -40,9 +40,12 @@
 #include "kernel_path.h"
 #include "kernel_path_branched.h"
 #include "kernel_bake.h"
+#include "kernel_metropolis.h"
 
 CCL_NAMESPACE_BEGIN
 
+extern float s, as;
+
 /* Path Tracing */
 
 void kernel_cpu_avx_path_trace(KernelGlobals *kg, float *buffer, unsigned int *rng_state, int sample, int x, int y, int offset, int stride)
@@ -55,6 +58,21 @@
 		kernel_path_trace(kg, buffer, rng_state, sample, x, y, offset, stride);
 }
 
+void kernel_cpu_avx_metropolis_step(KernelGlobals *kg, float *rbuffer, MetropolisChain *metro, double *sharedParams,
+	int x, int y, int w, int h, int offset, int stride)
+{
+	kernel_metropolis_step(kg, rbuffer, metro, sharedParams, x, y, w, h, offset, stride);
+}
+
+void kernel_cpu_avx_metropolis_first_pass(KernelGlobals *kg, ccl_global float *buffer, double *sharedParams, ccl_global uint *rng_state, int x, int y, int offset, int stride)
+{
+	kernel_metropolis_first_pass(kg, buffer, sharedParams, rng_state, x, y, offset, stride);
+}
+
+void kernel_cpu_avx_metropolis_warmup(KernelGlobals *kg, ccl_global uint *rng_state, double *sharedParams, int sample, int x, int y, int offset, int stride) {
+	kernel_metropolis_warmup(kg, rng_state, sharedParams, sample, x, y, offset, stride);
+}
+
 /* Film */
 
 void kernel_cpu_avx_convert_to_byte(KernelGlobals *kg, uchar4 *rgba, float *buffer, float sample_scale, int x, int y, int offset, int stride)
diff -ru --new-file blender-2.76b.old/intern/cycles/kernel/kernels/cpu/kernel.cpp blender-2.76b/intern/cycles/kernel/kernels/cpu/kernel.cpp
--- blender-2.76b.old/intern/cycles/kernel/kernels/cpu/kernel.cpp	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/intern/cycles/kernel/kernels/cpu/kernel.cpp	2016-01-14 01:33:57.687865558 +0300
@@ -116,6 +116,25 @@
 		kernel_path_trace(kg, buffer, rng_state, sample, x, y, offset, stride);
 }
 
+void kernel_metro_init_chain(KernelGlobals *kg, MetropolisChain *m) {
+	return metro_init_chain(kg, m);
+}
+
+void kernel_cpu_metropolis_first_pass(KernelGlobals *kg, ccl_global float *buffer, double *sharedParams, ccl_global uint *rng_state, int x, int y, int offset, int stride)
+{
+	kernel_metropolis_first_pass(kg, buffer, sharedParams, rng_state, x, y, offset, stride);
+}
+
+void kernel_cpu_metropolis_warmup(KernelGlobals *kg, ccl_global uint *rng_state, double *sharedParams, int sample, int x, int y, int offset, int stride) {
+	kernel_metropolis_warmup(kg, rng_state, sharedParams, sample, x, y, offset, stride);
+}
+
+void kernel_cpu_metropolis_step(KernelGlobals *kg, float *rbuffer, MetropolisChain *metro, double *sharedParams,
+	int x, int y, int w, int h, int offset, int stride)
+{
+	kernel_metropolis_step(kg, rbuffer, metro, sharedParams, x, y, w, h, offset, stride);
+}
+
 /* Film */
 
 void kernel_cpu_convert_to_byte(KernelGlobals *kg, uchar4 *rgba, float *buffer, float sample_scale, int x, int y, int offset, int stride)
diff -ru --new-file blender-2.76b.old/intern/cycles/kernel/kernels/cpu/kernel_sse2.cpp blender-2.76b/intern/cycles/kernel/kernels/cpu/kernel_sse2.cpp
--- blender-2.76b.old/intern/cycles/kernel/kernels/cpu/kernel_sse2.cpp	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/intern/cycles/kernel/kernels/cpu/kernel_sse2.cpp	2016-01-14 02:25:09.800058290 +0300
@@ -51,6 +51,21 @@
 		kernel_path_trace(kg, buffer, rng_state, sample, x, y, offset, stride);
 }
 
+void kernel_cpu_sse2_metropolis_step(KernelGlobals *kg, float *rbuffer, MetropolisChain *metro, double *sharedParams,
+	int x, int y, int w, int h, int offset, int stride)
+{
+	kernel_metropolis_step(kg, rbuffer, metro, sharedParams, x, y, w, h, offset, stride);
+}
+
+void kernel_cpu_sse2_metropolis_first_pass(KernelGlobals *kg, ccl_global float *buffer, double *sharedParams, ccl_global uint *rng_state, int x, int y, int offset, int stride)
+{
+	kernel_metropolis_first_pass(kg, buffer, sharedParams, rng_state, x, y, offset, stride);
+}
+
+void kernel_cpu_sse2_metropolis_warmup(KernelGlobals *kg, ccl_global uint *rng_state, double *sharedParams, int sample, int x, int y, int offset, int stride) {
+	kernel_metropolis_warmup(kg, rng_state, sharedParams, sample, x, y, offset, stride);
+}
+
 /* Film */
 
 void kernel_cpu_sse2_convert_to_byte(KernelGlobals *kg, uchar4 *rgba, float *buffer, float sample_scale, int x, int y, int offset, int stride)
diff -ru --new-file blender-2.76b.old/intern/cycles/kernel/kernels/cpu/kernel_sse3.cpp blender-2.76b/intern/cycles/kernel/kernels/cpu/kernel_sse3.cpp
--- blender-2.76b.old/intern/cycles/kernel/kernels/cpu/kernel_sse3.cpp	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/intern/cycles/kernel/kernels/cpu/kernel_sse3.cpp	2016-01-14 02:25:53.224698117 +0300
@@ -53,6 +53,21 @@
 		kernel_path_trace(kg, buffer, rng_state, sample, x, y, offset, stride);
 }
 
+void kernel_cpu_sse3_metropolis_step(KernelGlobals *kg, float *rbuffer, MetropolisChain *metro, double *sharedParams,
+	int x, int y, int w, int h, int offset, int stride)
+{
+	kernel_metropolis_step(kg, rbuffer, metro, sharedParams, x, y, w, h, offset, stride);
+}
+
+void kernel_cpu_sse3_metropolis_first_pass(KernelGlobals *kg, ccl_global float *buffer, double *sharedParams, ccl_global uint *rng_state, int x, int y, int offset, int stride)
+{
+	kernel_metropolis_first_pass(kg, buffer, sharedParams, rng_state, x, y, offset, stride);
+}
+
+void kernel_cpu_sse3_metropolis_warmup(KernelGlobals *kg, ccl_global uint *rng_state, double *sharedParams, int sample, int x, int y, int offset, int stride) {
+	kernel_metropolis_warmup(kg, rng_state, sharedParams, sample, x, y, offset, stride);
+}
+
 /* Film */
 
 void kernel_cpu_sse3_convert_to_byte(KernelGlobals *kg, uchar4 *rgba, float *buffer, float sample_scale, int x, int y, int offset, int stride)
diff -ru --new-file blender-2.76b.old/intern/cycles/kernel/kernels/cpu/kernel_sse41.cpp blender-2.76b/intern/cycles/kernel/kernels/cpu/kernel_sse41.cpp
--- blender-2.76b.old/intern/cycles/kernel/kernels/cpu/kernel_sse41.cpp	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/intern/cycles/kernel/kernels/cpu/kernel_sse41.cpp	2016-01-14 02:26:34.091300216 +0300
@@ -54,6 +54,21 @@
 		kernel_path_trace(kg, buffer, rng_state, sample, x, y, offset, stride);
 }
 
+void kernel_cpu_sse41_metropolis_step(KernelGlobals *kg, float *rbuffer, MetropolisChain *metro, double *sharedParams,
+	int x, int y, int w, int h, int offset, int stride)
+{
+	kernel_metropolis_step(kg, rbuffer, metro, sharedParams, x, y, w, h, offset, stride);
+}
+
+void kernel_cpu_sse41_metropolis_first_pass(KernelGlobals *kg, ccl_global float *buffer, double *sharedParams, ccl_global uint *rng_state, int x, int y, int offset, int stride)
+{
+	kernel_metropolis_first_pass(kg, buffer, sharedParams, rng_state, x, y, offset, stride);
+}
+
+void kernel_cpu_sse41_metropolis_warmup(KernelGlobals *kg, ccl_global uint *rng_state, double *sharedParams, int sample, int x, int y, int offset, int stride) {
+	kernel_metropolis_warmup(kg, rng_state, sharedParams, sample, x, y, offset, stride);
+}
+
 /* Film */
 
 void kernel_cpu_sse41_convert_to_byte(KernelGlobals *kg, uchar4 *rgba, float *buffer, float sample_scale, int x, int y, int offset, int stride)
diff -ru --new-file blender-2.76b.old/intern/cycles/kernel/kernels/cuda/kernel.cu blender-2.76b/intern/cycles/kernel/kernels/cuda/kernel.cu
--- blender-2.76b.old/intern/cycles/kernel/kernels/cuda/kernel.cu	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/intern/cycles/kernel/kernels/cuda/kernel.cu	2016-01-14 19:06:07.677421298 +0300
@@ -113,30 +113,99 @@
 
 extern "C" __global__ void
 CUDA_LAUNCH_BOUNDS(CUDA_THREADS_BLOCK_WIDTH, CUDA_KERNEL_MAX_REGISTERS)
-kernel_cuda_path_trace(float *buffer, uint *rng_state, int sample, int sx, int sy, int sw, int sh, int offset, int stride)
+kernel_cuda_path_trace(float *buffer, uint *rng_state, int *thread_to_pixel, int sample, int sx, int sy, int sw, int sh, int offset, int stride)
 {
-	int x = sx + blockDim.x*blockIdx.x + threadIdx.x;
-	int y = sy + blockDim.y*blockIdx.y + threadIdx.y;
+	if (thread_to_pixel) {
+		int i = (blockDim.y*blockIdx.y + threadIdx.y) * sw + blockDim.x*blockIdx.x + threadIdx.x;
+		if (i < sw * sh) {
+			int x = thread_to_pixel[2*i];
+			int y = thread_to_pixel[2*i + 1];
+			kernel_path_trace(NULL, buffer, rng_state, sample, x + sx, y + sy, offset, stride);
+		}
+	} else {
+		int x = blockDim.x*blockIdx.x + threadIdx.x;
+		int y = blockDim.y*blockIdx.y + threadIdx.y;
 
-	if(x < sx + sw && y < sy + sh)
-		kernel_path_trace(NULL, buffer, rng_state, sample, x, y, offset, stride);
+		if(x < sx + sw && y < sy + sh)
+			kernel_path_trace(NULL, buffer, rng_state, sample, x + sx, y + sy, offset, stride);
+	}
 }
 
 #ifdef __BRANCHED_PATH__
 extern "C" __global__ void
 CUDA_LAUNCH_BOUNDS(CUDA_THREADS_BLOCK_WIDTH, CUDA_KERNEL_BRANCHED_MAX_REGISTERS)
-kernel_cuda_branched_path_trace(float *buffer, uint *rng_state, int sample, int sx, int sy, int sw, int sh, int offset, int stride)
+kernel_cuda_branched_path_trace(float *buffer, uint *rng_state, int *thread_to_pixel, int sample, int sx, int sy, int sw, int sh, int offset, int stride)
 {
-	int x = sx + blockDim.x*blockIdx.x + threadIdx.x;
-	int y = sy + blockDim.y*blockIdx.y + threadIdx.y;
+	if (thread_to_pixel) {
+		int i = (blockDim.y*blockIdx.y + threadIdx.y) * sw + blockDim.x*blockIdx.x + threadIdx.x;
+		if (i < sw * sh) {
+			int x = thread_to_pixel[2*i];
+			int y = thread_to_pixel[2*i + 1];
+			kernel_branched_path_trace(NULL, buffer, rng_state, sample, x + sx, y + sy, offset, stride);
+		}
+	} else {
+		int x = blockDim.x*blockIdx.x + threadIdx.x;
+		int y = blockDim.y*blockIdx.y + threadIdx.y;
 
-	if(x < sx + sw && y < sy + sh)
-		kernel_branched_path_trace(NULL, buffer, rng_state, sample, x, y, offset, stride);
+		if(x < sw && y < sh)
+			kernel_branched_path_trace(NULL, buffer, rng_state, sample, x + sx, y + sy, offset, stride);
+	}
 }
 #endif
 
 extern "C" __global__ void
 CUDA_LAUNCH_BOUNDS(CUDA_THREADS_BLOCK_WIDTH, CUDA_KERNEL_MAX_REGISTERS)
+kernel_cuda_metropolis_first_pass(float *buffer, uint *rng_state, double *sharedParams, MetropolisChain *chains, int sx, int sy, int sw, int sh, int offset, int stride, int numChains)
+{
+	int x = blockDim.x*blockIdx.x + threadIdx.x;
+	int y = blockDim.y*blockIdx.y + threadIdx.y;
+
+    if (x == 0 && y == 0) {
+        sharedParams[0] = 0;
+        sharedParams[1] = 0;
+        sharedParams[2] = 0;
+        sharedParams[3] = 0;
+    }
+
+	//Init chains
+	if (y*sw + x < numChains) {
+		int chainSize = PRNG_BASE_NUM + (kernel_data.integrator.max_bounce + kernel_data.integrator.transparent_max_bounce + 3)*PRNG_BOUNCE_NUM + 2;
+		chainSize = sizeof(MetropolisChain) + chainSize*(2*sizeof(int) + 3*sizeof(float)); 
+		chainSize = ((chainSize + 15) / 16) * 16;
+		metro_init_chain(NULL, (MetropolisChain*) (((char*) chains) + (y*sw + x)*chainSize));
+	}
+
+	if(x < sw && y < sh)
+		kernel_metropolis_first_pass(NULL, buffer, sharedParams, rng_state, x + sx, y + sy, offset, stride);
+}
+
+extern "C" __global__ void
+CUDA_LAUNCH_BOUNDS(CUDA_THREADS_BLOCK_WIDTH, CUDA_KERNEL_MAX_REGISTERS)
+kernel_cuda_metropolis_warmup(uint *rng_state, double *sharedParams, int sample, int sw, int sh, int offset, int stride)
+{
+	int x = blockDim.x*blockIdx.x + threadIdx.x;
+	int y = blockDim.y*blockIdx.y + threadIdx.y;
+
+	if (x < sw && y < sh)
+        kernel_metropolis_warmup(NULL, rng_state, sharedParams, sample, x, y, offset, stride);
+}
+
+extern "C" __global__ void
+CUDA_LAUNCH_BOUNDS(CUDA_THREADS_BLOCK_WIDTH, CUDA_KERNEL_MAX_REGISTERS)
+kernel_cuda_metropolis_step(float *rbuffer, double *sharedParams, MetropolisChain *chains, int numChains,
+int sx, int sy, int sw, int sh, int offset, int stride)
+{
+	int i = blockDim.x*blockIdx.x + threadIdx.x;
+	if (i < numChains) {
+		int chainSize = PRNG_BASE_NUM + (kernel_data.integrator.max_bounce + kernel_data.integrator.transparent_max_bounce + 3)*PRNG_BOUNCE_NUM + 2;
+		chainSize = sizeof(MetropolisChain) + chainSize*(2*sizeof(int) + 3*sizeof(float));
+		chainSize = ((chainSize + 15) / 16) * 16;
+		kernel_metropolis_step(NULL, rbuffer, (MetropolisChain*) (((char*) chains) + i*chainSize), sharedParams, sx, sy, sw, sh, offset, stride);
+	}
+}
+
+extern "C" __global__ void
+CUDA_LAUNCH_BOUNDS(CUDA_THREADS_BLOCK_WIDTH, CUDA_KERNEL_MAX_REGISTERS)
 kernel_cuda_convert_to_byte(uchar4 *rgba, float *buffer, float sample_scale, int sx, int sy, int sw, int sh, int offset, int stride)
 {
 	int x = sx + blockDim.x*blockIdx.x + threadIdx.x;
diff -ru --new-file blender-2.76b.old/intern/cycles/kernel/kernel_textures.h blender-2.76b/intern/cycles/kernel/kernel_textures.h
--- blender-2.76b.old/intern/cycles/kernel/kernel_textures.h	2015-10-27 19:57:22.000000000 +0300
+++ blender-2.76b/intern/cycles/kernel/kernel_textures.h	2016-01-14 02:28:03.511617542 +0300
@@ -72,6 +72,9 @@
 /* sobol */
 KERNEL_TEX(uint, texture_uint, __sobol_directions)
 
+/* Metropolis MCQMC */
+KERNEL_TEX(float, texture_float, __metropolis_mcqmc)
+
 /* full-float image */
 KERNEL_IMAGE_TEX(float4, texture_image_float4, __tex_image_float_000)
 KERNEL_IMAGE_TEX(float4, texture_image_float4, __tex_image_float_001)
@@ -173,9 +176,10 @@
 KERNEL_IMAGE_TEX(uchar4, texture_image_uchar4, __tex_image_095)
 KERNEL_IMAGE_TEX(uchar4, texture_image_uchar4, __tex_image_096)
 KERNEL_IMAGE_TEX(uchar4, texture_image_uchar4, __tex_image_097)
-KERNEL_IMAGE_TEX(uchar4, texture_image_uchar4, __tex_image_098)
+
 
 /* Kepler and above */
+KERNEL_IMAGE_TEX(uchar4, texture_image_uchar4, __tex_image_098)
 KERNEL_IMAGE_TEX(uchar4, texture_image_uchar4, __tex_image_099)
 KERNEL_IMAGE_TEX(uchar4, texture_image_uchar4, __tex_image_100)
 KERNEL_IMAGE_TEX(uchar4, texture_image_uchar4, __tex_image_101)
diff -ru --new-file blender-2.76b.old/intern/cycles/kernel/kernel_types.h blender-2.76b/intern/cycles/kernel/kernel_types.h
--- blender-2.76b.old/intern/cycles/kernel/kernel_types.h	2015-11-04 13:02:14.000000000 +0300
+++ blender-2.76b/intern/cycles/kernel/kernel_types.h	2016-01-14 02:32:33.476593612 +0300
@@ -73,6 +73,7 @@
 #define __VOLUME_DECOUPLED__
 #define __VOLUME_SCATTER__
 #define __SHADOW_RECORD_ALL__
+#define __METROPOLIS__
 #define __VOLUME_RECORD_ALL__
 #endif
 
@@ -80,6 +81,7 @@
 #define __KERNEL_SHADING__
 #define __KERNEL_ADV_SHADING__
 #define __BRANCHED_PATH__
+#define __METROPOLIS__
 #define __VOLUME__
 #define __VOLUME_SCATTER__
 
@@ -344,6 +346,8 @@
 	PASS_SUBSURFACE_INDIRECT = (1 << 23),
 	PASS_SUBSURFACE_COLOR = (1 << 24),
 	PASS_LIGHT = (1 << 25), /* no real pass, used to force use_light_pass */
+	PASS_VARIANCE = 67108864,
+	PASS_SAMPLES = 134217728
 #ifdef __KERNEL_DEBUG__
 	PASS_BVH_TRAVERSAL_STEPS = (1 << 26),
 	PASS_BVH_TRAVERSED_INSTANCES = (1 << 27),
@@ -394,6 +398,40 @@
 	float mist;
 } PathRadiance;
 
+struct PassData {
+public:
+	float pass_depth;
+	float3 pass_normal;
+	float4 pass_motion;
+	float pass_motion_weight;
+
+	float3 pass_uv;
+	float pass_object_id;
+	float pass_material_id;
+
+	float3 pass_diffuse_color;
+	float3 pass_glossy_color;
+	float3 pass_transmission_color;
+	float3 pass_subsurface_color;
+	
+	float3 pass_diffuse_indirect;
+	float3 pass_glossy_indirect;
+	float3 pass_transmission_indirect;
+	float3 pass_subsurface_indirect;
+	
+	float3 pass_diffuse_direct;
+	float3 pass_glossy_direct;
+	float3 pass_transmission_direct;
+	float3 pass_subsurface_direct;
+	
+	float3 pass_emission;
+	float3 pass_background;
+	float3 pass_ao;
+
+	float4 pass_shadow;
+	float pass_mist;
+};
+
 typedef struct BsdfEval {
 	int use_light_pass;
 
@@ -854,13 +892,16 @@
 	int pass_shadow;
 	float pass_shadow_scale;
 	int filter_table_offset;
-	int pass_pad2;
+	int pass_variance;	
 
 	int pass_mist;
 	float mist_start;
 	float mist_inv_depth;
 	float mist_falloff;
-
+		
+	int pass_samples;
+	int pass_pad0;
+	int pass_pad1;
 #ifdef __KERNEL_DEBUG__
 	int pass_bvh_traversal_steps;
 	int pass_bvh_traversed_instances;
@@ -927,6 +968,12 @@
 	float sample_clamp_direct;
 	float sample_clamp_indirect;
 
+	/* metropolis path */
+	int metropolis;
+	int max_consecutive_rejects;
+	float image_mutation_range;
+	int map_interval;
+
 	/* branched path */
 	int branched;
 	int diffuse_samples;
@@ -999,6 +1046,29 @@
 	KernelTables tables;
 } KernelData;
 
+struct MetropolisChain {
+	uint sampleSize;
+	uint rng, rngPos;
+    float *rngRotation;
+
+	//Current sampler state
+	bool isLargeMutation, cooldown;
+	float weight;
+	uint consecRejects;
+    float largeStepProb;
+
+	//Current and proposed samples
+	uint currentStamp, proposedStamp;
+	float *currentSamples, *proposedSamples;
+	int *currentSampleStamps, *proposedSampleStamps;
+	float currentImportance;
+	PassData currentSampleResult;
+	float4 currentL;
+};
+
+#define METRO_RNG_N 1021
+#define METRO_RNG_A 65
+
 #ifdef __KERNEL_DEBUG__
 typedef ccl_addr_space struct DebugData {
 	// Total number of BVH node traversal steps and primitives intersections
diff -ru --new-file blender-2.76b.old/intern/cycles/kernel/kernel_volume.h blender-2.76b/intern/cycles/kernel/kernel_volume.h
--- blender-2.76b.old/intern/cycles/kernel/kernel_volume.h	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/intern/cycles/kernel/kernel_volume.h	2016-01-14 02:33:52.870762657 +0300
@@ -570,9 +570,9 @@
 	shader_setup_from_volume(kg, sd, ray, state->bounce, state->transparent_bounce);
 
 	if(heterogeneous)
-		return kernel_volume_integrate_heterogeneous_distance(kg, state, ray, sd, L, throughput, &tmp_rng);
+		return kernel_volume_integrate_heterogeneous_distance(kg, state, ray, sd, L, throughput, kernel_data.integrator.metropolis?rng:&tmp_rng);
 	else
-		return kernel_volume_integrate_homogeneous(kg, state, ray, sd, L, throughput, &tmp_rng, true);
+		return kernel_volume_integrate_homogeneous(kg, state, ray, sd, L, throughput, kernel_data.integrator.metropolis?rng:&tmp_rng, true);
 }
 
 /* Decoupled Volume Sampling
diff -ru --new-file blender-2.76b.old/intern/cycles/kernel/svm/svm_image.h blender-2.76b/intern/cycles/kernel/svm/svm_image.h
--- blender-2.76b.old/intern/cycles/kernel/svm/svm_image.h	2015-10-27 19:57:22.000000000 +0300
+++ blender-2.76b/intern/cycles/kernel/svm/svm_image.h	2016-01-14 17:09:23.747637191 +0300
@@ -250,9 +250,9 @@
 		case 94: r = kernel_tex_image_interp(__tex_image_094, x, y); break;
 		case 95: r = kernel_tex_image_interp(__tex_image_095, x, y); break;
 		case 96: r = kernel_tex_image_interp(__tex_image_096, x, y); break;
-		case 97: r = kernel_tex_image_interp(__tex_image_097, x, y); break;
 
 #if defined(__CUDA_ARCH__) && (__CUDA_ARCH__ >= 300)
+		case 97: r = kernel_tex_image_interp(__tex_image_097, x, y); break;
 		case 98: r = kernel_tex_image_interp(__tex_image_098, x, y); break;
 		case 99: r = kernel_tex_image_interp(__tex_image_099, x, y); break;
 		case 100: r = kernel_tex_image_interp(__tex_image_100, x, y); break;
diff -ru --new-file blender-2.76b.old/intern/cycles/render/buffers.cpp blender-2.76b/intern/cycles/render/buffers.cpp
--- blender-2.76b.old/intern/cycles/render/buffers.cpp	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/intern/cycles/render/buffers.cpp	2016-01-14 17:12:45.062681352 +0300
@@ -23,10 +23,12 @@
 #include "util_foreach.h"
 #include "util_hash.h"
 #include "util_image.h"
+#include "util_importance.h"
 #include "util_math.h"
 #include "util_opengl.h"
 #include "util_time.h"
 #include "util_types.h"
+#include "util_color.h"
 
 CCL_NAMESPACE_BEGIN
 
@@ -97,14 +99,25 @@
 
 /* Render Buffers */
 
-RenderBuffers::RenderBuffers(Device *device_)
+RenderBuffers::RenderBuffers(Device *device_, bool use_importance)
 {
 	device = device_;
+	metro_shared_params = NULL;
+	if (use_importance)
+		importance_map = new float[params.width*params.height];
+	else
+		importance_map = NULL;
 }
 
 RenderBuffers::~RenderBuffers()
 {
 	device_free();
+	if (importance_map) {
+		delete[] importance_map;
+		importance_map = NULL;
+	}
+	if (metro_shared_params)
+		delete[] metro_shared_params;
 }
 
 void RenderBuffers::device_free()
@@ -142,6 +155,15 @@
 		for(y = 0; y < height; y++)
 			init_state[x + y*width] = hash_int_2d(params.full_x+x, params.full_y+y);
 
+	/* allocate importance map */
+	if (importance_map) {
+		delete[] importance_map;
+		importance_map = new float[params.width*params.height];
+		for (x = 0; x < width; x++)
+			for (y = 0; y < height; y++)
+				importance_map[x + y*width] = 1.0f; // Default map for first pass
+	}
+
 	device->mem_alloc(rng_state, MEM_READ_WRITE);
 	device->mem_copy_to(rng_state);
 }
@@ -156,9 +178,23 @@
 	return true;
 }
 
+#define samples_pass_val (has_samples_pass?(*(in - pass_offset + sample_pass_offset)):sample)
+#define scale ((pass.filter) ? ((samples_pass_val > 0)?(1.0f/samples_pass_val):0.0f): 1.0f)
+#define scale_exposure (scale * ((pass.exposure)?exposure:1.0f))
+
 bool RenderBuffers::get_pass_rect(PassType type, float exposure, int sample, int components, float *pixels)
 {
-	int pass_offset = 0;
+	int pass_offset = 0, sample_pass_offset = 0;
+	bool has_samples_pass = false;
+
+	foreach(Pass& pass, params.passes) {
+		if (pass.type != PASS_SAMPLES)
+			sample_pass_offset += pass.components;
+		else {
+			has_samples_pass = true;
+			break;
+		}
+	}
 
 	foreach(Pass& pass, params.passes) {
 		if(pass.type != type) {
@@ -169,8 +205,6 @@
 		float *in = (float*)buffer.data_pointer + pass_offset;
 		int pass_stride = params.get_passes_size();
 
-		float scale = (pass.filter)? 1.0f/(float)sample: 1.0f;
-		float scale_exposure = (pass.exposure)? scale*exposure: scale;
 
 		int size = params.width*params.height;
 
@@ -180,16 +214,10 @@
 			/* scalar */
 			if(type == PASS_DEPTH) {
 				for(int i = 0; i < size; i++, in += pass_stride, pixels++) {
-					float f = *in;
+					float f = importance_map ? (float)sqrt(sqrt(importance_map[i])):*in;
 					pixels[0] = (f == 0.0f)? 1e10f: f*scale_exposure;
 				}
 			}
-			else if(type == PASS_MIST) {
-				for(int i = 0; i < size; i++, in += pass_stride, pixels++) {
-					float f = *in;
-					pixels[0] = saturate(f*scale_exposure);
-				}
-			}
 #ifdef WITH_CYCLES_DEBUG
 			else if(type == PASS_BVH_TRAVERSAL_STEPS) {
 				for(int i = 0; i < size; i++, in += pass_stride, pixels++) {
@@ -211,20 +239,62 @@
 				}
 			}
 		}
+		else if(components == 2) {
+			assert(pass.components == components);
+
+			for(int i = 0; i < size; i++, in += pass_stride, pixels++) {
+				float2 f = make_float2(in[0], in[1]);
+				pixels[0] = f.x*scale_exposure;
+				pixels[1] = f.y*scale_exposure;
+			}
+		}
 		else if(components == 3) {
 			assert(pass.components == 4);
 
 			/* RGBA */
 			if(type == PASS_SHADOW) {
 				for(int i = 0; i < size; i++, in += pass_stride, pixels += 3) {
-					float4 f = make_float4(in[0], in[1], in[2], in[3]);
+					/*float4 f = make_float4(in[0], in[1], in[2], in[3]);
 					float invw = (f.w > 0.0f)? 1.0f/f.w: 1.0f;
 
 					pixels[0] = f.x*invw;
 					pixels[1] = f.y*invw;
-					pixels[2] = f.z*invw;
+					pixels[2] = f.z*invw;*/
+					float3 f = make_float3(in[0], in[1], in[2]);
+
+					pixels[0] = f.x;
+					pixels[1] = f.y;
+					pixels[2] = f.z;
 				}
 			}
+            else if(pass.type == PASS_DIFFUSE_COLOR) {
+				/* RGB lighting passes that need to divide out color */
+				int pass_offset_v = 0;
+				int pass_offset_s = 0;
+				foreach(Pass& color_pass, params.passes) {
+					if(color_pass.type == PASS_VARIANCE)
+						break;
+					pass_offset_v += color_pass.components;
+				}
+				foreach(Pass& color_pass, params.passes) {
+					if(color_pass.type == PASS_SAMPLES)
+						break;
+					pass_offset_s += color_pass.components;
+				}
+
+				float *in_v = (float*)buffer.data_pointer + pass_offset_v;
+			float *in_s = (float*)buffer.data_pointer + pass_offset_s;
+				float *in_c = (float*)buffer.data_pointer;
+
+				for(int i = 0; i < size; i++, in += pass_stride, in_v += pass_stride, in_s += pass_stride, in_c += pass_stride, pixels += 3) {
+                    float3 variance = *((float3*)in_v) / (*in_s - 1);//(*((float3*)in_v) - ((*((float3*)in_c)) * (*((float3*)in_c))) / (*in_s)) / (*in_s-1);
+                    float greyVariance = max(linear_rgb_to_gray(variance), 0.0f);
+                    float f = sqrtf(greyVariance / *in_s) * linear_gray_to_inv_tvi(linear_rgb_to_gray(*((float3*)in_c) / *in_s));
+					pixels[0] = f;
+					pixels[1] = f;
+					pixels[2] = f;
+                }
+            }
 			else if(pass.divide_type != PASS_NONE) {
 				/* RGB lighting passes that need to divide out color */
 				pass_offset = 0;
@@ -315,6 +385,10 @@
 	return false;
 }
 
+#undef samples_pass_val
+#undef scale
+#undef scale_exposure
+
 /* Display Buffer */
 
 DisplayBuffer::DisplayBuffer(Device *device_, bool linear)
diff -ru --new-file blender-2.76b.old/intern/cycles/render/buffers.h blender-2.76b/intern/cycles/render/buffers.h
--- blender-2.76b.old/intern/cycles/render/buffers.h	2015-10-27 19:57:22.000000000 +0300
+++ blender-2.76b/intern/cycles/render/buffers.h	2016-01-14 02:43:05.855974588 +0300
@@ -68,12 +68,17 @@
 	/* buffer parameters */
 	BufferParams params;
 
+	double *metro_shared_params;
+
 	/* float buffer */
 	device_vector<float> buffer;
 	/* random number generator state */
 	device_vector<uint> rng_state;
 
-	RenderBuffers(Device *device);
+    float* importance_map;
+    void build_importance_map();
+
+	RenderBuffers(Device *device, bool use_importance);
 	~RenderBuffers();
 
 	void reset(Device *device, BufferParams& params);
@@ -142,6 +147,12 @@
 	device_ptr buffer;
 	device_ptr rng_state;
 
+    // Used to restore the tile for error-progressive rendering
+    int t_index;
+    int t_x, t_y;
+    int t_device;
+    float t_priority;
+
 	RenderBuffers *buffers;
 
 	RenderTile();
diff -ru --new-file blender-2.76b.old/intern/cycles/render/film.cpp blender-2.76b/intern/cycles/render/film.cpp
--- blender-2.76b.old/intern/cycles/render/film.cpp	2015-11-04 13:02:14.000000000 +0300
+++ blender-2.76b/intern/cycles/render/film.cpp	2016-01-14 02:46:12.176789863 +0300
@@ -133,7 +133,7 @@
 
 		case PASS_EMISSION:
 		case PASS_BACKGROUND:
-			pass.components = 4;
+			pass.components = 3;
 			pass.exposure = true;
 			break;
 		case PASS_AO:
@@ -152,6 +152,12 @@
 			 */
 			pass.components = 0;
 			break;
+		case PASS_VARIANCE:
+			pass.components = 3;
+			break;
+		case PASS_SAMPLES:
+			pass.components = 1;
+			break;
 #ifdef WITH_CYCLES_DEBUG
 		case PASS_BVH_TRAVERSAL_STEPS:
 			pass.components = 1;
@@ -404,10 +410,15 @@
 				kfilm->pass_shadow = kfilm->pass_stride;
 				kfilm->use_light_pass = 1;
 				break;
-
 			case PASS_LIGHT:
 				kfilm->use_light_pass = 1;
 				break;
+			case PASS_VARIANCE:
+				kfilm->pass_variance = kfilm->pass_stride;
+				break;
+			case PASS_SAMPLES:
+				kfilm->pass_samples = kfilm->pass_stride;
+				break;
 
 #ifdef WITH_CYCLES_DEBUG
 			case PASS_BVH_TRAVERSAL_STEPS:
@@ -432,9 +443,9 @@
 	kfilm->pass_alpha_threshold = pass_alpha_threshold;
 
 	/* update filter table */
-	vector<float> table = filter_table(filter_type, filter_width);
-	filter_table_offset = scene->lookup_tables->add_table(dscene, table);
-	kfilm->filter_table_offset = (int)filter_table_offset;
+    vector<float> table = filter_table(filter_type, filter_width);
+    filter_table_offset = scene->lookup_tables->add_table(dscene, table);
+    kfilm->filter_table_offset = (int)filter_table_offset;
 
 	/* mist pass parameters */
 	kfilm->mist_start = mist_start;
diff -ru --new-file blender-2.76b.old/intern/cycles/render/image.h blender-2.76b/intern/cycles/render/image.h
--- blender-2.76b.old/intern/cycles/render/image.h	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/intern/cycles/render/image.h	2016-01-14 02:47:51.620291414 +0300
@@ -29,11 +29,11 @@
 CCL_NAMESPACE_BEGIN
 
 /* generic */
-#define TEX_NUM_IMAGES			94
+#define TEX_NUM_IMAGES			93
 #define TEX_IMAGE_BYTE_START	TEX_NUM_FLOAT_IMAGES
 
 /* extended gpu */
-#define TEX_EXTENDED_NUM_IMAGES_GPU		145
+#define TEX_EXTENDED_NUM_IMAGES_GPU		144
 
 /* extended cpu */
 #define TEX_EXTENDED_NUM_FLOAT_IMAGES	1024
diff -ru --new-file blender-2.76b.old/intern/cycles/render/integrator.cpp blender-2.76b/intern/cycles/render/integrator.cpp
--- blender-2.76b.old/intern/cycles/render/integrator.cpp	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/intern/cycles/render/integrator.cpp	2016-01-14 02:49:41.605951345 +0300
@@ -22,6 +22,7 @@
 
 #include "util_foreach.h"
 #include "util_hash.h"
+#include "util_metropolis.h"
 
 CCL_NAMESPACE_BEGIN
 
@@ -59,6 +60,8 @@
 	mesh_light_samples = 1;
 	subsurface_samples = 1;
 	volume_samples = 1;
+	max_consecutive_rejects = 512;
+	image_mutation_range = 0.1f;
 
 	sample_all_lights_direct = true;
 	sample_all_lights_indirect = true;
@@ -129,6 +132,11 @@
 	kintegrator->sample_clamp_direct = (sample_clamp_direct == 0.0f)? FLT_MAX: sample_clamp_direct*3.0f;
 	kintegrator->sample_clamp_indirect = (sample_clamp_indirect == 0.0f)? FLT_MAX: sample_clamp_indirect*3.0f;
 
+	kintegrator->metropolis = (method == METROPOLIS_PATH);
+	kintegrator->max_consecutive_rejects = max_consecutive_rejects;
+	kintegrator->image_mutation_range = image_mutation_range;
+	kintegrator->map_interval = map_interval;
+
 	kintegrator->branched = (method == BRANCHED_PATH);
 	kintegrator->diffuse_samples = diffuse_samples;
 	kintegrator->glossy_samples = glossy_samples;
@@ -173,6 +181,10 @@
 
 	device->tex_alloc("__sobol_directions", dscene->sobol_directions);
 
+    float *metro_rng = dscene->metropolis_mcqmc.resize(METRO_RNG_N);
+    metro_build_rng_table(metro_rng);
+    device->tex_alloc("__metropolis_mcqmc", dscene->metropolis_mcqmc);
+
 	need_update = false;
 }
 
@@ -203,6 +215,9 @@
 		sample_clamp_direct == integrator.sample_clamp_direct &&
 		sample_clamp_indirect == integrator.sample_clamp_indirect &&
 		method == integrator.method &&
+		max_consecutive_rejects == integrator.max_consecutive_rejects &&
+		image_mutation_range == integrator.image_mutation_range &&
+		map_interval == integrator.map_interval &&
 		aa_samples == integrator.aa_samples &&
 		diffuse_samples == integrator.diffuse_samples &&
 		glossy_samples == integrator.glossy_samples &&
diff -ru --new-file blender-2.76b.old/intern/cycles/render/integrator.h blender-2.76b/intern/cycles/render/integrator.h
--- blender-2.76b.old/intern/cycles/render/integrator.h	2015-10-27 19:57:22.000000000 +0300
+++ blender-2.76b/intern/cycles/render/integrator.h	2016-01-14 02:50:31.073697656 +0300
@@ -53,6 +53,10 @@
 	float sample_clamp_indirect;
 	bool motion_blur;
 
+	int max_consecutive_rejects;
+	float image_mutation_range;
+	int map_interval;
+	
 	int aa_samples;
 	int diffuse_samples;
 	int glossy_samples;
@@ -66,7 +70,8 @@
 
 	enum Method {
 		BRANCHED_PATH = 0,
-		PATH = 1
+		PATH = 1,
+		METROPOLIS_PATH = 2
 	};
 	
 	Method method;
diff -ru --new-file blender-2.76b.old/intern/cycles/render/scene.h blender-2.76b/intern/cycles/render/scene.h
--- blender-2.76b.old/intern/cycles/render/scene.h	2015-10-27 19:57:22.000000000 +0300
+++ blender-2.76b/intern/cycles/render/scene.h	2016-01-14 02:51:00.120135797 +0300
@@ -108,6 +108,7 @@
 
 	/* integrator */
 	device_vector<uint> sobol_directions;
+	device_vector<float> metropolis_mcqmc;
 
 	/* cpu images */
 	device_vector<uchar4> tex_image[TEX_EXTENDED_NUM_IMAGES_CPU];
diff -ru --new-file blender-2.76b.old/intern/cycles/render/session.cpp blender-2.76b/intern/cycles/render/session.cpp
--- blender-2.76b.old/intern/cycles/render/session.cpp	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/intern/cycles/render/session.cpp	2016-01-14 20:24:00.518323318 +0300
@@ -30,11 +30,13 @@
 
 #include "util_foreach.h"
 #include "util_function.h"
+#include "util_importance.h"
 #include "util_logging.h"
 #include "util_math.h"
 #include "util_opengl.h"
 #include "util_task.h"
 #include "util_time.h"
+#include "util_system.h"
 
 CCL_NAMESPACE_BEGIN
 
@@ -46,7 +48,8 @@
 : params(params_),
   tile_manager(params.progressive, params.samples, params.tile_size, params.start_resolution,
        params.background == false || params.progressive_refine, params.background, params.tile_order,
-       max(params.device.multi_devices.size(), 1)),
+	   params.stopping_threshold, params.map_interval, max(params.device.multi_devices.size(), 1),
+	   params.num_progressive_samples, params.error_progressive),
   stats()
 {
 	device_use_gl = ((params.device.type != DEVICE_CPU) && !params.background);
@@ -60,7 +63,7 @@
 		display = NULL;
 	}
 	else {
-		buffers = new RenderBuffers(device);
+		buffers = new RenderBuffers(device, params.importance_equalisation | params.adaptive);
 		display = new DisplayBuffer(device, params.display_buffer_linear);
 	}
 
@@ -271,7 +274,7 @@
 			thread_scoped_lock buffers_lock(buffers_mutex);
 
 			/* update status and timing */
-			update_status_time();
+			update_status_time(false);
 
 			/* path trace */
 			path_trace();
@@ -282,7 +285,7 @@
 				progress.set_cancel(device->error_message());
 
 			/* update status and timing */
-			update_status_time();
+			update_status_time(false);
 
 			gpu_need_tonemap = true;
 			gpu_draw_ready = true;
@@ -354,7 +357,7 @@
 bool Session::acquire_tile(Device *tile_device, RenderTile& rtile)
 {
 	if(progress.get_cancel()) {
-		if(params.progressive_refine == false) {
+		if(params.progressive_refine == false || params.error_progressive) {
 			/* for progressive refine current sample should be finished for all tiles */
 			return false;
 		}
@@ -371,10 +374,15 @@
 	
 	/* fill render tile */
 	rtile.x = tile_manager.state.buffer.full_x + tile.x;
+	rtile.t_x = tile.x;
 	rtile.y = tile_manager.state.buffer.full_y + tile.y;
+	rtile.t_y = tile.y;
 	rtile.w = tile.w;
 	rtile.h = tile.h;
-	rtile.start_sample = tile_manager.state.sample;
+	rtile.t_device = tile.device;
+	rtile.t_index = tile.index;
+	rtile.t_priority = 1e10f;
+	rtile.start_sample = params.error_progressive?tile.sample:tile_manager.state.sample;
 	rtile.num_samples = tile_manager.state.num_samples;
 	rtile.resolution = tile_manager.state.resolution_divider;
 
@@ -419,7 +427,7 @@
 
 		tilebuffers = tile_buffers[tile.index];
 		if(tilebuffers == NULL) {
-			tilebuffers = new RenderBuffers(tile_device);
+			tilebuffers = new RenderBuffers(tile_device, params.importance_equalisation | params.adaptive);
 			tile_buffers[tile.index] = tilebuffers;
 
 			tilebuffers->reset(tile_device, buffer_params);
@@ -428,7 +436,7 @@
 		tile_lock.unlock();
 	}
 	else {
-		tilebuffers = new RenderBuffers(tile_device);
+		tilebuffers = new RenderBuffers(tile_device, params.importance_equalisation | params.adaptive);
 
 		tilebuffers->reset(tile_device, buffer_params);
 	}
@@ -451,19 +459,24 @@
 	thread_scoped_lock tile_lock(tile_mutex);
 
 	if(update_render_tile_cb) {
-		if(params.progressive_refine == false) {
+		if(params.progressive_refine == false || params.error_progressive) {
 			/* todo: optimize this by making it thread safe and removing lock */
 
 			update_render_tile_cb(rtile);
 		}
 	}
 
-	update_status_time();
+	update_status_time(true);
 }
 
 void Session::release_tile(RenderTile& rtile)
 {
 	thread_scoped_lock tile_lock(tile_mutex);
+	if (params.error_progressive) {
+		rtile.t_priority = tile_error(rtile, params.adaptive_error_power);
+		if(update_render_tile_cb)
+			update_render_tile_cb(rtile);
+	}
 
 	if(write_render_tile_cb) {
 		if(params.progressive_refine == false) {
@@ -474,7 +487,8 @@
 		}
 	}
 
-	update_status_time();
+	update_status_time(true);
+	tile_manager.finished_tile(Tile(rtile.t_index, rtile.t_x, rtile.t_y, rtile.w, rtile.h, rtile.t_device, rtile.t_priority, rtile.start_sample + rtile.num_samples));
 }
 
 void Session::run_cpu()
@@ -492,6 +506,8 @@
 		reset_(delayed_reset.params, delayed_reset.samples);
 		delayed_reset.do_reset = false;
 	}
+	
+	bool first_pass = true;
 
 	while(!progress.get_cancel()) {
 		/* advance to next tile */
@@ -558,14 +574,23 @@
 			if(progress.get_cancel())
 				break;
 
+			if (params.importance_equalisation && params.metropolis && !first_pass && !tile_manager.done()) {
+				buffers->build_importance_map();
+			}
+
+			first_pass = false;
+
 			/* update status and timing */
-			update_status_time();
+			update_status_time(false);
 
 			/* path trace */
-			path_trace();
+			if (params.metropolis)
+				metropolis_trace();
+			else
+				path_trace();
 
 			/* update status and timing */
-			update_status_time();
+			update_status_time(false);
 
 			if(!params.background)
 				need_tonemap = true;
@@ -820,7 +845,7 @@
 	}
 }
 
-void Session::update_status_time(bool show_pause, bool show_done)
+void Session::update_status_time(bool tile_locked, bool show_pause, bool show_done)
 {
 	int sample = tile_manager.state.sample;
 	int resolution = tile_manager.state.resolution_divider;
@@ -870,6 +895,19 @@
 			substatus += string_printf(", Sample %d/%d", status_sample, num_samples);
 		}
 	}
+	else if(params.error_progressive) {
+		float worstErr;
+		if (tile_locked)
+			worstErr = tile_manager.state.tiles.top().priority;
+		else {
+			thread_scoped_lock tile_lock(tile_mutex);
+			worstErr = tile_manager.state.tiles.top().priority;
+		}
+		if (worstErr == 1e10f)
+			substatus = string_printf("Path Tracing First Pass");
+		else
+			substatus = string_printf("Path Tracing Max Error %f", worstErr);
+    }
 	else if(tile_manager.num_samples == USHRT_MAX)
 		substatus = string_printf("Path Tracing Sample %d", sample+1);
 	else
@@ -905,6 +943,37 @@
 	progress.increment_sample();
 }
 
+void Session::metropolis_trace()
+{
+	/* add path trace task */
+	DeviceTask task(DeviceTask::METROPOLIS_TRACE);
+
+	task.acquire_tile = function_bind(&Session::acquire_tile, this, _1, _2);
+	task.release_tile = function_bind(&Session::release_tile, this, _1);
+	task.get_cancel = function_bind(&Progress::get_cancel, &this->progress);
+	task.update_tile_sample = function_bind(&Session::update_tile_sample, this, _1);
+	task.update_progress_sample = function_bind(&Session::update_progress_sample, this);
+	task.need_finish_queue = params.progressive_refine && !params.error_progressive;
+	task.integrator_branched = scene->integrator->method == Integrator::BRANCHED_PATH;
+	task.integrator_metropolis = params.metropolis;
+	task.adaptive = params.adaptive;
+	task.stopping_threshold = params.stopping_threshold;
+	task.adaptive_error_power = params.adaptive_error_power;
+	task.map_interval = params.map_interval;
+	task.importance_equalisation = params.importance_equalisation;
+	task.error_progressive = params.error_progressive;
+	task.warmup_samples = params.warmup_samples;
+    if (params.num_metro_chains == 0) {
+		if (device->info.type == DEVICE_CUDA)
+			task.num_metro_chains = 8192;
+		else
+			task.num_metro_chains = 1;
+	} else task.num_metro_chains = params.num_metro_chains;
+	task.metro_sample_size = PRNG_BASE_NUM + (scene->dscene.data.integrator.max_bounce + scene->dscene.data.integrator.transparent_max_bounce + 3)*PRNG_BOUNCE_NUM;
+
+	device->task_add(task);
+}
+
 void Session::path_trace()
 {
 	/* add path trace task */
@@ -915,9 +984,15 @@
 	task.get_cancel = function_bind(&Progress::get_cancel, &this->progress);
 	task.update_tile_sample = function_bind(&Session::update_tile_sample, this, _1);
 	task.update_progress_sample = function_bind(&Session::update_progress_sample, this);
-	task.need_finish_queue = params.progressive_refine;
+	task.need_finish_queue = params.progressive_refine && !params.error_progressive;
 	task.integrator_branched = scene->integrator->method == Integrator::BRANCHED_PATH;
 	task.requested_tile_size = params.tile_size;
+	task.integrator_metropolis = false;
+	task.adaptive = params.adaptive;
+	task.stopping_threshold = params.stopping_threshold;
+	task.adaptive_error_power = params.adaptive_error_power;
+	task.map_interval = params.map_interval;
+	task.error_progressive = params.error_progressive;
 
 	device->task_add(task);
 }
@@ -961,7 +1036,7 @@
 			return false;
 	}
 
-	if(params.progressive_refine) {
+	if(params.progressive_refine && !params.error_progressive) {
 		foreach(RenderBuffers *buffers, tile_buffers) {
 			RenderTile rtile;
 			rtile.buffers = buffers;
diff -ru --new-file blender-2.76b.old/intern/cycles/render/session.h blender-2.76b/intern/cycles/render/session.h
--- blender-2.76b.old/intern/cycles/render/session.h	2015-10-27 19:57:22.000000000 +0300
+++ blender-2.76b/intern/cycles/render/session.h	2016-01-14 11:48:15.443351352 +0300
@@ -45,7 +45,18 @@
 	DeviceInfo device;
 	bool background;
 	bool progressive_refine;
+	int num_progressive_samples;
 	string output_path;
+	
+	bool adaptive;
+	int map_interval;
+	float stopping_threshold;
+	float adaptive_error_power;
+	bool metropolis;
+	bool importance_equalisation;
+	bool error_progressive;
+	int num_metro_chains;
+	int warmup_samples;
 
 	bool progressive;
 	bool experimental;
@@ -95,6 +106,11 @@
 		&& progressive_refine == params.progressive_refine
 		&& output_path == params.output_path
 		/* && samples == params.samples */
+		&& adaptive == params.adaptive
+		&& map_interval == params.map_interval
+		&& stopping_threshold == params.stopping_threshold
+		&& metropolis == params.metropolis
+		&& importance_equalisation == params.importance_equalisation
 		&& progressive == params.progressive
 		&& experimental == params.experimental
 		&& tile_size == params.tile_size
@@ -156,10 +172,11 @@
 
 	void run();
 
-	void update_status_time(bool show_pause = false, bool show_done = false);
+	void update_status_time(bool tile_locked, bool show_pause = false, bool show_done = false);
 
 	void tonemap(int sample);
 	void path_trace();
+	void metropolis_trace();
 	void reset_(BufferParams& params, int samples);
 
 	void run_cpu();
diff -ru --new-file blender-2.76b.old/intern/cycles/render/tile.cpp blender-2.76b/intern/cycles/render/tile.cpp
--- blender-2.76b.old/intern/cycles/render/tile.cpp	2015-11-04 13:02:14.000000000 +0300
+++ blender-2.76b/intern/cycles/render/tile.cpp	2016-01-14 12:02:13.776747875 +0300
@@ -22,9 +22,14 @@
 CCL_NAMESPACE_BEGIN
 
 TileManager::TileManager(bool progressive_, int num_samples_, int2 tile_size_, int start_resolution_,
-                         bool preserve_tile_device_, bool background_, TileOrder tile_order_, int num_devices_)
+                         bool preserve_tile_device_, bool background_, TileOrder tile_order_,
+                         float error_tolerance_, int map_interval_, int num_devices_,
+                                                 int num_progressive_samples_, bool error_progressive_)
 {
 	progressive = progressive_;
+	error_progressive = error_progressive_;
+	num_progressive_samples = num_progressive_samples_;
+	current_progressive_samples = 1;
 	tile_size = tile_size_;
 	tile_order = tile_order_;
 	start_resolution = start_resolution_;
@@ -32,6 +37,8 @@
 	num_devices = num_devices_;
 	preserve_tile_device = preserve_tile_device_;
 	background = background_;
+	error_tolerance = error_tolerance_;
+	map_interval = map_interval_;
 
 	BufferParams buffer_params;
 	reset(buffer_params, 0);
@@ -58,7 +65,8 @@
 	}
 
 	num_samples = num_samples_;
-
+	
+	current_progressive_samples = 1;
 	state.buffer = BufferParams();
 	state.sample = -1;
 	state.num_tiles = 0;
@@ -165,9 +173,9 @@
 	state.buffer.full_height = max(1, params.full_height/resolution);
 }
 
-list<Tile>::iterator TileManager::next_viewport_tile(int device)
+PriorityQueue<Tile>::iterator TileManager::next_viewport_tile(int device)
 {
-	list<Tile>::iterator iter;
+	PriorityQueue<Tile>::iterator iter;
 
 	int logical_device = preserve_tile_device? device: 0;
 
@@ -179,9 +187,9 @@
 	return state.tiles.end();
 }
 
-list<Tile>::iterator TileManager::next_background_tile(int device, TileOrder tile_order)
+PriorityQueue<Tile>::iterator TileManager::next_background_tile(int device, TileOrder tile_order)
 {
-	list<Tile>::iterator iter, best = state.tiles.end();
+	PriorityQueue<Tile>::iterator iter, best = state.tiles.end();
 
 	int resolution = state.resolution_divider;
 	int logical_device = preserve_tile_device? device: 0;
@@ -233,7 +241,28 @@
 
 bool TileManager::next_tile(Tile& tile, int device)
 {
-	list<Tile>::iterator tile_it;
+	int logical_device = preserve_tile_device? device: 0;
+	if (error_progressive) {
+		list<Tile> wrongDevice;
+		while (!state.tiles.empty()) {
+			Tile t = state.tiles.top();
+			state.tiles.pop();
+			if (t.device != logical_device)
+				wrongDevice.push_back(t);
+			else {
+				for(list<Tile>::iterator iter = wrongDevice.begin(); iter != wrongDevice.end(); iter++)
+					state.tiles.push(*iter);
+				if (t.priority <= error_tolerance) //Done since worst error (for this device) is below threshold
+					return false;
+				tile = t;
+			return true;
+			}
+		}
+		for(list<Tile>::iterator iter = wrongDevice.begin(); iter != wrongDevice.end(); iter++)
+			state.tiles.push(*iter);
+		return false;
+	}
+	PriorityQueue<Tile>::iterator tile_it;	
 	
 	if(background)
 		tile_it = next_background_tile(device, tile_order);
@@ -251,9 +280,17 @@
 	return false;
 }
 
+void TileManager::finished_tile(Tile tile) {
+	if (error_progressive)
+		state.tiles.push(tile);
+}
+
 bool TileManager::done()
 {
-	return (state.sample+state.num_samples >= num_samples && state.resolution_divider == 1);
+	if (error_progressive)
+		return (state.tiles.empty())?false:state.tiles.top().priority <= error_tolerance;
+	else
+		return (state.sample+state.num_samples >= num_samples && state.resolution_divider == 1);
 }
 
 bool TileManager::next()
@@ -261,17 +298,28 @@
 	if(done())
 		return false;
 
-	if(progressive && state.resolution_divider > 1) {
+	if (error_progressive) {
+		state.sample = 0;
+		state.num_samples = map_interval;
+		state.resolution_divider = 1;
+		set_tiles();
+	}
+	else if(progressive && state.resolution_divider > 1) {
 		state.sample = 0;
 		state.resolution_divider /= 2;
 		state.num_samples = 1;
 		set_tiles();
 	}
 	else {
-		state.sample++;
+		if(progressive)
+			state.sample += current_progressive_samples;
+		else
+			state.sample++;
+
+		current_progressive_samples = min(min(current_progressive_samples * 2, num_progressive_samples), num_samples - state.sample);
 
 		if(progressive)
-			state.num_samples = 1;
+			state.num_samples = current_progressive_samples;
 		else
 			state.num_samples = num_samples;
 
diff -ru --new-file blender-2.76b.old/intern/cycles/render/tile.h blender-2.76b/intern/cycles/render/tile.h
--- blender-2.76b.old/intern/cycles/render/tile.h	2015-10-27 19:57:22.000000000 +0300
+++ blender-2.76b/intern/cycles/render/tile.h	2016-01-14 12:06:49.756820392 +0300
@@ -18,6 +18,7 @@
 #define __TILE_H__
 
 #include <limits.h>
+#include <queue>
 
 #include "buffers.h"
 #include "util_list.h"
@@ -32,12 +33,19 @@
 	int x, y, w, h;
 	int device;
 	bool rendering;
+	float priority;
+	int sample;
 
 	Tile()
 	{}
 
-	Tile(int index_, int x_, int y_, int w_, int h_, int device_)
-	: index(index_), x(x_), y(y_), w(w_), h(h_), device(device_), rendering(false) {}
+	Tile(int index_, int x_, int y_, int w_, int h_, int device_, float priority_ = 1e10f, int sample_ = 0)
+	: index(index_), x(x_), y(y_), w(w_), h(h_), device(device_), rendering(false), priority(priority_), sample(sample_) {}
+	bool operator<(const Tile &b) const {
+		if (priority < b.priority) return true;
+		if (priority == b.priority) return index > b.index;
+		return false;
+	}
 };
 
 /* Tile order */
@@ -64,19 +72,22 @@
 		int resolution_divider;
 		int num_tiles;
 		int num_rendered_tiles;
-		list<Tile> tiles;
+		PriorityQueue<Tile> tiles;
 	} state;
 
 	int num_samples;
 
 	TileManager(bool progressive, int num_samples, int2 tile_size, int start_resolution,
-	            bool preserve_tile_device, bool background, TileOrder tile_order, int num_devices = 1);
+			bool preserve_tile_device, bool background, TileOrder tile_order, float error_tolerance,
+			int map_interval, int num_devices = 1,
+			int num_progressive_samples = 1, bool error_progressive = false);
 	~TileManager();
 
 	void reset(BufferParams& params, int num_samples);
 	void set_samples(int num_samples);
 	bool next();
 	bool next_tile(Tile& tile, int device = 0);
+	void finished_tile(Tile tile);
 	bool done();
 	
 	void set_tile_order(TileOrder tile_order_) { tile_order = tile_order_; }
@@ -85,10 +96,16 @@
 	void set_tiles();
 
 	bool progressive;
+	bool error_progressive;
+	bool error_first_pass_done;
+	int current_progressive_samples;
+	int num_progressive_samples;
 	int2 tile_size;
 	TileOrder tile_order;
 	int start_resolution;
 	int num_devices;
+	float error_tolerance;
+	int map_interval;
 
 	/* in some cases it is important that the same tile will be returned for the same
 	 * device it was originally generated for (i.e. viewport rendering when buffer is
@@ -116,10 +133,10 @@
 	void gen_tiles_sliced();
 
 	/* returns tiles for background render */
-	list<Tile>::iterator next_background_tile(int device, TileOrder tile_order);
+	PriorityQueue<Tile>::iterator next_background_tile(int device, TileOrder tile_order);
 
 	/* returns first unhandled tile for viewport render */
-	list<Tile>::iterator next_viewport_tile(int device);
+	PriorityQueue<Tile>::iterator next_viewport_tile(int device);
 };
 
 CCL_NAMESPACE_END
diff -ru --new-file blender-2.76b.old/intern/cycles/util/CMakeLists.txt blender-2.76b/intern/cycles/util/CMakeLists.txt
--- blender-2.76b.old/intern/cycles/util/CMakeLists.txt	2015-11-04 13:02:14.000000000 +0300
+++ blender-2.76b/intern/cycles/util/CMakeLists.txt	2016-01-14 12:09:22.727074078 +0300
@@ -1,11 +1,15 @@
 
 set(INC
 	.
+	../kernel
+	../render
+	../device
 	../../glew-mx
 )
 
 set(INC_SYS
 	${GLEW_INCLUDE_DIR}
+	util_importance.cpp
 )
 
 set(SRC
@@ -45,12 +49,14 @@
 	util_half.h
 	util_hash.h
 	util_image.h
+	util_importance.h
 	util_list.h
 	util_logging.h
 	util_map.h
 	util_math.h
 	util_math_fast.h
 	util_md5.h
+	util_metropolis.h
 	util_opengl.h
 	util_optimization.h
 	util_param.h
diff -ru --new-file blender-2.76b.old/intern/cycles/util/util_color.h blender-2.76b/intern/cycles/util/util_color.h
--- blender-2.76b.old/intern/cycles/util/util_color.h	2015-10-27 19:57:22.000000000 +0300
+++ blender-2.76b/intern/cycles/util/util_color.h	2016-01-14 13:10:25.716844490 +0300
@@ -239,6 +239,31 @@
 	return c.x*0.2126f + c.y*0.7152f + c.z*0.0722f;
 }
 
+ccl_device float linear_rgb_to_gray(float4 c)
+{
+	return c.x*0.2126f + c.y*0.7152f + c.z*0.0722f;
+}
+
+ccl_device float linear_gray_to_inv_tvi(float v) {
+    float log_ten = (float)log(10.0f);
+	if (v < 0.0001f) //Safety check for v=0
+    	return (float)exp(2.86f * log_ten);
+    
+	float log_v = (float)log10(v);
+	float log_i;
+	if (log_v < -3.94f)
+		log_i = -2.86f;
+	else if (log_v < -1.44f)
+		log_i = (float)pow(0.405f*log_v + 1.6f, 2.18f) - 2.86f;
+	else if (log_v < -0.0184f)
+		log_i = log_v - 0.395f;
+	else if (log_v < 1.9f)
+		log_i = (float)pow(0.249f*log_v + 0.65f, 2.7f) - 0.72f;
+	else
+		log_i = log_v - 1.255f;
+	return (float)exp(-log_i * log_ten);
+}
+
 CCL_NAMESPACE_END
 
 #endif /* __UTIL_COLOR_H__ */
diff -ru --new-file blender-2.76b.old/intern/cycles/util/util_hash.h blender-2.76b/intern/cycles/util/util_hash.h
--- blender-2.76b.old/intern/cycles/util/util_hash.h	2015-10-27 19:57:22.000000000 +0300
+++ blender-2.76b/intern/cycles/util/util_hash.h	2016-01-14 15:11:26.341769052 +0300
@@ -19,9 +19,9 @@
 
 #include "util_types.h"
 
-CCL_NAMESPACE_BEGIN
+CCL_NAMESPACE_BEGIN 
 
-static inline uint hash_int_2d(uint kx, uint ky)
+ccl_device uint hash_int_2d(uint kx, uint ky)
 {
 #define rot(x,k) (((x)<<(k)) | ((x)>>(32-(k))))
 
@@ -44,7 +44,7 @@
 #undef rot
 }
 
-static inline uint hash_int(uint k)
+ccl_device uint hash_int(uint k)
 {
 	return hash_int_2d(k, 0);
 }
@@ -62,4 +62,3 @@
 CCL_NAMESPACE_END
 
 #endif /* __UTIL_HASH_H__ */
-
diff -ru --new-file blender-2.76b.old/intern/cycles/util/util_importance.cpp blender-2.76b/intern/cycles/util/util_importance.cpp
--- blender-2.76b.old/intern/cycles/util/util_importance.cpp	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/intern/cycles/util/util_importance.cpp	2016-01-14 12:12:44.377046514 +0300
@@ -0,0 +1,301 @@
+/*
+ * Copyright 2011-2013 Blender Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+
+#include <algorithm>
+#include "kernel_types.h"
+#include "util_importance.h"
+#include "util_hash.h"
+#include "util_color.h"
+#include "util_foreach.h"
+#include "buffers.h"
+#include "tile.h"
+
+#include <cstdio>
+using namespace std;
+
+CCL_NAMESPACE_BEGIN
+
+#define DATA_ADDR(x, y) ((offset + x + x_ofs + (y + y_ofs)*stride)*pass_stride)
+#define PASS_ADDR(x, y, pass) ((y * width + x) * pixel_stride + pass)
+
+//Precomputed gaussian blur with 7-pixel radius
+static const float BlurringKernel[] = {0.30406f, 0.22855f, 0.09681f, 0.02314f};
+
+void build_importance(RenderTile &rtile)
+{
+   if (!rtile.buffers->copy_from_device()) return;
+   
+   int width = rtile.w, height = rtile.h;
+   float *temp_importance = new float[width * height];
+   int pass_stride = rtile.buffers->params.get_passes_size();
+   float *passes = (float*)rtile.buffers->buffer.data_pointer + (rtile.offset + rtile.x + rtile.y * rtile.stride) * pass_stride;
+   float *importance = rtile.buffers->importance_map + rtile.offset + rtile.x + rtile.y * rtile.stride;
+
+   int samples_pass = 0, variance_pass = 0;
+   bool found_samples_pass = false, found_variance_pass = false;
+   foreach(Pass& pass, rtile.buffers->params.passes) {
+       if (pass.type != PASS_SAMPLES)
+           samples_pass += pass.components;
+       else {
+           found_samples_pass = true;
+           break;
+       }
+   }
+   assert(found_samples_pass);
+   foreach(Pass& pass, rtile.buffers->params.passes) {
+       if (pass.type != PASS_VARIANCE)
+           variance_pass += pass.components;
+       else {
+           found_variance_pass = true;
+           break;
+       }
+   }
+   assert(found_variance_pass);
+   for (int y = 0; y < height; y++) {
+       for (int x = 0; x < width; x++, passes += pass_stride, importance++) {
+           float3 *combinedPass, *variancePass;
+           float *samplesPass;
+           combinedPass = (float3*) passes;
+           variancePass = (float3*) (passes + variance_pass);
+           samplesPass = passes + samples_pass;
+
+           float factor = 1.0f / *samplesPass;
+           float intensityFactor = linear_gray_to_inv_tvi(linear_rgb_to_gray(*combinedPass * factor));
+            
+            float3 variance = (*variancePass) / (*samplesPass - 1);//(*variancePass - ((*combinedPass) * (*combinedPass)) / *samplesPass) * factor;
+
+           /*
+             * sqrt(variance) gives standard deviation, so sqrt(variance) * intensityFactor gives perceptually-weighted standard deviation (PWSD)
+             * However, since MC converges with O(1/sqrt(N)), the PWSD must be squared again
+             * (to decrease the error by a factor of 2, the sample smust be increased by a factor of 4)
+             * So (sqrt(variance) * IF)^2 is the correct sampling importance, which simplifies to variance*IV^2
+             * */
+            *importance = linear_rgb_to_gray(variance) * intensityFactor * intensityFactor;
+       }
+       importance += rtile.stride - width;
+       passes += (rtile.stride - width) * pass_stride;
+   }
+   importance = rtile.buffers->importance_map;
+   for (int y = 0; y < height; y++) {
+       for (int x = 0; x < width; x++) {
+           temp_importance[y*width + x]  = BlurringKernel[3]*importance[rtile.offset + rtile.x + (y+rtile.y)*rtile.stride +           ((x > 2) ? (x - 3) : x)];
+           temp_importance[y*width + x]  = BlurringKernel[2]*importance[rtile.offset + rtile.x + (y+rtile.y)*rtile.stride +           ((x > 1) ? (x - 2) : x)];
+           temp_importance[y*width + x] += BlurringKernel[1]*importance[rtile.offset + rtile.x + (y+rtile.y)*rtile.stride +           ((x > 0) ? (x - 1) : x)];
+           temp_importance[y*width + x] += BlurringKernel[0]*importance[rtile.offset + rtile.x + (y+rtile.y)*rtile.stride +                                x ];
+           temp_importance[y*width + x] += BlurringKernel[1]*importance[rtile.offset + rtile.x + (y+rtile.y)*rtile.stride + (((width - x) > 1) ? (x + 1) : x)];
+           temp_importance[y*width + x] += BlurringKernel[2]*importance[rtile.offset + rtile.x + (y+rtile.y)*rtile.stride + (((width - x) > 2) ? (x + 2) : x)];
+           temp_importance[y*width + x] += BlurringKernel[3]*importance[rtile.offset + rtile.x + (y+rtile.y)*rtile.stride + (((width - x) > 3) ? (x + 3) : x)];
+       }
+   }
+   for (int y = 0; y < height; y++) {
+       for (int x = 0; x < width; x++) {
+           importance[rtile.offset + rtile.x + (y+rtile.y)*rtile.stride + x]  = BlurringKernel[3]*temp_importance[           ((y > 2) ? (y - 3) : y)*width + x];
+           importance[rtile.offset + rtile.x + (y+rtile.y)*rtile.stride + x]  = BlurringKernel[2]*temp_importance[           ((y > 1) ? (y - 2) : y)*width + x];
+           importance[rtile.offset + rtile.x + (y+rtile.y)*rtile.stride + x] += BlurringKernel[1]*temp_importance[           ((y > 0) ? (y - 1) : y)*width + x];
+           importance[rtile.offset + rtile.x + (y+rtile.y)*rtile.stride + x] += BlurringKernel[0]*temp_importance[                                y *width + x];
+           importance[rtile.offset + rtile.x + (y+rtile.y)*rtile.stride + x] += BlurringKernel[1]*temp_importance[(((height - y) > 1) ? (y + 1) : y)*width + x];
+           importance[rtile.offset + rtile.x + (y+rtile.y)*rtile.stride + x] += BlurringKernel[2]*temp_importance[(((height - y) > 2) ? (y + 2) : y)*width + x];
+           importance[rtile.offset + rtile.x + (y+rtile.y)*rtile.stride + x] += BlurringKernel[3]*temp_importance[(((height - y) > 3) ? (y + 3) : y)*width + x];
+       }
+   }
+   delete[] temp_importance;
+}
+
+void RenderBuffers::build_importance_map()
+{
+   int samples_pass = 0, pixel_stride;
+   bool found_samples_pass = false;
+   foreach(Pass& pass, params.passes) {
+       if (pass.type != PASS_SAMPLES)
+           samples_pass += pass.components;
+       else {
+           found_samples_pass = true;
+           break;
+       }
+   }
+   assert(found_samples_pass);
+   pixel_stride = params.get_passes_size();
+    float* ptr = (float*) buffer.data_pointer;
+    for (int y = 0; y < params.height; y++)
+        for (int x = 0; x < params.width; x++) {
+            if (*(ptr + samples_pass) > 0.0f)
+                importance_map[y*params.width + x] = linear_gray_to_inv_tvi(linear_rgb_to_gray(*((float4*) ptr) / *(ptr + samples_pass)));
+            else importance_map[y*params.width + x] = 10.0f;
+            ptr += pixel_stride;
+        }
+
+   float *temp_importance = new float[params.width * params.height];
+   for (int y = 0; y < params.height; y++) {
+       for (int x = 0; x < params.width; x++) {
+           temp_importance[y*params.width + x]  = BlurringKernel[0]*importance_map[y*params.width +                  ((x > 1) ? (x - 2) : x)];
+           temp_importance[y*params.width + x] += BlurringKernel[1]*importance_map[y*params.width +                  ((x > 0) ? (x - 1) : x)];
+           temp_importance[y*params.width + x] += BlurringKernel[2]*importance_map[y*params.width +                                       x ];
+           temp_importance[y*params.width + x] += BlurringKernel[3]*importance_map[y*params.width + (((params.width - x) > 1) ? (x + 1) : x)];
+           temp_importance[y*params.width + x] += BlurringKernel[4]*importance_map[y*params.width + (((params.width - x) > 1) ? (x + 1) : x)];
+       }
+   }
+   for (int y = 0; y < params.height; y++) {
+       for (int x = 0; x < params.width; x++) {
+           importance_map[y*params.width + x]  = BlurringKernel[0]*temp_importance[                  ((y > 1) ? (y - 2) : y)*params.width + x];
+           importance_map[y*params.width + x] += BlurringKernel[1]*temp_importance[                  ((y > 0) ? (y - 1) : y)*params.width + x];
+           importance_map[y*params.width + x] += BlurringKernel[2]*temp_importance[                                       y *params.width + x];
+           importance_map[y*params.width + x] += BlurringKernel[3]*temp_importance[(((params.height - y) > 1) ? (y + 1) : y)*params.width + x];
+           importance_map[y*params.width + x] += BlurringKernel[4]*temp_importance[(((params.height - y) > 1) ? (y + 1) : y)*params.width + x];
+       }
+   }
+   delete[] temp_importance;
+}
+
+CDF_2D::CDF_2D(float *in_data, int width_, int height_, int stride)
+{
+   width = width_;
+   height = height_;
+   marginal = new float[height];
+   data = new float[width*height];
+
+   for (int y = 0; y < height; y++) {
+       float *in_row = in_data + y*stride;
+       float *row = data + y*width;
+
+       row[0] = in_row[0];
+       for (int x = 1; x < width; x++)
+           row[x] = row[x-1] + in_row[x];
+
+       marginal[y] = row[width-1] + ((y == 0) ? 0.0f : marginal[y-1]);
+
+       float scale = 1.0f / row[width-1];
+       for (int x = 0; x < width; x++)
+           row[x] *= scale;
+   }
+
+   float scale = 1.0f / marginal[height-1];
+   for (int y = 0; y < height; y++)
+       marginal[y] *= scale;
+}
+
+CDF_2D::~CDF_2D()
+{
+   if (marginal) delete[] marginal;
+   if (data) delete[] data;
+}
+
+void CDF_2D::sample(float u, float v, int &x, int &y)
+{
+   y = std::lower_bound(marginal, marginal + height, v) - marginal;
+   x = std::lower_bound(data + y*width, data + (y+1)*width, u) - data - y*width;
+}
+
+void CDF_2D::eval_02(uint i, uint rotation, float &u, float &v)
+{
+   uint r = 0, i_ = i;
+   for(uint va = 1U << 31; i_; i_ >>= 1, va ^= va >> 1)
+       if(i_ & 1)
+           r ^= va;
+   v = (float)r * (1.0f/(float)0xFFFFFFFF) + (rotation & 0xFFFF) * (1.0f/(float)0xFFFF);
+   v -= floorf(v);
+
+   i = (i << 16) | (i >> 16);
+   i = ((i & 0x00ff00ff) << 8) | ((i & 0xff00ff00) >> 8);
+   i = ((i & 0x0f0f0f0f) << 4) | ((i & 0xf0f0f0f0) >> 4);
+   i = ((i & 0x33333333) << 2) | ((i & 0xcccccccc) >> 2);
+   i = ((i & 0x55555555) << 1) | ((i & 0xaaaaaaaa) >> 1);
+   u = (float)i * (1.0f/(float)0xFFFFFFFF) + (rotation >> 16) * (1.0f/(float)0xFFFF);
+   u -= floorf(u);
+}
+
+void CDF_2D::sample_02_jittered(int i, int vx, int vy, int &x, int &y) {
+   float u, v;
+   eval_02(i, hash_int_2d(vx, vy), u, v);
+   sample((vx + u) / width, (vy + v) / height, x, y);
+}
+
+#define stop_error 0.001f
+
+float tile_error(RenderTile &rtile, float error_power) {
+    if (!rtile.buffers->copy_from_device()) return -1;
+
+   int samples_pass = 0, variance_pass = 0;
+   bool found_samples_pass = false, found_variance_pass = false;
+   foreach(Pass& pass, rtile.buffers->params.passes) {
+       if (pass.type != PASS_SAMPLES)
+           samples_pass += pass.components;
+       else {
+           found_samples_pass = true;
+           break;
+       }
+   }
+   assert(found_samples_pass);
+   foreach(Pass& pass, rtile.buffers->params.passes) {
+       if (pass.type != PASS_VARIANCE)
+           variance_pass += pass.components;
+       else {
+           found_variance_pass = true;
+           break;
+       }
+   }
+   assert(found_variance_pass);
+
+   int pass_stride = rtile.buffers->params.get_passes_size();
+   float *passes = (float*)rtile.buffers->buffer.data_pointer + (rtile.offset + rtile.x + rtile.y * rtile.stride) * pass_stride;
+   float *importance = rtile.buffers->importance_map + rtile.offset + rtile.x + rtile.y * rtile.stride;
+   float error = 0.0f;
+
+   for (int y = 0; y < rtile.h; y++) {
+       for (int x = 0; x < rtile.w; x++, passes += pass_stride, importance++) {
+           float3 *combinedPass, *variancePass;
+           float *samplesPass;
+           combinedPass = (float3*) passes;
+           variancePass = (float3*) (passes + variance_pass);
+           samplesPass = passes + samples_pass;
+            
+            if (*samplesPass < 2)
+                return -1; //No sample at this pixel yet
+
+           float factor = 1.0f / (*samplesPass);
+           float intensityFactor = linear_gray_to_inv_tvi(linear_rgb_to_gray(*combinedPass * factor));
+
+            float3 variance = (*variancePass) / (*samplesPass - 1);
+           /*
+             * sqrt(variance) * IF gives PWSD (see build_importance)
+             * O(1/sqrt(N)) convergence => PWSD / sqrt(N) gives an approximation of the remaining error
+             * sqrt(variance) * IF / sqrt(N) is equal to sqrt(variance / N) * IF
+             */
+            
+            float svariance = max(linear_rgb_to_gray(variance), 0.0f);
+            
+           float perror = sqrtf(svariance * factor) * intensityFactor;
+            error += powf(perror, error_power);
+       }
+       passes += (rtile.stride - rtile.w) * pass_stride;
+       importance += rtile.stride - rtile.w;
+   }
+   error /= rtile.w * rtile.h;
+   return powf(error, 1.0f / error_power);
+}
+
+bool tile_converged(RenderTile &rtile, DeviceTask *task)
+{
+    if (task->error_progressive) return false;
+   if (task->stopping_threshold <= 0.0f) return false;
+   if (rtile.sample < task->map_interval) return false;
+   if (rtile.sample % task->map_interval) return false;
+
+   float error = tile_error(rtile, task->adaptive_error_power);
+    if (error < 0) return false;
+   return (error < task->stopping_threshold);
+}
+
+CCL_NAMESPACE_END
diff -ru --new-file blender-2.76b.old/intern/cycles/util/util_importance.h blender-2.76b/intern/cycles/util/util_importance.h
--- blender-2.76b.old/intern/cycles/util/util_importance.h	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/intern/cycles/util/util_importance.h	2016-01-14 12:13:37.316827161 +0300
@@ -0,0 +1,49 @@
+/*
+ * Copyright 2011-2013 Blender Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+
+#ifndef __UTIL_IMPORTANCE_H__
+#define __UTIL_IMPORTANCE_H__
+
+#include <algorithm>
+#include "util_color.h"
+#include "buffers.h"
+#include "device_task.h"
+
+CCL_NAMESPACE_BEGIN
+
+void build_importance(RenderTile &tile);
+float tile_error(RenderTile &rtile, float error_power);
+bool tile_converged(RenderTile &rtile, DeviceTask *task);
+
+class CDF_2D {
+public:
+   CDF_2D(float *data_, int width_, int height_, int stride);
+
+   ~CDF_2D();
+
+   void sample(float u, float v, int &x, int &y);
+
+   void eval_02(uint i, uint rotation, float &u, float &v);
+
+   void sample_02_jittered(int i, int vx, int vy, int &x, int &y);
+private:
+   float *data, *marginal;
+   int width, height;
+};
+
+CCL_NAMESPACE_END
+
+#endif /* __UTIL_IMPORTANCE_H__ */
diff -ru --new-file blender-2.76b.old/intern/cycles/util/util_list.h blender-2.76b/intern/cycles/util/util_list.h
--- blender-2.76b.old/intern/cycles/util/util_list.h	2015-10-27 19:57:22.000000000 +0300
+++ blender-2.76b/intern/cycles/util/util_list.h	2016-01-14 12:14:27.167562363 +0300
@@ -18,11 +18,22 @@
 #define __UTIL_LIST_H__
 
 #include <list>
+#include <queue>
 
 CCL_NAMESPACE_BEGIN
 
 using std::list;
 
+template<typename T, typename compare = std::less<T> >
+class PriorityQueue : public std::priority_queue<T, std::vector<T>, compare>{
+public:
+	typedef typename std::vector<T>::iterator iterator;
+	void clear() { this->c.clear(); }
+	iterator begin() { return this->c.begin(); }
+	iterator end() { return this->c.end(); }
+	void push_back(const T &v) { this->push(v); }
+};
+
 CCL_NAMESPACE_END
 
 #endif /* __UTIL_LIST_H__ */
diff -ru --new-file blender-2.76b.old/intern/cycles/util/util_metropolis.h blender-2.76b/intern/cycles/util/util_metropolis.h
--- blender-2.76b.old/intern/cycles/util/util_metropolis.h	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/intern/cycles/util/util_metropolis.h	2016-01-14 12:14:59.284036072 +0300
@@ -0,0 +1,46 @@
+/*
+ * Copyright 2011-2013 Blender Foundation
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License
+ */
+
+#ifndef __UTIL_METROPOLIS_H__
+#define __UTIL_METROPOLIS_H__
+
+#include <algorithm>
+#include "kernel_types.h"
+
+CCL_NAMESPACE_BEGIN
+
+static inline int metro_get_size(int numChains, int sampleSize) {
+    int size = sizeof(MetropolisChain); //Metropolis Chains
+    size += 2*sampleSize*sizeof(uint); //SampleStamps arrays
+    size += 3*sampleSize*sizeof(float); //Samples arrays and rngRotation
+    size = ((size + 15)/16) * 16; //Round to 16 bytes for alignment
+    return numChains*size;
+}
+
+static inline void metro_build_rng_table(float* table) {
+    table[0] = 0.0f;
+    table[1] = 1.0f / METRO_RNG_N;
+    uint rngState = 1;
+    for (int i = 2; i < METRO_RNG_N; i++) {
+        rngState = (rngState * METRO_RNG_A) % METRO_RNG_N; //LCG
+        table[i] = ((float) rngState) / METRO_RNG_N;
+    }
+    std::random_shuffle(table, table + METRO_RNG_N);
+}
+
+CCL_NAMESPACE_END
+
+#endif /* __UTIL_METROPOLIS_H__ */
