diff -ru --new-file blender-2.76b.old/build_files/cmake/macros.cmake blender-2.76b/build_files/cmake/macros.cmake
--- blender-2.76b.old/build_files/cmake/macros.cmake	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/build_files/cmake/macros.cmake	2016-01-27 18:46:54.666785993 +0300
@@ -692,6 +692,10 @@
 		list(APPEND BLENDER_SORTED_LIBS bf_intern_opensubdiv)
 	endif()
 
+	if(WITH_VORO)
+		list(APPEND BLENDER_SORTED_LIBS extern_voro)
+	endif()
+
 	foreach(SORTLIB ${BLENDER_SORTED_LIBS})
 		set(REMLIB ${SORTLIB})
 		foreach(SEARCHLIB ${BLENDER_LINK_LIBS})
diff -ru --new-file blender-2.76b.old/build_files/scons/tools/btools.py blender-2.76b/build_files/scons/tools/btools.py
--- blender-2.76b.old/build_files/scons/tools/btools.py	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/build_files/scons/tools/btools.py	2016-01-27 18:47:52.616353753 +0300
@@ -171,6 +171,7 @@
             'WITH_BF_BOOLEAN',
             'WITH_BF_REMESH',
             'WITH_BF_OCEANSIM',
+            'WITH_BF_VORONOI',
             'WITH_BF_SMOKE',
             'WITH_BF_CXX_GUARDEDALLOC',
             'WITH_BF_JEMALLOC', 'WITH_BF_STATICJEMALLOC', 'BF_JEMALLOC', 'BF_JEMALLOC_INC', 'BF_JEMALLOC_LIBPATH', 'BF_JEMALLOC_LIB', 'BF_JEMALLOC_LIB_STATIC',
@@ -289,6 +290,7 @@
         (BoolVariable('WITH_BF_BOOLEAN', 'Build with boolean modifier', True)),
         (BoolVariable('WITH_BF_REMESH', 'Build with remesh modifier', True)),
         (BoolVariable('WITH_BF_OCEANSIM', 'Build with ocean simulation', False)),
+        (BoolVariable('WITH_BF_VORONOI', 'Build with voronoi cells in explo modifier', True)),
         (BoolVariable('WITH_BF_SMOKE', 'Build with smoke simulation', True)),
         ('BF_PROFILE_FLAGS', 'Profiling compiler flags', ''),
         (BoolVariable('WITH_BF_OPENAL', 'Use OpenAL if true', False)),
diff -ru --new-file blender-2.76b.old/CMakeLists.txt blender-2.76b/CMakeLists.txt
--- blender-2.76b.old/CMakeLists.txt	2016-01-27 18:39:43.668008004 +0300
+++ blender-2.76b/CMakeLists.txt	2016-01-27 18:44:56.736666316 +0300
@@ -227,6 +227,7 @@
 option(WITH_GAMEENGINE    "Enable Game Engine" ${_init_GAMEENGINE})
 option(WITH_PLAYER        "Build Player" OFF)
 option(WITH_OPENCOLORIO   "Enable OpenColorIO color management" ${_init_OPENCOLORIO})
+option(WITH_VORO    "Enable Voronoi Fracture based on Voro++" ON)
 
 # Compositor
 option(WITH_COMPOSITOR         "Enable the tile based nodal compositor" ON)
@@ -2910,6 +2911,7 @@
 	info_cfg_option(WITH_CYCLES)
 	info_cfg_option(WITH_FREESTYLE)
 	info_cfg_option(WITH_OPENCOLORIO)
+	info_cfg_option(WITH_VORO)
 
 	info_cfg_text("Compiler Options:")
 	info_cfg_option(WITH_BUILDINFO)
diff -ru --new-file blender-2.76b.old/extern/SConscript blender-2.76b/extern/SConscript
--- blender-2.76b.old/extern/SConscript	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/extern/SConscript	2016-01-27 18:49:08.012791709 +0300
@@ -52,5 +52,8 @@
     if env['OURPLATFORM'] in ('linux', 'openbsd3', 'sunos5', 'aix4', 'aix5'):
         SConscript(['xdnd/SConscript'])
 
+if env ['WITH_BF_VORONOI']:
+    SConscript(['voro++/SConscript'])
+
 if env['WITH_BF_SDL'] and env['WITH_BF_SDL_DYNLOAD']:
     SConscript(['sdlew/SConscript'])
diff -ru --new-file blender-2.76b.old/extern/voro++/CMakeLists.txt blender-2.76b/extern/voro++/CMakeLists.txt
--- blender-2.76b.old/extern/voro++/CMakeLists.txt	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/CMakeLists.txt	2016-01-27 18:50:12.251313130 +0300
@@ -0,0 +1,40 @@
+set (INC 
+	src
+)
+
+set (INC_SYS
+)
+
+set (SRC 
+	src/c_loops.cc
+    src/cell.cc
+    src/cmd_line.cc
+    src/common.cc
+    src/container_prd.cc
+    src/container.cc
+    src/pre_container.cc
+    src/unitcell.cc
+    src/v_base.cc
+    src/v_compute.cc
+#    src/voro++.cc
+    src/wall.cc
+    src/c_interface.cc
+    
+    src/c_loops.hh
+    src/cell.hh
+    src/common.hh
+    src/config.hh
+    src/container_prd.hh
+    src/container.hh
+    src/pre_container.hh
+    src/rad_option.hh
+    src/unitcell.hh
+    src/v_base.hh
+    src/v_compute.hh
+#    src/voro++.hh
+    src/wall.hh
+    src/worklist.hh
+    src/c_interface.hh
+)
+
+blender_add_lib(extern_voro "${SRC}" "${INC}" "${INC_SYS}")
diff -ru --new-file blender-2.76b.old/extern/voro++/LICENSE blender-2.76b/extern/voro++/LICENSE
--- blender-2.76b.old/extern/voro++/LICENSE	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/LICENSE	2016-01-27 18:50:37.603124022 +0300
@@ -0,0 +1,39 @@
+Voro++ Copyright (c) 2008, The Regents of the University of California, through
+Lawrence Berkeley National Laboratory (subject to receipt of any required
+approvals from the U.S. Dept. of Energy). All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met: 
+
+(1) Redistributions of source code must retain the above copyright notice, this
+list of conditions and the following disclaimer. 
+
+(2) Redistributions in binary form must reproduce the above copyright notice,
+this list of conditions and the following disclaimer in the documentation
+and/or other materials provided with the distribution. 
+
+(3) Neither the name of the University of California, Lawrence Berkeley
+National Laboratory, U.S. Dept. of Energy nor the names of its contributors may
+be used to endorse or promote products derived from this software without
+specific prior written permission. 
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
+
+You are under no obligation whatsoever to provide any bug fixes, patches, or
+upgrades to the features, functionality or performance of the source code
+("Enhancements") to anyone; however, if you choose to make your Enhancements
+available either publicly, or directly to Lawrence Berkeley National
+Laboratory, without imposing a separate written license agreement for such
+Enhancements, then you hereby grant the following license: a  non-exclusive,
+royalty-free perpetual license to install, use, modify, prepare derivative
+works, incorporate into other computer software, distribute, and sublicense
+such enhancements or derivative works thereof, in binary and source code form.
diff -ru --new-file blender-2.76b.old/extern/voro++/NEWS blender-2.76b/extern/voro++/NEWS
--- blender-2.76b.old/extern/voro++/NEWS	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/NEWS	2016-01-27 18:51:27.362752524 +0300
@@ -0,0 +1,341 @@
+Version 0.4.6 (October 17th 2013)
+=================================
+* Fixed an issue with template instantiation in wall.cc that was causing
+  compilation problems with new versions of Apple Xcode. Thanks to Barend
+  Thijsse (Delft University of Technology) and Juan Pablo Cruz Pérez (Instituto
+  de Física y Matemáticas) for pointing this out.
+* Added routines to the container classes to compute a ghost Voronoi cell at
+  any given location, as though an extra particle was inserted at that
+  location
+* Removed unused private variable in c_loops.hh
+* Updated Doxyfile to 1.8.5
+
+Version 0.4.5 (July 27th 2012)
+==============================
+* Removed "using namespace std" from the header files and added extra "std::"
+  qualifiers on STL vectors and queues. This is to prevent naming conflicts
+  with other libraries. Thanks to Florian Hoffmann (University of Luxembourg)
+  for pointing this out.
+* Fixed an error in the check_facets diagnostic routine. Thanks to Tristan
+  Carrier-Baudouin (Université catholique de Louvain) for pointing this out.
+* Fixed a memory leak in the new container_periodic class. Thanks to Massimo
+  Marchi (Commissariat á l'Energie Atomique) for pointing this out.
+* Removed some duplicate or unnecessary #include statements of the standard C++
+  header files
+* Fix small naming mismatch between cell.cc and cell.hh in plane_intersects
+  and nplane routines, which would give a warning with Doxygen
+* More changes for older MS Visual C++ compatability
+* Updated Doxyfile to 1.8.1.1
+
+Version 0.4.4 (January 17th 2012)
+=================================
+* Fixed an error in pointer arithmetic that was introduced in version 0.4,
+  which would occur in cases where the delete stack was extended when a large
+  number of vertices were being removed. Thanks to Jeff Johnson (Lawrence
+  Berkeley Laboratory) and Matt Freeman (Texas A&M University) for pointing
+  this out.
+
+Version 0.4.3 (November 12th 2011)
+==================================
+* Removed spurious Gnuplot output line from torus.cc example
+* More changes for better Visual C++ compatibility
+* Fixed indexing error in worklist generation routine. This had no effect
+  on the generated worklists, but would become apparent in other situations.
+* Added rad_option.hh to the list of files included by voro++.hh for
+  completeness
+* Fix errors in Gnuplot commands in the basic examples README file. Thanks to
+  William-Fernando Oquendo (National University of Colombia) for pointing this
+  out.
+* Fixed memory allocation issue in face_freq_table routine - thanks to Lingti
+  Kong for pointing this out
+* Minor cleanups and optimizations to wall classes
+
+Version 0.4.2 (September 23rd 2011)
+===================================
+* Fixed a bug in the put_remap routine where a z periodic boolean was
+  switched to an x periodic boolean. This would only be noticed when using
+  mixed periodic boundary conditions and importing particles that need to be
+  remapped.
+* The pid function in the c_loop_base class was mistakenly labeled as double
+  instead of int - this is now fixed. Thanks to William-Fernando Oquendo
+  (National University of Colombia) for pointing this out.
+* Fixed an extremely subtle bounds checking issue that would only materialize
+  for the radical Voronoi tessellation with large particle radii. Thanks to
+  Richard Martin and Maciej Haranczyk (Lawrence Berkeley Laboratory) for
+  pointing out the original problem.
+* Fixed other problems with the radical tessellation. Originally, the
+  algorithms were concieved for with hard spheres in mind, where the particles
+  would not overlap, and an assumption was used in the cutoff procedure that
+  made use of this, but would not be true in general.
+* Removed more bracket initializations like "double a(3);" for better
+  consistency, and more compatibility with older versions of MS Visual C++.
+  Thanks to Martin Brehm for help with this.
+* Factored out the regular/radical inline routines into separate classes, so
+  that they don't have to be duplicated in the container_periodic classes
+* Fixed problems with the container_periodic classes referencing the wrong
+  loop classes. Thanks to Wang Chuncheng (Nanyang Technological University) for
+  pointing this out.
+* Added c_loop_order_periodic class for doing ordered loops with the periodic
+  container classes
+* Updated the README file in the src directory. The detailed description of
+  each file has been removed since this is difficult to maintain and this
+  information is already present in the class reference manual.
+* Fixed an error in the pre_container selection of the optimal computational
+  grid size
+* Code comment cleanups, particularly in wall.hh
+* Minor man page reformatting
+* Updated Doxyfile to version 1.7.5.1
+
+Version 0.4.1 (September 7th 2011)
+==================================
+* Fixed bug in command-line utility that would give incorrect results when
+  using the "-c" option for custom output. Thanks to Prof. Aldo Romero
+  (CINVESTAV-Unidad Queretaro) for pointing this out.
+* Added some additional documentation about neighbor information
+
+Version 0.4 (August 30th 2011)
+==============================
+* New classes called container_periodic and container_periodic_poly that carry
+  out Voronoi computations in 3D periodic parallelepiped unit cells have been
+  added. This adds significant complexity to the computation, and the memory
+  organization of these classes is different, requiring allocation for ghost
+  regions. Currently these classes cannot be accessed by the command-line
+  utility, but will be integrated further in future releases. These classes are
+  currently mainly exploited by a sister software project Zeo++ for chemical
+  informatics (Maciej Haranczyk, Chris Rycroft, Thomas Willems, Richard Martin)
+  to be released in late 2011.
+* As part of the new container_periodic classes, a new class called unitcell
+  has been added, which will compute the Voronoi cell for a single particle in
+  a 3D periodic parallelepiped class. The Voronoi cell is formed by the
+  influences of the periodic images of itself only. This turns out to be an
+  important component of the calculations done by the container_periodic
+  classes but can also be used independently.
+* The container classes now have a routine called find_voronoi_cell that will
+  take a given position vector and return the Voronoi cell which is contained
+  within. For the regular Voronoi tessellation, this is just the Voronoi cell
+  corresponding to the closest particle (by definition). For the radical
+  Voronoi tessellation, this is weighted by the particle radii.
+* The library is now enclosed within the "voro" namespace. This requires
+  specifying "using namespace voro;" in the preamble of codes or prepending
+  "voro::" to access functions. This greatly minimizes the possiblity of naming
+  conflicts when using multiple libraries, particularly since many of the
+  classes iin the library have fairly generic names (eg. "container"). Thanks to
+  Allan Johns (Dr. D Studios) for suggesting this.
+* Voro++ can now be built as a static library that can be installed and linked
+  to. As part of this, the .cc and .hh files have been significantly revised
+  with some small inline functions and template code being written into the
+  header files.
+* Previously, all of the voronoicell output routines sent data to an output
+  stream. However, input and output are now carried out using the STL vector
+  class, allowing for programs to directly link to and use Voro++ output. The
+  STL vector class has been chosen since it the simplest and most standard
+  mechanism for returning a variable amount of data. Several new examples are
+  provided to demonstrate this functionality, for both the voronoicell class
+  and the container class.
+* A common issue has been that the order of particles in the output file does
+  not match the input file, since Voro++ internally sorts particles according
+  to their position. A new class called voro_order has been provided, which can
+  link to particles as they are stored, allowing for the Voronoi computation to
+  be carried out in the same order as the input file. The core computation
+  routines can be run with a variety of different loops, and a new example
+  "loops.cc" is provided to demonstrate this. 
+* The order of parameters to certain functions have been changed to take
+  advantage of the C++ default parameter mechanism wherever possible
+* The container and container_poly classes are now derived from a base class,
+  rather than being different instances of a template. This simplifies the code
+  and stops common routines from being duplicated. The core Voronoi computation
+  routine is now held within a voro_compute class, which can be instantiated on
+  any container with the correct access functions.
+* The voronoicell and voronoicell_neighbor classes are now derived from a
+  common base class, rather than being different instances of a template. This
+  simplifies the code and stops common routines from being duplicated. The core
+  nplane routine is now a function template that can be instantiated on the
+  parent class itself. 
+* All output routines have been switched from using C++ iostreams to using the C
+  cstdio library. This has been done for increased performance. In general the
+  cstdio routines run significantly faster than the comparable iostream
+  routines: for one file import test, using fscanf from cstdio was five times
+  as fast as the comparable << operator from iostream. As another example,
+  the program "cylinder.cc", which uses both file import and export, runs
+  approximately twice as fast before. Since many people use Voro++ to batch
+  process large numbers of input files, this increase in input/output speed
+  seemed desirable.
+* The Gnuplot output routines now merge individual lines into contiguous paths
+  wherever possible, resulting in a ~15% reduction in their file size and a
+  noticeable improvement in rendering speed
+* Previously, the POV-Ray output routines could create cylinders where the start
+  and end points matched. This was a benign problem, due to the fact the vertex
+  positions within Voro++ were held to higher precision than the POV-Ray output
+  file, meaning that distinct vertices could appear to be at the same position;
+  a perl script was provided to post-process and remove these. However, Voro++
+  now scans each cylinder before saving to file to automatically remove these
+  cases from consideration.
+* Pointer arithmetic is now used within a number of critical cell computation
+  routines, and gives a speedup of 10%-20% in many cases. On some typical
+  problems on typical machines, Voro++ currently computes around 50,000
+  cells/second. New machines can achieve upwards of 70,000 cells/second.
+* A new pre-container mechanism is provided, which can read in a file of
+  unknown length, and then make a guess at the correct computational grid size
+  to use. This removes the need for specifying a length scale with the
+  command-line utility. However, a length scale or grid decomposition can still
+  be manually specified.
+* Removed the option to compile in single-precision. This was a highly
+  specialized feature, and it appears better to allow users who wish to do this
+  to make their own modifications. This option also conflicted with building
+  Voro++ as a standard static library.
+* Fixed a benign bug in the block computation list that would cause it to get
+  extended prematurely
+* Numerous small improvements to memory allocation routines
+* Added routines to copy a Voronoi cell
+* Created a new wall_list class to handle a list of walls. This simplifies the
+  command-line utility code.
+* Labels in the worklist that are used in the transition from the radius search
+  to the block search have been optimized
+* The command-line utility can now produce POV-Ray output. Also, the main loop
+  in the utility has been combined so that the Voronoi tessellation is only
+  carried out once, even if POV-Ray and Gnuplot output is also required.
+* The command-line utility does range checking on the filename to prevent
+  buffer overruns
+* The routines that put particles into a container now do so more reliably for
+  periodic cases, remapping them into the primary domain if necessary
+* A number of the POV-Ray header files have been altered to directly make use
+  of a right-handed coordinate system in which the z axis points upwards. This
+  matches the Gnuplot style, and the style used in many scientific simulations.
+  It avoids the need for a rotation or matrix transformation when rendering
+  many of the particle packings. Some of the test particle packings have been
+  transformed to ensure consistency with previous renderings.
+* Some POV-Ray files have been cleaned up and there are additional comments
+* Fixed a bug in the print_all_custom() routine, affecting "%P" output. Thanks
+  to David Waroquiers (Université Catholique de Louvain, Belgium) for pointing
+  this out.
+* Fixed a bug that caused the neighbor list not to be outputted in the same
+  order as the other plane diagnostic routines. Thanks to Olufemi Olorode
+  (Texas A&M University) for pointing this out.
+* Removed the add_vertex() and init_test() routines, which were mainly used for
+  debugging
+* Updated Doxyfile to version 1.7.4
+
+Version 0.3.1 (September 29, 2009)
+==================================
+* Carried out a major overhaul of the source code comments that are used by
+  Doxygen. Several errors in the documentation were fixed.
+* Additional comments in the Makefiles, and added the "phony target" keyword
+* Many code cleanups and standardizations. Some double and triple loops
+  were concatenated into one to reduce the amount of indentation.
+* Fixed the import.cc example program
+* Updated Doxyfile to version 1.6.1
+
+Version 0.3 (August 17, 2009)
+=============================
+* In response to feedback from several people, the routines for computing
+  statistics about computed Voronoi cells have been significantly revised,
+  extended, and put within a common framework. The voronoicell class now has a
+  large number of routines of the form output_...() that will print cell
+  information to an output stream. There are also a number of new, simple
+  routines for computing basic statistics such as the number of edges and faces
+  of each cell. All of these routines can now be used during the container
+  analysis, by making use of the new print_custom() routine, which can output
+  according to a given format string, that uses control sequences similar to
+  the standard C printf() routine.
+* Renamed the "radical" example directory to "custom", and added two
+  new programs called "cell_statistics.cc" and "custom_output.cc" for
+  demonstrating the new output routines for the voronoicell and container
+  classes respectively
+* Added a routine for computing the centroid of a Voronoi cell
+* Added new routines for computing neighbor normals, in response to a
+  request from Dave Greenwood
+* Removed unnecessary trailing tabs and spaces in the source code
+* Fixed a few text justification problems, and altered some of the comments
+  in the example programs
+* Improved the command-line utility, allowing it to specify custom information
+  in the output. Implemented better error checking on command-line arguments.
+* Removed the facets() routine, since this has been superseded by the new
+  output_...() routines. This also rendered some functions in the neighbor_none
+  and neighbor_track classes obsolete, and they have also been removed.
+* Some reorganization of the cell.hh and container.hh header files to group
+  similar functions together
+* Added torus.cc example that shows how to write custom walls as derived
+  classes
+* Updated Doxyfile to version 1.5.9
+
+Version 0.2.7 (March 25, 2009)
+==============================
+* Added some missing cstdlib and cstring header files that cause compilation
+  errors on some systems
+* Some text cleanups in the main README file and cmd_line.cc
+* The worklist_gen.pl script was in DOS format. It has been switched to Unix
+  format to match the rest of the code.
+* Fixed some incorrect inequalities in degenerate2.cc
+* Improved some error messages in container.cc
+
+Version 0.2.6 (March 23, 2009)
+==============================
+* Significantly improved the error messages generated by the code. It now
+  makes use of the exit() routine rather than throwing errors, and it returns
+  various status codes (defined in config.hh) for different types of abnormal
+  behavior.
+* Changed two occurences of "cin" to "cout" in the draw_particles routines
+* Corrected error in comment in the tetrahedron example
+* Minor comment cleanups of the worklist_gen.pl script
+* Updated Doxyfile to version 1.5.8
+* Added a routine print_facet_information() in response to a problem
+  from Hengxing Lan
+* Many of the cell based statistics routines (like number_of_faces() and
+  facets()) internally track their progress by temporarily flipping the edge
+  table entries to negative values, so that they know where they have already
+  been. The common code that was used at the end of each of these functions for
+  resetting the edges back to positive has now been made into a private inline
+  function called reset_edges().
+* Fixed a missing initialization of max_radius to zero in the radius_poly
+  class. This should not have ever caused any errors, as max_radius would
+  always have been big enough. However if max_radius was initially set to a
+  large value, it could have potentially made the code run slower.
+* Fixed the code layout in the suretest class header
+* Added some additional checks in the command-line utility to screen out
+  invalid command-line arguments. Switched the test on the number of
+  computational blocks to use floating point arithmetic, because integers
+  could potentially overflow and become negative.
+* Included several more of the POV-Ray header files that were used to create
+  the example images on the website
+* Removed a "cout" statement in the wall_cone class
+* Cleanup of the README files for the basic examples and the wall examples
+
+Version 0.2.5 (January 1, 2009)
+===============================
+* Added the DOE acknowledgements to the code overview document
+
+Version 0.2.4 (December 14, 2008)
+=================================
+* Added the code overview PDF document to the package, in the docs directory
+* Fixed some spelling errors in the comments
+* Many more documentation updates
+
+Version 0.2.3 (December 9, 2008)
+================================
+* Removed an unused variable that was reported by the Portland C compiler
+* Documentation updates
+* Added the import.pov script
+* Added some simple functions to solve the problem from Stefan Eibl of counting
+  faces
+* Renamed the facets_loop to voropp_loop
+
+Version 0.2.2 (November 19, 2008)
+=================================
+* Main README file updated
+
+Version 0.2.1 (November 3, 2008)
+================================
+* Much more documentation
+* Brief Doxygen class comments
+* Updated Doxyfile to version 1.5.7
+
+Version 0.2 (October 31, 2008)
+==============================
+* Updated some occurrences of char* with const char* for compatability with
+  version 4.2 of the GNU C++ compiler
+* Making use of default parameters in the wall classes
+* The command-line utility can now add walls
+
+Version 0.1 (August 22, 2008)
+=============================
+* Initial version uploaded to the web
diff -ru --new-file blender-2.76b.old/extern/voro++/README2 blender-2.76b/extern/voro++/README2
--- blender-2.76b.old/extern/voro++/README2	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/README2	2016-01-27 18:52:11.674421792 +0300
@@ -0,0 +1,153 @@
+Voro++, a 3D cell-based Voronoi library (http://math.lbl.gov/voro++/)
+By Chris H. Rycroft (UC Berkeley / Lawrence Berkeley Laboratory)
+================================================================
+Voro++ is a software library for carrying out three-dimensional computations
+of the Voronoi tessellation. A distinguishing feature of the Voro++ library
+is that it carries out cell-based calculations, computing the Voronoi cell
+for each particle individually, rather than computing the Voronoi
+tessellation as a global network of vertices and edges. It is particularly
+well-suited for applications that rely on cell-based statistics, where
+features of Voronoi cells (eg. volume, centroid, number of faces) can be
+used to analyze a system of particles
+
+Voro++ comprises of several C++ classes that can be built as a static library
+and linked to. A command-line utility is also provided that can analyze text
+files of particle configurations and use most of the features of the code.
+Numerous examples are provided to demonstrate the library's features and all of
+these are discussed in detail on the library website.
+
+
+Compilation - Linux / Mac OS / Windows with Cygwin
+==================================================
+The code is written in ANSI C++, and compiles on many system architectures. The
+package contains the C++ source code, example files, miscellaneous utilities
+and documentation. On Linux, Mac OS, and Windows (using Cygwin), the
+compilation and installed can be carried out using GNU Make.
+
+To begin, the user should review the file "config.mk" in the top level
+directory, to make sure that the compilation and installation settings are
+appropriate for their system. Typing "make" will then compile the static
+library, command-line utility, and examples. The command-line utility and
+library will appear within the "src" directory.
+
+Following successful compilation, the library, command-line utility, and
+documentation can be installed by typing "sudo make install". By default, the
+program files are installed into /usr/local, and it may be necessary to modify
+your environment variables in order to access the installed files:
+
+- to use the command-line utility, the variable PATH should contain
+  /usr/local/bin.
+- to access the Voro++ man page, the variable MANPATH should contain
+  /usr/local/man.
+- to access the Voro++ header files, code compilation should include
+  the flag '-I/usr/local/include/voro++'.
+- to link to the static library, code compilation should include the
+  flags '-L/usr/local/lib' to tell the linker where to look, and then
+  '-lvoro++' to link to the library.
+
+The library website contains additional notes on setting environment variables,
+and many guides are available on the Internet.
+
+The code can later be uninstalled with "sudo make uninstall". It is also
+possible to use the library and command-line utility without installation by
+calling the files directly once they have been compiled. On systems where the
+user does not have root privileges to install into /usr/local, the "config.mk"
+file can be modified to install into the user's home directory by setting
+PREFIX=$(HOME). Voro++ supports parallel compilation by using the "make -j <n>"
+command where n is the number of threads.
+
+
+Compilation - Windows without Cygwin
+====================================
+On a Windows machine without a terminal environment like Cygwin, it is possible
+to import and compile the library in many standard C++ development
+environments. Users have reported success in building the library with
+Microsoft Visual C++ Express and Code::Blocks.
+
+
+Related programs
+================
+No external dependencies are required to compile and run the code, but several
+programs may be useful for analyzing the output:
+
+- The freeware plotting program Gnuplot (available at www.gnuplot.info) can be
+  used for rapid 2D and 3D visualization of the program output.
+
+- The freeware raytracer POV-Ray (available at www.povray.org) can be used for
+  high-quality renderings of the program output.
+
+- The reference manual is generated from comments in the source code using
+  Doxygen (available at www.doxygen.org). This package is only required if the
+  library files are being developed and the reference manuals need to be
+  regenerated. The complete reference manual to the current code is available
+  online at http://math.lbl.gov/voro++/doc/refman/
+
+
+Contents
+========
+examples - many documented examples making use of the library
+html - an HTML-based reference manual (generated by Doxygen)
+man - contains the man page that is installed with the program
+scripts - miscellaneous helper scripts
+src - source code files
+
+
+Usage
+=====
+Voro++ is released as free software through the Lawrence Berkeley National
+Laboratory - a detailed copyright notice is provided below, and the complete
+terms of the license can be found in the LICENSE file.
+
+I am very interested to hear from users of the software, so if you find this
+useful, please email me at chr@alum.mit.edu. Also, if you plan to publish an
+academic paper using this software, please consider citing one of the following
+publications:
+
+- Chris H. Rycroft, "Voro++: A three-dimensional Voronoi cell library in C++",
+  Chaos 19, 041111 (2009).
+
+- Chris H. Rycroft, Gary S. Grest, James W. Landry, and Martin Z. Bazant,
+  "Analysis of Granular Flow in a Pebble-Bed Nuclear Reactor",
+  Phys. Rev. E 74, 021306 (2006).
+
+- Chris H. Rycroft, "Multiscale Modeling in Granular Flow", PhD thesis
+  submitted to the Massachusetts Institute of Technology, September 2007.
+  (http://math.berkeley.edu/~chr/publish/phd.html)
+
+The first reference contains a one-page overview of the library. The second
+reference contains some of the initial images that were made using a very early
+version of this code, to track small changes in packing fraction in a large
+particle simulation. The third reference discusses the use of 3D Voronoi cells,
+and describes the algorithms that were employed in the early version of this
+code. Since the publication of the above references, the algorithms in Voro++
+have been significantly improved, and a paper specifically devoted to the
+current code architecture will be published during 2012.
+
+
+Copyright Notice
+================
+Voro++ Copyright (c) 2008, The Regents of the University of California, through
+Lawrence Berkeley National Laboratory (subject to receipt of any required
+approvals from the U.S. Dept. of Energy). All rights reserved.
+
+If you have questions about your rights to use or distribute this software,
+please contact Berkeley Lab's Technology Transfer Department at TTD@lbl.gov.
+
+NOTICE. This software was developed under partial funding from the U.S.
+Department of Energy. As such, the U.S. Government has been granted for itself
+and others acting on its behalf a paid-up, nonexclusive, irrevocable, worldwide
+license in the Software to reproduce, prepare derivative works, and perform
+publicly and display publicly. Beginning five (5) years after the date
+permission to assert copyright is obtained from the U.S. Department of Energy,
+and subject to any subsequent five (5) year renewals, the U.S. Government is
+granted for itself and others acting on its behalf a paid-up, nonexclusive,
+irrevocable, worldwide license in the Software to reproduce, prepare derivative
+works, distribute copies to the public, perform publicly and display publicly,
+and to permit others to do so.
+
+
+Acknowledgments
+===============
+This work was supported by the Director, Office of Science, Computational and
+Technology Research, U.S. Department of Energy under Contract No.
+DE-AC02-05CH11231.
diff -ru --new-file blender-2.76b.old/extern/voro++/SConscript blender-2.76b/extern/voro++/SConscript
--- blender-2.76b.old/extern/voro++/SConscript	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/SConscript	2016-01-27 18:53:56.416640360 +0300
@@ -0,0 +1,2298 @@
+#!/usr/bin/python
+
+import os
+Import ('env')
+
+sources = env.Glob('src/*.cc')
+sources.remove('src'+os.sep+'voro++.cc')
+sources.remove('src'+os.sep+'v_base_wl.cc')
+defs = []
+incs = ['src']
+
+env.BlenderLib ('extern_voro++', Split(sources), incs, defs, libtype=['extern'], priority=[40] )
+ndex: extern/voro++/src/Doxyfile
+==================================================================
+-- /dev/null
+++ extern/voro++/src/Doxyfile
+@ -0,0 +1,2281 @@
+# Doxyfile 1.8.5
+
+# This file describes the settings to be used by the documentation system
+# doxygen (www.doxygen.org) for a project.
+#
+# All text after a double hash (##) is considered a comment and is placed in
+# front of the TAG it is preceding.
+#
+# All text after a single hash (#) is considered a comment and will be ignored.
+# The format is:
+# TAG = value [value, ...]
+# For lists, items can also be appended using:
+# TAG += value [value, ...]
+# Values that contain spaces should be placed between quotes (\" \").
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+
+# This tag specifies the encoding used for all characters in the config file
+# that follow. The default is UTF-8 which is also the encoding used for all text
+# before the first occurrence of this tag. Doxygen uses libiconv (or the iconv
+# built into libc) for the transcoding. See http://www.gnu.org/software/libiconv
+# for the list of possible encodings.
+# The default value is: UTF-8.
+
+DOXYFILE_ENCODING      = UTF-8
+
+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded by
+# double-quotes, unless you are using Doxywizard) that should identify the
+# project for which the documentation is generated. This name is used in the
+# title of most generated pages and in a few other places.
+# The default value is: My Project.
+
+PROJECT_NAME           = Voro++
+
+# The PROJECT_NUMBER tag can be used to enter a project or revision number. This
+# could be handy for archiving the generated documentation or if some version
+# control system is used.
+
+PROJECT_NUMBER         =
+
+# Using the PROJECT_BRIEF tag one can provide an optional one line description
+# for a project that appears at the top of each page and should give viewer a
+# quick idea about the purpose of the project. Keep the description short.
+
+PROJECT_BRIEF          =
+
+# With the PROJECT_LOGO tag one can specify an logo or icon that is included in
+# the documentation. The maximum height of the logo should not exceed 55 pixels
+# and the maximum width should not exceed 200 pixels. Doxygen will copy the logo
+# to the output directory.
+
+PROJECT_LOGO           =
+
+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) path
+# into which the generated documentation will be written. If a relative path is
+# entered, it will be relative to the location where doxygen was started. If
+# left blank the current directory will be used.
+
+OUTPUT_DIRECTORY       = ..
+
+# If the CREATE_SUBDIRS tag is set to YES, then doxygen will create 4096 sub-
+# directories (in 2 levels) under the output directory of each output format and
+# will distribute the generated files over these directories. Enabling this
+# option can be useful when feeding doxygen a huge amount of source files, where
+# putting all generated files in the same directory would otherwise causes
+# performance problems for the file system.
+# The default value is: NO.
+
+CREATE_SUBDIRS         = NO
+
+# The OUTPUT_LANGUAGE tag is used to specify the language in which all
+# documentation generated by doxygen is written. Doxygen will use this
+# information to generate all constant output in the proper language.
+# Possible values are: Afrikaans, Arabic, Brazilian, Catalan, Chinese, Chinese-
+# Traditional, Croatian, Czech, Danish, Dutch, English, Esperanto, Farsi,
+# Finnish, French, German, Greek, Hungarian, Italian, Japanese, Japanese-en,
+# Korean, Korean-en, Latvian, Norwegian, Macedonian, Persian, Polish,
+# Portuguese, Romanian, Russian, Serbian, Slovak, Slovene, Spanish, Swedish,
+# Turkish, Ukrainian and Vietnamese.
+# The default value is: English.
+
+OUTPUT_LANGUAGE        = English
+
+# If the BRIEF_MEMBER_DESC tag is set to YES doxygen will include brief member
+# descriptions after the members that are listed in the file and class
+# documentation (similar to Javadoc). Set to NO to disable this.
+# The default value is: YES.
+
+BRIEF_MEMBER_DESC      = YES
+
+# If the REPEAT_BRIEF tag is set to YES doxygen will prepend the brief
+# description of a member or function before the detailed description
+#
+# Note: If both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the
+# brief descriptions will be completely suppressed.
+# The default value is: YES.
+
+REPEAT_BRIEF           = NO
+
+# This tag implements a quasi-intelligent brief description abbreviator that is
+# used to form the text in various listings. Each string in this list, if found
+# as the leading text of the brief description, will be stripped from the text
+# and the result, after processing the whole list, is used as the annotated
+# text. Otherwise, the brief description is used as-is. If left blank, the
+# following values are used ($name is automatically replaced with the name of
+# the entity):The $name class, The $name widget, The $name file, is, provides,
+# specifies, contains, represents, a, an and the.
+
+ABBREVIATE_BRIEF       =
+
+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then
+# doxygen will generate a detailed section even if there is only a brief
+# description.
+# The default value is: NO.
+
+ALWAYS_DETAILED_SEC    = NO
+
+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all
+# inherited members of a class in the documentation of that class as if those
+# members were ordinary class members. Constructors, destructors and assignment
+# operators of the base classes will not be shown.
+# The default value is: NO.
+
+INLINE_INHERITED_MEMB  = NO
+
+# If the FULL_PATH_NAMES tag is set to YES doxygen will prepend the full path
+# before files name in the file list and in the header files. If set to NO the
+# shortest path that makes the file name unique will be used
+# The default value is: YES.
+
+FULL_PATH_NAMES        = YES
+
+# The STRIP_FROM_PATH tag can be used to strip a user-defined part of the path.
+# Stripping is only done if one of the specified strings matches the left-hand
+# part of the path. The tag can be used to show relative paths in the file list.
+# If left blank the directory from which doxygen is run is used as the path to
+# strip.
+#
+# Note that you can specify absolute paths here, but also relative paths, which
+# will be relative from the directory where doxygen is started.
+# This tag requires that the tag FULL_PATH_NAMES is set to YES.
+
+STRIP_FROM_PATH        =
+
+# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of the
+# path mentioned in the documentation of a class, which tells the reader which
+# header file to include in order to use a class. If left blank only the name of
+# the header file containing the class definition is used. Otherwise one should
+# specify the list of include paths that are normally passed to the compiler
+# using the -I flag.
+
+STRIP_FROM_INC_PATH    =
+
+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter (but
+# less readable) file names. This can be useful is your file systems doesn't
+# support long names like on DOS, Mac, or CD-ROM.
+# The default value is: NO.
+
+SHORT_NAMES            = NO
+
+# If the JAVADOC_AUTOBRIEF tag is set to YES then doxygen will interpret the
+# first line (until the first dot) of a Javadoc-style comment as the brief
+# description. If set to NO, the Javadoc-style will behave just like regular Qt-
+# style comments (thus requiring an explicit @brief command for a brief
+# description.)
+# The default value is: NO.
+
+JAVADOC_AUTOBRIEF      = NO
+
+# If the QT_AUTOBRIEF tag is set to YES then doxygen will interpret the first
+# line (until the first dot) of a Qt-style comment as the brief description. If
+# set to NO, the Qt-style will behave just like regular Qt-style comments (thus
+# requiring an explicit \brief command for a brief description.)
+# The default value is: NO.
+
+QT_AUTOBRIEF           = NO
+
+# The MULTILINE_CPP_IS_BRIEF tag can be set to YES to make doxygen treat a
+# multi-line C++ special comment block (i.e. a block of //! or /// comments) as
+# a brief description. This used to be the default behavior. The new default is
+# to treat a multi-line C++ comment block as a detailed description. Set this
+# tag to YES if you prefer the old behavior instead.
+#
+# Note that setting this tag to YES also means that rational rose comments are
+# not recognized any more.
+# The default value is: NO.
+
+MULTILINE_CPP_IS_BRIEF = NO
+
+# If the INHERIT_DOCS tag is set to YES then an undocumented member inherits the
+# documentation from any documented member that it re-implements.
+# The default value is: YES.
+
+INHERIT_DOCS           = YES
+
+# If the SEPARATE_MEMBER_PAGES tag is set to YES, then doxygen will produce a
+# new page for each member. If set to NO, the documentation of a member will be
+# part of the file/class/namespace that contains it.
+# The default value is: NO.
+
+SEPARATE_MEMBER_PAGES  = NO
+
+# The TAB_SIZE tag can be used to set the number of spaces in a tab. Doxygen
+# uses this value to replace tabs by spaces in code fragments.
+# Minimum value: 1, maximum value: 16, default value: 4.
+
+TAB_SIZE               = 8
+
+# This tag can be used to specify a number of aliases that act as commands in
+# the documentation. An alias has the form:
+# name=value
+# For example adding
+# "sideeffect=@par Side Effects:\n"
+# will allow you to put the command \sideeffect (or @sideeffect) in the
+# documentation, which will result in a user-defined paragraph with heading
+# "Side Effects:". You can put \n's in the value part of an alias to insert
+# newlines.
+
+ALIASES                =
+
+# This tag can be used to specify a number of word-keyword mappings (TCL only).
+# A mapping has the form "name=value". For example adding "class=itcl::class"
+# will allow you to use the command class in the itcl::class meaning.
+
+TCL_SUBST              =
+
+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C sources
+# only. Doxygen will then generate output that is more tailored for C. For
+# instance, some of the names that are used will be different. The list of all
+# members will be omitted, etc.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_FOR_C  = YES
+
+# Set the OPTIMIZE_OUTPUT_JAVA tag to YES if your project consists of Java or
+# Python sources only. Doxygen will then generate output that is more tailored
+# for that language. For instance, namespaces will be presented as packages,
+# qualified scopes will look different, etc.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_JAVA   = NO
+
+# Set the OPTIMIZE_FOR_FORTRAN tag to YES if your project consists of Fortran
+# sources. Doxygen will then generate output that is tailored for Fortran.
+# The default value is: NO.
+
+OPTIMIZE_FOR_FORTRAN   = NO
+
+# Set the OPTIMIZE_OUTPUT_VHDL tag to YES if your project consists of VHDL
+# sources. Doxygen will then generate output that is tailored for VHDL.
+# The default value is: NO.
+
+OPTIMIZE_OUTPUT_VHDL   = NO
+
+# Doxygen selects the parser to use depending on the extension of the files it
+# parses. With this tag you can assign which parser to use for a given
+# extension. Doxygen has a built-in mapping, but you can override or extend it
+# using this tag. The format is ext=language, where ext is a file extension, and
+# language is one of the parsers supported by doxygen: IDL, Java, Javascript,
+# C#, C, C++, D, PHP, Objective-C, Python, Fortran, VHDL. For instance to make
+# doxygen treat .inc files as Fortran files (default is PHP), and .f files as C
+# (default is Fortran), use: inc=Fortran f=C.
+#
+# Note For files without extension you can use no_extension as a placeholder.
+#
+# Note that for custom extensions you also need to set FILE_PATTERNS otherwise
+# the files are not read by doxygen.
+
+EXTENSION_MAPPING      =
+
+# If the MARKDOWN_SUPPORT tag is enabled then doxygen pre-processes all comments
+# according to the Markdown format, which allows for more readable
+# documentation. See http://daringfireball.net/projects/markdown/ for details.
+# The output of markdown processing is further processed by doxygen, so you can
+# mix doxygen, HTML, and XML commands with Markdown formatting. Disable only in
+# case of backward compatibilities issues.
+# The default value is: YES.
+
+MARKDOWN_SUPPORT       = YES
+
+# When enabled doxygen tries to link words that correspond to documented
+# classes, or namespaces to their corresponding documentation. Such a link can
+# be prevented in individual cases by by putting a % sign in front of the word
+# or globally by setting AUTOLINK_SUPPORT to NO.
+# The default value is: YES.
+
+AUTOLINK_SUPPORT       = YES
+
+# If you use STL classes (i.e. std::string, std::vector, etc.) but do not want
+# to include (a tag file for) the STL sources as input, then you should set this
+# tag to YES in order to let doxygen match functions declarations and
+# definitions whose arguments contain STL classes (e.g. func(std::string);
+# versus func(std::string) {}). This also make the inheritance and collaboration
+# diagrams that involve STL classes more complete and accurate.
+# The default value is: NO.
+
+BUILTIN_STL_SUPPORT    = YES
+
+# If you use Microsoft's C++/CLI language, you should set this option to YES to
+# enable parsing support.
+# The default value is: NO.
+
+CPP_CLI_SUPPORT        = NO
+
+# Set the SIP_SUPPORT tag to YES if your project consists of sip (see:
+# http://www.riverbankcomputing.co.uk/software/sip/intro) sources only. Doxygen
+# will parse them like normal C++ but will assume all classes use public instead
+# of private inheritance when no explicit protection keyword is present.
+# The default value is: NO.
+
+SIP_SUPPORT            = NO
+
+# For Microsoft's IDL there are propget and propput attributes to indicate
+# getter and setter methods for a property. Setting this option to YES will make
+# doxygen to replace the get and set methods by a property in the documentation.
+# This will only work if the methods are indeed getting or setting a simple
+# type. If this is not the case, or you want to show the methods anyway, you
+# should set this option to NO.
+# The default value is: YES.
+
+IDL_PROPERTY_SUPPORT   = YES
+
+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC
+# tag is set to YES, then doxygen will reuse the documentation of the first
+# member in the group (if any) for the other members of the group. By default
+# all members of a group must be documented explicitly.
+# The default value is: NO.
+
+DISTRIBUTE_GROUP_DOC   = NO
+
+# Set the SUBGROUPING tag to YES to allow class member groups of the same type
+# (for instance a group of public functions) to be put as a subgroup of that
+# type (e.g. under the Public Functions section). Set it to NO to prevent
+# subgrouping. Alternatively, this can be done per class using the
+# \nosubgrouping command.
+# The default value is: YES.
+
+SUBGROUPING            = YES
+
+# When the INLINE_GROUPED_CLASSES tag is set to YES, classes, structs and unions
+# are shown inside the group in which they are included (e.g. using \ingroup)
+# instead of on a separate page (for HTML and Man pages) or section (for LaTeX
+# and RTF).
+#
+# Note that this feature does not work in combination with
+# SEPARATE_MEMBER_PAGES.
+# The default value is: NO.
+
+INLINE_GROUPED_CLASSES = NO
+
+# When the INLINE_SIMPLE_STRUCTS tag is set to YES, structs, classes, and unions
+# with only public data fields or simple typedef fields will be shown inline in
+# the documentation of the scope in which they are defined (i.e. file,
+# namespace, or group documentation), provided this scope is documented. If set
+# to NO, structs, classes, and unions are shown on a separate page (for HTML and
+# Man pages) or section (for LaTeX and RTF).
+# The default value is: NO.
+
+INLINE_SIMPLE_STRUCTS  = NO
+
+# When TYPEDEF_HIDES_STRUCT tag is enabled, a typedef of a struct, union, or
+# enum is documented as struct, union, or enum with the name of the typedef. So
+# typedef struct TypeS {} TypeT, will appear in the documentation as a struct
+# with name TypeT. When disabled the typedef will appear as a member of a file,
+# namespace, or class. And the struct will be named TypeS. This can typically be
+# useful for C code in case the coding convention dictates that all compound
+# types are typedef'ed and only the typedef is referenced, never the tag name.
+# The default value is: NO.
+
+TYPEDEF_HIDES_STRUCT   = NO
+
+# The size of the symbol lookup cache can be set using LOOKUP_CACHE_SIZE. This
+# cache is used to resolve symbols given their name and scope. Since this can be
+# an expensive process and often the same symbol appears multiple times in the
+# code, doxygen keeps a cache of pre-resolved symbols. If the cache is too small
+# doxygen will become slower. If the cache is too large, memory is wasted. The
+# cache size is given by this formula: 2^(16+LOOKUP_CACHE_SIZE). The valid range
+# is 0..9, the default is 0, corresponding to a cache size of 2^16=65536
+# symbols. At the end of a run doxygen will report the cache usage and suggest
+# the optimal cache size from a speed point of view.
+# Minimum value: 0, maximum value: 9, default value: 0.
+
+LOOKUP_CACHE_SIZE      = 0
+
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+
+# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in
+# documentation are documented, even if no documentation was available. Private
+# class members and static file members will be hidden unless the
+# EXTRACT_PRIVATE respectively EXTRACT_STATIC tags are set to YES.
+# Note: This will also disable the warnings about undocumented members that are
+# normally produced when WARNINGS is set to YES.
+# The default value is: NO.
+
+EXTRACT_ALL            = NO
+
+# If the EXTRACT_PRIVATE tag is set to YES all private members of a class will
+# be included in the documentation.
+# The default value is: NO.
+
+EXTRACT_PRIVATE        = NO
+
+# If the EXTRACT_PACKAGE tag is set to YES all members with package or internal
+# scope will be included in the documentation.
+# The default value is: NO.
+
+EXTRACT_PACKAGE        = NO
+
+# If the EXTRACT_STATIC tag is set to YES all static members of a file will be
+# included in the documentation.
+# The default value is: NO.
+
+EXTRACT_STATIC         = NO
+
+# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs) defined
+# locally in source files will be included in the documentation. If set to NO
+# only classes defined in header files are included. Does not have any effect
+# for Java sources.
+# The default value is: YES.
+
+EXTRACT_LOCAL_CLASSES  = YES
+
+# This flag is only useful for Objective-C code. When set to YES local methods,
+# which are defined in the implementation section but not in the interface are
+# included in the documentation. If set to NO only methods in the interface are
+# included.
+# The default value is: NO.
+
+EXTRACT_LOCAL_METHODS  = NO
+
+# If this flag is set to YES, the members of anonymous namespaces will be
+# extracted and appear in the documentation as a namespace called
+# 'anonymous_namespace{file}', where file will be replaced with the base name of
+# the file that contains the anonymous namespace. By default anonymous namespace
+# are hidden.
+# The default value is: NO.
+
+EXTRACT_ANON_NSPACES   = NO
+
+# If the HIDE_UNDOC_MEMBERS tag is set to YES, doxygen will hide all
+# undocumented members inside documented classes or files. If set to NO these
+# members will be included in the various overviews, but no documentation
+# section is generated. This option has no effect if EXTRACT_ALL is enabled.
+# The default value is: NO.
+
+HIDE_UNDOC_MEMBERS     = NO
+
+# If the HIDE_UNDOC_CLASSES tag is set to YES, doxygen will hide all
+# undocumented classes that are normally visible in the class hierarchy. If set
+# to NO these classes will be included in the various overviews. This option has
+# no effect if EXTRACT_ALL is enabled.
+# The default value is: NO.
+
+HIDE_UNDOC_CLASSES     = NO
+
+# If the HIDE_FRIEND_COMPOUNDS tag is set to YES, doxygen will hide all friend
+# (class|struct|union) declarations. If set to NO these declarations will be
+# included in the documentation.
+# The default value is: NO.
+
+HIDE_FRIEND_COMPOUNDS  = NO
+
+# If the HIDE_IN_BODY_DOCS tag is set to YES, doxygen will hide any
+# documentation blocks found inside the body of a function. If set to NO these
+# blocks will be appended to the function's detailed documentation block.
+# The default value is: NO.
+
+HIDE_IN_BODY_DOCS      = NO
+
+# The INTERNAL_DOCS tag determines if documentation that is typed after a
+# \internal command is included. If the tag is set to NO then the documentation
+# will be excluded. Set it to YES to include the internal documentation.
+# The default value is: NO.
+
+INTERNAL_DOCS          = NO
+
+# If the CASE_SENSE_NAMES tag is set to NO then doxygen will only generate file
+# names in lower-case letters. If set to YES upper-case letters are also
+# allowed. This is useful if you have classes or files whose names only differ
+# in case and if your file system supports case sensitive file names. Windows
+# and Mac users are advised to set this option to NO.
+# The default value is: system dependent.
+
+CASE_SENSE_NAMES       = NO
+
+# If the HIDE_SCOPE_NAMES tag is set to NO then doxygen will show members with
+# their full class and namespace scopes in the documentation. If set to YES the
+# scope will be hidden.
+# The default value is: NO.
+
+HIDE_SCOPE_NAMES       = NO
+
+# If the SHOW_INCLUDE_FILES tag is set to YES then doxygen will put a list of
+# the files that are included by a file in the documentation of that file.
+# The default value is: YES.
+
+SHOW_INCLUDE_FILES     = YES
+
+# If the FORCE_LOCAL_INCLUDES tag is set to YES then doxygen will list include
+# files with double quotes in the documentation rather than with sharp brackets.
+# The default value is: NO.
+
+FORCE_LOCAL_INCLUDES   = NO
+
+# If the INLINE_INFO tag is set to YES then a tag [inline] is inserted in the
+# documentation for inline members.
+# The default value is: YES.
+
+INLINE_INFO            = YES
+
+# If the SORT_MEMBER_DOCS tag is set to YES then doxygen will sort the
+# (detailed) documentation of file and class members alphabetically by member
+# name. If set to NO the members will appear in declaration order.
+# The default value is: YES.
+
+SORT_MEMBER_DOCS       = YES
+
+# If the SORT_BRIEF_DOCS tag is set to YES then doxygen will sort the brief
+# descriptions of file, namespace and class members alphabetically by member
+# name. If set to NO the members will appear in declaration order.
+# The default value is: NO.
+
+SORT_BRIEF_DOCS        = NO
+
+# If the SORT_MEMBERS_CTORS_1ST tag is set to YES then doxygen will sort the
+# (brief and detailed) documentation of class members so that constructors and
+# destructors are listed first. If set to NO the constructors will appear in the
+# respective orders defined by SORT_BRIEF_DOCS and SORT_MEMBER_DOCS.
+# Note: If SORT_BRIEF_DOCS is set to NO this option is ignored for sorting brief
+# member documentation.
+# Note: If SORT_MEMBER_DOCS is set to NO this option is ignored for sorting
+# detailed member documentation.
+# The default value is: NO.
+
+SORT_MEMBERS_CTORS_1ST = NO
+
+# If the SORT_GROUP_NAMES tag is set to YES then doxygen will sort the hierarchy
+# of group names into alphabetical order. If set to NO the group names will
+# appear in their defined order.
+# The default value is: NO.
+
+SORT_GROUP_NAMES       = NO
+
+# If the SORT_BY_SCOPE_NAME tag is set to YES, the class list will be sorted by
+# fully-qualified names, including namespaces. If set to NO, the class list will
+# be sorted only by class name, not including the namespace part.
+# Note: This option is not very useful if HIDE_SCOPE_NAMES is set to YES.
+# Note: This option applies only to the class list, not to the alphabetical
+# list.
+# The default value is: NO.
+
+SORT_BY_SCOPE_NAME     = NO
+
+# If the STRICT_PROTO_MATCHING option is enabled and doxygen fails to do proper
+# type resolution of all parameters of a function it will reject a match between
+# the prototype and the implementation of a member function even if there is
+# only one candidate or it is obvious which candidate to choose by doing a
+# simple string match. By disabling STRICT_PROTO_MATCHING doxygen will still
+# accept a match between prototype and implementation in such cases.
+# The default value is: NO.
+
+STRICT_PROTO_MATCHING  = NO
+
+# The GENERATE_TODOLIST tag can be used to enable ( YES) or disable ( NO) the
+# todo list. This list is created by putting \todo commands in the
+# documentation.
+# The default value is: YES.
+
+GENERATE_TODOLIST      = YES
+
+# The GENERATE_TESTLIST tag can be used to enable ( YES) or disable ( NO) the
+# test list. This list is created by putting \test commands in the
+# documentation.
+# The default value is: YES.
+
+GENERATE_TESTLIST      = YES
+
+# The GENERATE_BUGLIST tag can be used to enable ( YES) or disable ( NO) the bug
+# list. This list is created by putting \bug commands in the documentation.
+# The default value is: YES.
+
+GENERATE_BUGLIST       = YES
+
+# The GENERATE_DEPRECATEDLIST tag can be used to enable ( YES) or disable ( NO)
+# the deprecated list. This list is created by putting \deprecated commands in
+# the documentation.
+# The default value is: YES.
+
+GENERATE_DEPRECATEDLIST= YES
+
+# The ENABLED_SECTIONS tag can be used to enable conditional documentation
+# sections, marked by \if <section_label> ... \endif and \cond <section_label>
+# ... \endcond blocks.
+
+ENABLED_SECTIONS       =
+
+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines that the
+# initial value of a variable or macro / define can have for it to appear in the
+# documentation. If the initializer consists of more lines than specified here
+# it will be hidden. Use a value of 0 to hide initializers completely. The
+# appearance of the value of individual variables and macros / defines can be
+# controlled using \showinitializer or \hideinitializer command in the
+# documentation regardless of this setting.
+# Minimum value: 0, maximum value: 10000, default value: 30.
+
+MAX_INITIALIZER_LINES  = 30
+
+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated at
+# the bottom of the documentation of classes and structs. If set to YES the list
+# will mention the files that were used to generate the documentation.
+# The default value is: YES.
+
+SHOW_USED_FILES        = YES
+
+# Set the SHOW_FILES tag to NO to disable the generation of the Files page. This
+# will remove the Files entry from the Quick Index and from the Folder Tree View
+# (if specified).
+# The default value is: YES.
+
+SHOW_FILES             = YES
+
+# Set the SHOW_NAMESPACES tag to NO to disable the generation of the Namespaces
+# page. This will remove the Namespaces entry from the Quick Index and from the
+# Folder Tree View (if specified).
+# The default value is: YES.
+
+SHOW_NAMESPACES        = YES
+
+# The FILE_VERSION_FILTER tag can be used to specify a program or script that
+# doxygen should invoke to get the current version for each file (typically from
+# the version control system). Doxygen will invoke the program by executing (via
+# popen()) the command command input-file, where command is the value of the
+# FILE_VERSION_FILTER tag, and input-file is the name of an input file provided
+# by doxygen. Whatever the program writes to standard output is used as the file
+# version. For an example see the documentation.
+
+FILE_VERSION_FILTER    =
+
+# The LAYOUT_FILE tag can be used to specify a layout file which will be parsed
+# by doxygen. The layout file controls the global structure of the generated
+# output files in an output format independent way. To create the layout file
+# that represents doxygen's defaults, run doxygen with the -l option. You can
+# optionally specify a file name after the option, if omitted DoxygenLayout.xml
+# will be used as the name of the layout file.
+#
+# Note that if you run doxygen from a directory containing a file called
+# DoxygenLayout.xml, doxygen will parse it automatically even if the LAYOUT_FILE
+# tag is left empty.
+
+LAYOUT_FILE            =
+
+# The CITE_BIB_FILES tag can be used to specify one or more bib files containing
+# the reference definitions. This must be a list of .bib files. The .bib
+# extension is automatically appended if omitted. This requires the bibtex tool
+# to be installed. See also http://en.wikipedia.org/wiki/BibTeX for more info.
+# For LaTeX the style of the bibliography can be controlled using
+# LATEX_BIB_STYLE. To use this feature you need bibtex and perl available in the
+# search path. Do not use file names with spaces, bibtex cannot handle them. See
+# also \cite for info how to create references.
+
+CITE_BIB_FILES         =
+
+#---------------------------------------------------------------------------
+# Configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+
+# The QUIET tag can be used to turn on/off the messages that are generated to
+# standard output by doxygen. If QUIET is set to YES this implies that the
+# messages are off.
+# The default value is: NO.
+
+QUIET                  = NO
+
+# The WARNINGS tag can be used to turn on/off the warning messages that are
+# generated to standard error ( stderr) by doxygen. If WARNINGS is set to YES
+# this implies that the warnings are on.
+#
+# Tip: Turn warnings on while writing the documentation.
+# The default value is: YES.
+
+WARNINGS               = YES
+
+# If the WARN_IF_UNDOCUMENTED tag is set to YES, then doxygen will generate
+# warnings for undocumented members. If EXTRACT_ALL is set to YES then this flag
+# will automatically be disabled.
+# The default value is: YES.
+
+WARN_IF_UNDOCUMENTED   = YES
+
+# If the WARN_IF_DOC_ERROR tag is set to YES, doxygen will generate warnings for
+# potential errors in the documentation, such as not documenting some parameters
+# in a documented function, or documenting parameters that don't exist or using
+# markup commands wrongly.
+# The default value is: YES.
+
+WARN_IF_DOC_ERROR      = YES
+
+# This WARN_NO_PARAMDOC option can be enabled to get warnings for functions that
+# are documented, but have no documentation for their parameters or return
+# value. If set to NO doxygen will only warn about wrong or incomplete parameter
+# documentation, but not about the absence of documentation.
+# The default value is: NO.
+
+WARN_NO_PARAMDOC       = NO
+
+# The WARN_FORMAT tag determines the format of the warning messages that doxygen
+# can produce. The string should contain the $file, $line, and $text tags, which
+# will be replaced by the file and line number from which the warning originated
+# and the warning text. Optionally the format may contain $version, which will
+# be replaced by the version of the file (if it could be obtained via
+# FILE_VERSION_FILTER)
+# The default value is: $file:$line: $text.
+
+WARN_FORMAT            = "$file:$line: $text"
+
+# The WARN_LOGFILE tag can be used to specify a file to which warning and error
+# messages should be written. If left blank the output is written to standard
+# error (stderr).
+
+WARN_LOGFILE           =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the input files
+#---------------------------------------------------------------------------
+
+# The INPUT tag is used to specify the files and/or directories that contain
+# documented source files. You may enter file names like myfile.cpp or
+# directories like /usr/src/myproject. Separate the files or directories with
+# spaces.
+# Note: If this tag is empty the current directory is searched.
+
+INPUT                  = .
+
+# This tag can be used to specify the character encoding of the source files
+# that doxygen parses. Internally doxygen uses the UTF-8 encoding. Doxygen uses
+# libiconv (or the iconv built into libc) for the transcoding. See the libiconv
+# documentation (see: http://www.gnu.org/software/libiconv) for the list of
+# possible encodings.
+# The default value is: UTF-8.
+
+INPUT_ENCODING         = UTF-8
+
+# If the value of the INPUT tag contains directories, you can use the
+# FILE_PATTERNS tag to specify one or more wildcard patterns (like *.cpp and
+# *.h) to filter out the source-files in the directories. If left blank the
+# following patterns are tested:*.c, *.cc, *.cxx, *.cpp, *.c++, *.java, *.ii,
+# *.ixx, *.ipp, *.i++, *.inl, *.idl, *.ddl, *.odl, *.h, *.hh, *.hxx, *.hpp,
+# *.h++, *.cs, *.d, *.php, *.php4, *.php5, *.phtml, *.inc, *.m, *.markdown,
+# *.md, *.mm, *.dox, *.py, *.f90, *.f, *.for, *.tcl, *.vhd, *.vhdl, *.ucf,
+# *.qsf, *.as and *.js.
+
+FILE_PATTERNS          =
+
+# The RECURSIVE tag can be used to specify whether or not subdirectories should
+# be searched for input files as well.
+# The default value is: NO.
+
+RECURSIVE              = NO
+
+# The EXCLUDE tag can be used to specify files and/or directories that should be
+# excluded from the INPUT source files. This way you can easily exclude a
+# subdirectory from a directory tree whose root is specified with the INPUT tag.
+#
+# Note that relative paths are relative to the directory from which doxygen is
+# run.
+
+EXCLUDE                = cmd_line.cc
+
+# The EXCLUDE_SYMLINKS tag can be used to select whether or not files or
+# directories that are symbolic links (a Unix file system feature) are excluded
+# from the input.
+# The default value is: NO.
+
+EXCLUDE_SYMLINKS       = NO
+
+# If the value of the INPUT tag contains directories, you can use the
+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude
+# certain files from those directories.
+#
+# Note that the wildcards are matched against the file with absolute path, so to
+# exclude all test directories for example use the pattern */test/*
+
+EXCLUDE_PATTERNS       =
+
+# The EXCLUDE_SYMBOLS tag can be used to specify one or more symbol names
+# (namespaces, classes, functions, etc.) that should be excluded from the
+# output. The symbol name can be a fully qualified name, a word, or if the
+# wildcard * is used, a substring. Examples: ANamespace, AClass,
+# AClass::ANamespace, ANamespace::*Test
+#
+# Note that the wildcards are matched against the file with absolute path, so to
+# exclude all test directories use the pattern */test/*
+
+EXCLUDE_SYMBOLS        =
+
+# The EXAMPLE_PATH tag can be used to specify one or more files or directories
+# that contain example code fragments that are included (see the \include
+# command).
+
+EXAMPLE_PATH           =
+
+# If the value of the EXAMPLE_PATH tag contains directories, you can use the
+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp and
+# *.h) to filter out the source-files in the directories. If left blank all
+# files are included.
+
+EXAMPLE_PATTERNS       =
+
+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be
+# searched for input files to be used with the \include or \dontinclude commands
+# irrespective of the value of the RECURSIVE tag.
+# The default value is: NO.
+
+EXAMPLE_RECURSIVE      = NO
+
+# The IMAGE_PATH tag can be used to specify one or more files or directories
+# that contain images that are to be included in the documentation (see the
+# \image command).
+
+IMAGE_PATH             =
+
+# The INPUT_FILTER tag can be used to specify a program that doxygen should
+# invoke to filter for each input file. Doxygen will invoke the filter program
+# by executing (via popen()) the command:
+#
+# <filter> <input-file>
+#
+# where <filter> is the value of the INPUT_FILTER tag, and <input-file> is the
+# name of an input file. Doxygen will then use the output that the filter
+# program writes to standard output. If FILTER_PATTERNS is specified, this tag
+# will be ignored.
+#
+# Note that the filter must not add or remove lines; it is applied before the
+# code is scanned, but not when the output code is generated. If lines are added
+# or removed, the anchors will not be placed correctly.
+
+INPUT_FILTER           =
+
+# The FILTER_PATTERNS tag can be used to specify filters on a per file pattern
+# basis. Doxygen will compare the file name with each pattern and apply the
+# filter if there is a match. The filters are a list of the form: pattern=filter
+# (like *.cpp=my_cpp_filter). See INPUT_FILTER for further information on how
+# filters are used. If the FILTER_PATTERNS tag is empty or if none of the
+# patterns match the file name, INPUT_FILTER is applied.
+
+FILTER_PATTERNS        =
+
+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using
+# INPUT_FILTER ) will also be used to filter the input files that are used for
+# producing the source files to browse (i.e. when SOURCE_BROWSER is set to YES).
+# The default value is: NO.
+
+FILTER_SOURCE_FILES    = NO
+
+# The FILTER_SOURCE_PATTERNS tag can be used to specify source filters per file
+# pattern. A pattern will override the setting for FILTER_PATTERN (if any) and
+# it is also possible to disable source filtering for a specific pattern using
+# *.ext= (so without naming a filter).
+# This tag requires that the tag FILTER_SOURCE_FILES is set to YES.
+
+FILTER_SOURCE_PATTERNS =
+
+# If the USE_MDFILE_AS_MAINPAGE tag refers to the name of a markdown file that
+# is part of the input, its contents will be placed on the main page
+# (index.html). This can be useful if you have a project on for instance GitHub
+# and want to reuse the introduction page also for the doxygen output.
+
+USE_MDFILE_AS_MAINPAGE =
+
+#---------------------------------------------------------------------------
+# Configuration options related to source browsing
+#---------------------------------------------------------------------------
+
+# If the SOURCE_BROWSER tag is set to YES then a list of source files will be
+# generated. Documented entities will be cross-referenced with these sources.
+#
+# Note: To get rid of all source code in the generated output, make sure that
+# also VERBATIM_HEADERS is set to NO.
+# The default value is: NO.
+
+SOURCE_BROWSER         = YES
+
+# Setting the INLINE_SOURCES tag to YES will include the body of functions,
+# classes and enums directly into the documentation.
+# The default value is: NO.
+
+INLINE_SOURCES         = NO
+
+# Setting the STRIP_CODE_COMMENTS tag to YES will instruct doxygen to hide any
+# special comment blocks from generated source code fragments. Normal C, C++ and
+# Fortran comments will always remain visible.
+# The default value is: YES.
+
+STRIP_CODE_COMMENTS    = NO
+
+# If the REFERENCED_BY_RELATION tag is set to YES then for each documented
+# function all documented functions referencing it will be listed.
+# The default value is: NO.
+
+REFERENCED_BY_RELATION = NO
+
+# If the REFERENCES_RELATION tag is set to YES then for each documented function
+# all documented entities called/used by that function will be listed.
+# The default value is: NO.
+
+REFERENCES_RELATION    = NO
+
+# If the REFERENCES_LINK_SOURCE tag is set to YES and SOURCE_BROWSER tag is set
+# to YES, then the hyperlinks from functions in REFERENCES_RELATION and
+# REFERENCED_BY_RELATION lists will link to the source code. Otherwise they will
+# link to the documentation.
+# The default value is: YES.
+
+REFERENCES_LINK_SOURCE = NO
+
+# If SOURCE_TOOLTIPS is enabled (the default) then hovering a hyperlink in the
+# source code will show a tooltip with additional information such as prototype,
+# brief description and links to the definition and documentation. Since this
+# will make the HTML file larger and loading of large files a bit slower, you
+# can opt to disable this feature.
+# The default value is: YES.
+# This tag requires that the tag SOURCE_BROWSER is set to YES.
+
+SOURCE_TOOLTIPS        = YES
+
+# If the USE_HTAGS tag is set to YES then the references to source code will
+# point to the HTML generated by the htags(1) tool instead of doxygen built-in
+# source browser. The htags tool is part of GNU's global source tagging system
+# (see http://www.gnu.org/software/global/global.html). You will need version
+# 4.8.6 or higher.
+#
+# To use it do the following:
+# - Install the latest version of global
+# - Enable SOURCE_BROWSER and USE_HTAGS in the config file
+# - Make sure the INPUT points to the root of the source tree
+# - Run doxygen as normal
+#
+# Doxygen will invoke htags (and that will in turn invoke gtags), so these
+# tools must be available from the command line (i.e. in the search path).
+#
+# The result: instead of the source browser generated by doxygen, the links to
+# source code will now point to the output of htags.
+# The default value is: NO.
+# This tag requires that the tag SOURCE_BROWSER is set to YES.
+
+USE_HTAGS              = NO
+
+# If the VERBATIM_HEADERS tag is set the YES then doxygen will generate a
+# verbatim copy of the header file for each class for which an include is
+# specified. Set to NO to disable this.
+# See also: Section \class.
+# The default value is: YES.
+
+VERBATIM_HEADERS       = YES
+
+#---------------------------------------------------------------------------
+# Configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+
+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index of all
+# compounds will be generated. Enable this if the project contains a lot of
+# classes, structs, unions or interfaces.
+# The default value is: YES.
+
+ALPHABETICAL_INDEX     = NO
+
+# The COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns in
+# which the alphabetical index list will be split.
+# Minimum value: 1, maximum value: 20, default value: 5.
+# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.
+
+COLS_IN_ALPHA_INDEX    = 5
+
+# In case all classes in a project start with a common prefix, all classes will
+# be put under the same header in the alphabetical index. The IGNORE_PREFIX tag
+# can be used to specify a prefix (or a list of prefixes) that should be ignored
+# while generating the index headers.
+# This tag requires that the tag ALPHABETICAL_INDEX is set to YES.
+
+IGNORE_PREFIX          =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the HTML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_HTML tag is set to YES doxygen will generate HTML output
+# The default value is: YES.
+
+GENERATE_HTML          = YES
+
+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: html.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_OUTPUT            = html
+
+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for each
+# generated HTML page (for example: .htm, .php, .asp).
+# The default value is: .html.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_FILE_EXTENSION    = .html
+
+# The HTML_HEADER tag can be used to specify a user-defined HTML header file for
+# each generated HTML page. If the tag is left blank doxygen will generate a
+# standard header.
+#
+# To get valid HTML the header file that includes any scripts and style sheets
+# that doxygen needs, which is dependent on the configuration options used (e.g.
+# the setting GENERATE_TREEVIEW). It is highly recommended to start with a
+# default header using
+# doxygen -w html new_header.html new_footer.html new_stylesheet.css
+# YourConfigFile
+# and then modify the file new_header.html. See also section "Doxygen usage"
+# for information on how to generate the default header that doxygen normally
+# uses.
+# Note: The header is subject to change so you typically have to regenerate the
+# default header when upgrading to a newer version of doxygen. For a description
+# of the possible markers and block names see the documentation.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_HEADER            =
+
+# The HTML_FOOTER tag can be used to specify a user-defined HTML footer for each
+# generated HTML page. If the tag is left blank doxygen will generate a standard
+# footer. See HTML_HEADER for more information on how to generate a default
+# footer and what special commands can be used inside the footer. See also
+# section "Doxygen usage" for information on how to generate the default footer
+# that doxygen normally uses.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_FOOTER            =
+
+# The HTML_STYLESHEET tag can be used to specify a user-defined cascading style
+# sheet that is used by each HTML page. It can be used to fine-tune the look of
+# the HTML output. If left blank doxygen will generate a default style sheet.
+# See also section "Doxygen usage" for information on how to generate the style
+# sheet that doxygen normally uses.
+# Note: It is recommended to use HTML_EXTRA_STYLESHEET instead of this tag, as
+# it is more robust and this tag (HTML_STYLESHEET) will in the future become
+# obsolete.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_STYLESHEET        =
+
+# The HTML_EXTRA_STYLESHEET tag can be used to specify an additional user-
+# defined cascading style sheet that is included after the standard style sheets
+# created by doxygen. Using this option one can overrule certain style aspects.
+# This is preferred over using HTML_STYLESHEET since it does not replace the
+# standard style sheet and is therefor more robust against future updates.
+# Doxygen will copy the style sheet file to the output directory. For an example
+# see the documentation.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_EXTRA_STYLESHEET  =
+
+# The HTML_EXTRA_FILES tag can be used to specify one or more extra images or
+# other source files which should be copied to the HTML output directory. Note
+# that these files will be copied to the base HTML output directory. Use the
+# $relpath^ marker in the HTML_HEADER and/or HTML_FOOTER files to load these
+# files. In the HTML_STYLESHEET file, use the file name only. Also note that the
+# files will be copied as-is; there are no commands or markers available.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_EXTRA_FILES       =
+
+# The HTML_COLORSTYLE_HUE tag controls the color of the HTML output. Doxygen
+# will adjust the colors in the stylesheet and background images according to
+# this color. Hue is specified as an angle on a colorwheel, see
+# http://en.wikipedia.org/wiki/Hue for more information. For instance the value
+# 0 represents red, 60 is yellow, 120 is green, 180 is cyan, 240 is blue, 300
+# purple, and 360 is red again.
+# Minimum value: 0, maximum value: 359, default value: 220.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_HUE    = 220
+
+# The HTML_COLORSTYLE_SAT tag controls the purity (or saturation) of the colors
+# in the HTML output. For a value of 0 the output will use grayscales only. A
+# value of 255 will produce the most vivid colors.
+# Minimum value: 0, maximum value: 255, default value: 100.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_SAT    = 100
+
+# The HTML_COLORSTYLE_GAMMA tag controls the gamma correction applied to the
+# luminance component of the colors in the HTML output. Values below 100
+# gradually make the output lighter, whereas values above 100 make the output
+# darker. The value divided by 100 is the actual gamma applied, so 80 represents
+# a gamma of 0.8, The value 220 represents a gamma of 2.2, and 100 does not
+# change the gamma.
+# Minimum value: 40, maximum value: 240, default value: 80.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_COLORSTYLE_GAMMA  = 80
+
+# If the HTML_TIMESTAMP tag is set to YES then the footer of each generated HTML
+# page will contain the date and time when the page was generated. Setting this
+# to NO can help when comparing the output of multiple runs.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_TIMESTAMP         = YES
+
+# If the HTML_DYNAMIC_SECTIONS tag is set to YES then the generated HTML
+# documentation will contain sections that can be hidden and shown after the
+# page has loaded.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_DYNAMIC_SECTIONS  = YES
+
+# With HTML_INDEX_NUM_ENTRIES one can control the preferred number of entries
+# shown in the various tree structured indices initially; the user can expand
+# and collapse entries dynamically later on. Doxygen will expand the tree to
+# such a level that at most the specified number of entries are visible (unless
+# a fully collapsed tree already exceeds this amount). So setting the number of
+# entries 1 will produce a full collapsed tree by default. 0 is a special value
+# representing an infinite number of entries and will result in a full expanded
+# tree by default.
+# Minimum value: 0, maximum value: 9999, default value: 100.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+HTML_INDEX_NUM_ENTRIES = 100
+
+# If the GENERATE_DOCSET tag is set to YES, additional index files will be
+# generated that can be used as input for Apple's Xcode 3 integrated development
+# environment (see: http://developer.apple.com/tools/xcode/), introduced with
+# OSX 10.5 (Leopard). To create a documentation set, doxygen will generate a
+# Makefile in the HTML output directory. Running make will produce the docset in
+# that directory and running make install will install the docset in
+# ~/Library/Developer/Shared/Documentation/DocSets so that Xcode will find it at
+# startup. See http://developer.apple.com/tools/creatingdocsetswithdoxygen.html
+# for more information.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_DOCSET        = NO
+
+# This tag determines the name of the docset feed. A documentation feed provides
+# an umbrella under which multiple documentation sets from a single provider
+# (such as a company or product suite) can be grouped.
+# The default value is: Doxygen generated docs.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_FEEDNAME        = "Doxygen generated docs"
+
+# This tag specifies a string that should uniquely identify the documentation
+# set bundle. This should be a reverse domain-name style string, e.g.
+# com.mycompany.MyDocSet. Doxygen will append .docset to the name.
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_BUNDLE_ID       = org.doxygen.Project
+
+# The DOCSET_PUBLISHER_ID tag specifies a string that should uniquely identify
+# the documentation publisher. This should be a reverse domain-name style
+# string, e.g. com.mycompany.MyDocSet.documentation.
+# The default value is: org.doxygen.Publisher.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_PUBLISHER_ID    = org.doxygen.Publisher
+
+# The DOCSET_PUBLISHER_NAME tag identifies the documentation publisher.
+# The default value is: Publisher.
+# This tag requires that the tag GENERATE_DOCSET is set to YES.
+
+DOCSET_PUBLISHER_NAME  = Publisher
+
+# If the GENERATE_HTMLHELP tag is set to YES then doxygen generates three
+# additional HTML index files: index.hhp, index.hhc, and index.hhk. The
+# index.hhp is a project file that can be read by Microsoft's HTML Help Workshop
+# (see: http://www.microsoft.com/en-us/download/details.aspx?id=21138) on
+# Windows.
+#
+# The HTML Help Workshop contains a compiler that can convert all HTML output
+# generated by doxygen into a single compiled HTML file (.chm). Compiled HTML
+# files are now used as the Windows 98 help format, and will replace the old
+# Windows help format (.hlp) on all Windows platforms in the future. Compressed
+# HTML files also contain an index, a table of contents, and you can search for
+# words in the documentation. The HTML workshop also contains a viewer for
+# compressed HTML files.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_HTMLHELP      = NO
+
+# The CHM_FILE tag can be used to specify the file name of the resulting .chm
+# file. You can add a path in front of the file if the result should not be
+# written to the html output directory.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+CHM_FILE               =
+
+# The HHC_LOCATION tag can be used to specify the location (absolute path
+# including file name) of the HTML help compiler ( hhc.exe). If non-empty
+# doxygen will try to run the HTML help compiler on the generated index.hhp.
+# The file has to be specified with full path.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+HHC_LOCATION           =
+
+# The GENERATE_CHI flag controls if a separate .chi index file is generated (
+# YES) or that it should be included in the master .chm file ( NO).
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+GENERATE_CHI           = NO
+
+# The CHM_INDEX_ENCODING is used to encode HtmlHelp index ( hhk), content ( hhc)
+# and project file content.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+CHM_INDEX_ENCODING     =
+
+# The BINARY_TOC flag controls whether a binary table of contents is generated (
+# YES) or a normal table of contents ( NO) in the .chm file.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+BINARY_TOC             = NO
+
+# The TOC_EXPAND flag can be set to YES to add extra items for group members to
+# the table of contents of the HTML help documentation and to the tree view.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTMLHELP is set to YES.
+
+TOC_EXPAND             = NO
+
+# If the GENERATE_QHP tag is set to YES and both QHP_NAMESPACE and
+# QHP_VIRTUAL_FOLDER are set, an additional index file will be generated that
+# can be used as input for Qt's qhelpgenerator to generate a Qt Compressed Help
+# (.qch) of the generated HTML documentation.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_QHP           = NO
+
+# If the QHG_LOCATION tag is specified, the QCH_FILE tag can be used to specify
+# the file name of the resulting .qch file. The path specified is relative to
+# the HTML output folder.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QCH_FILE               =
+
+# The QHP_NAMESPACE tag specifies the namespace to use when generating Qt Help
+# Project output. For more information please see Qt Help Project / Namespace
+# (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#namespace).
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_NAMESPACE          = org.doxygen.Project
+
+# The QHP_VIRTUAL_FOLDER tag specifies the namespace to use when generating Qt
+# Help Project output. For more information please see Qt Help Project / Virtual
+# Folders (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#virtual-
+# folders).
+# The default value is: doc.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_VIRTUAL_FOLDER     = doc
+
+# If the QHP_CUST_FILTER_NAME tag is set, it specifies the name of a custom
+# filter to add. For more information please see Qt Help Project / Custom
+# Filters (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#custom-
+# filters).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_CUST_FILTER_NAME   =
+
+# The QHP_CUST_FILTER_ATTRS tag specifies the list of the attributes of the
+# custom filter to add. For more information please see Qt Help Project / Custom
+# Filters (see: http://qt-project.org/doc/qt-4.8/qthelpproject.html#custom-
+# filters).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_CUST_FILTER_ATTRS  =
+
+# The QHP_SECT_FILTER_ATTRS tag specifies the list of the attributes this
+# project's filter section matches. Qt Help Project / Filter Attributes (see:
+# http://qt-project.org/doc/qt-4.8/qthelpproject.html#filter-attributes).
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHP_SECT_FILTER_ATTRS  =
+
+# The QHG_LOCATION tag can be used to specify the location of Qt's
+# qhelpgenerator. If non-empty doxygen will try to run qhelpgenerator on the
+# generated .qhp file.
+# This tag requires that the tag GENERATE_QHP is set to YES.
+
+QHG_LOCATION           =
+
+# If the GENERATE_ECLIPSEHELP tag is set to YES, additional index files will be
+# generated, together with the HTML files, they form an Eclipse help plugin. To
+# install this plugin and make it available under the help contents menu in
+# Eclipse, the contents of the directory containing the HTML and XML files needs
+# to be copied into the plugins directory of eclipse. The name of the directory
+# within the plugins directory should be the same as the ECLIPSE_DOC_ID value.
+# After copying Eclipse needs to be restarted before the help appears.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_ECLIPSEHELP   = NO
+
+# A unique identifier for the Eclipse help plugin. When installing the plugin
+# the directory name containing the HTML and XML files should also have this
+# name. Each documentation set should have its own identifier.
+# The default value is: org.doxygen.Project.
+# This tag requires that the tag GENERATE_ECLIPSEHELP is set to YES.
+
+ECLIPSE_DOC_ID         = org.doxygen.Project
+
+# If you want full control over the layout of the generated HTML pages it might
+# be necessary to disable the index and replace it with your own. The
+# DISABLE_INDEX tag can be used to turn on/off the condensed index (tabs) at top
+# of each HTML page. A value of NO enables the index and the value YES disables
+# it. Since the tabs in the index contain the same information as the navigation
+# tree, you can set this option to YES if you also set GENERATE_TREEVIEW to YES.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+DISABLE_INDEX          = NO
+
+# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
+# structure should be generated to display hierarchical information. If the tag
+# value is set to YES, a side panel will be generated containing a tree-like
+# index structure (just like the one that is generated for HTML Help). For this
+# to work a browser that supports JavaScript, DHTML, CSS and frames is required
+# (i.e. any modern browser). Windows users are probably better off using the
+# HTML help feature. Via custom stylesheets (see HTML_EXTRA_STYLESHEET) one can
+# further fine-tune the look of the index. As an example, the default style
+# sheet generated by doxygen has an example that shows how to put an image at
+# the root of the tree instead of the PROJECT_NAME. Since the tree basically has
+# the same information as the tab index, you could consider setting
+# DISABLE_INDEX to YES when enabling this option.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+GENERATE_TREEVIEW      = NO
+
+# The ENUM_VALUES_PER_LINE tag can be used to set the number of enum values that
+# doxygen will group on one line in the generated HTML documentation.
+#
+# Note that a value of 0 will completely suppress the enum values from appearing
+# in the overview section.
+# Minimum value: 0, maximum value: 20, default value: 4.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+ENUM_VALUES_PER_LINE   = 4
+
+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be used
+# to set the initial width (in pixels) of the frame in which the tree is shown.
+# Minimum value: 0, maximum value: 1500, default value: 250.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+TREEVIEW_WIDTH         = 250
+
+# When the EXT_LINKS_IN_WINDOW option is set to YES doxygen will open links to
+# external symbols imported via tag files in a separate window.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+EXT_LINKS_IN_WINDOW    = NO
+
+# Use this tag to change the font size of LaTeX formulas included as images in
+# the HTML documentation. When you change the font size after a successful
+# doxygen run you need to manually remove any form_*.png images from the HTML
+# output directory to force them to be regenerated.
+# Minimum value: 8, maximum value: 50, default value: 10.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+FORMULA_FONTSIZE       = 10
+
+# Use the FORMULA_TRANPARENT tag to determine whether or not the images
+# generated for formulas are transparent PNGs. Transparent PNGs are not
+# supported properly for IE 6.0, but are supported on all modern browsers.
+#
+# Note that when changing this option you need to delete any form_*.png files in
+# the HTML output directory before the changes have effect.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+FORMULA_TRANSPARENT    = YES
+
+# Enable the USE_MATHJAX option to render LaTeX formulas using MathJax (see
+# http://www.mathjax.org) which uses client side Javascript for the rendering
+# instead of using prerendered bitmaps. Use this if you do not have LaTeX
+# installed or if you want to formulas look prettier in the HTML output. When
+# enabled you may also need to install MathJax separately and configure the path
+# to it using the MATHJAX_RELPATH option.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+USE_MATHJAX            = NO
+
+# When MathJax is enabled you can set the default output format to be used for
+# the MathJax output. See the MathJax site (see:
+# http://docs.mathjax.org/en/latest/output.html) for more details.
+# Possible values are: HTML-CSS (which is slower, but has the best
+# compatibility), NativeMML (i.e. MathML) and SVG.
+# The default value is: HTML-CSS.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_FORMAT         = HTML-CSS
+
+# When MathJax is enabled you need to specify the location relative to the HTML
+# output directory using the MATHJAX_RELPATH option. The destination directory
+# should contain the MathJax.js script. For instance, if the mathjax directory
+# is located at the same level as the HTML output directory, then
+# MATHJAX_RELPATH should be ../mathjax. The default value points to the MathJax
+# Content Delivery Network so you can quickly see the result without installing
+# MathJax. However, it is strongly recommended to install a local copy of
+# MathJax from http://www.mathjax.org before deployment.
+# The default value is: http://cdn.mathjax.org/mathjax/latest.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_RELPATH        = http://www.mathjax.org/mathjax
+
+# The MATHJAX_EXTENSIONS tag can be used to specify one or more MathJax
+# extension names that should be enabled during MathJax rendering. For example
+# MATHJAX_EXTENSIONS = TeX/AMSmath TeX/AMSsymbols
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_EXTENSIONS     =
+
+# The MATHJAX_CODEFILE tag can be used to specify a file with javascript pieces
+# of code that will be used on startup of the MathJax code. See the MathJax site
+# (see: http://docs.mathjax.org/en/latest/output.html) for more details. For an
+# example see the documentation.
+# This tag requires that the tag USE_MATHJAX is set to YES.
+
+MATHJAX_CODEFILE       =
+
+# When the SEARCHENGINE tag is enabled doxygen will generate a search box for
+# the HTML output. The underlying search engine uses javascript and DHTML and
+# should work on any modern browser. Note that when using HTML help
+# (GENERATE_HTMLHELP), Qt help (GENERATE_QHP), or docsets (GENERATE_DOCSET)
+# there is already a search function so this one should typically be disabled.
+# For large projects the javascript based search engine can be slow, then
+# enabling SERVER_BASED_SEARCH may provide a better solution. It is possible to
+# search using the keyboard; to jump to the search box use <access key> + S
+# (what the <access key> is depends on the OS and browser, but it is typically
+# <CTRL>, <ALT>/<option>, or both). Inside the search box use the <cursor down
+# key> to jump into the search results window, the results can be navigated
+# using the <cursor keys>. Press <Enter> to select an item or <escape> to cancel
+# the search. The filter options can be selected when the cursor is inside the
+# search box by pressing <Shift>+<cursor down>. Also here use the <cursor keys>
+# to select a filter and <Enter> or <escape> to activate or cancel the filter
+# option.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_HTML is set to YES.
+
+SEARCHENGINE           = NO
+
+# When the SERVER_BASED_SEARCH tag is enabled the search engine will be
+# implemented using a web server instead of a web client using Javascript. There
+# are two flavours of web server based searching depending on the
+# EXTERNAL_SEARCH setting. When disabled, doxygen will generate a PHP script for
+# searching and an index file used by the script. When EXTERNAL_SEARCH is
+# enabled the indexing and searching needs to be provided by external tools. See
+# the section "External Indexing and Searching" for details.
+# The default value is: NO.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SERVER_BASED_SEARCH    = NO
+
+# When EXTERNAL_SEARCH tag is enabled doxygen will no longer generate the PHP
+# script for searching. Instead the search results are written to an XML file
+# which needs to be processed by an external indexer. Doxygen will invoke an
+# external search engine pointed to by the SEARCHENGINE_URL option to obtain the
+# search results.
+#
+# Doxygen ships with an example indexer ( doxyindexer) and search engine
+# (doxysearch.cgi) which are based on the open source search engine library
+# Xapian (see: http://xapian.org/).
+#
+# See the section "External Indexing and Searching" for details.
+# The default value is: NO.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTERNAL_SEARCH        = NO
+
+# The SEARCHENGINE_URL should point to a search engine hosted by a web server
+# which will return the search results when EXTERNAL_SEARCH is enabled.
+#
+# Doxygen ships with an example indexer ( doxyindexer) and search engine
+# (doxysearch.cgi) which are based on the open source search engine library
+# Xapian (see: http://xapian.org/). See the section "External Indexing and
+# Searching" for details.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SEARCHENGINE_URL       =
+
+# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the unindexed
+# search data is written to a file for indexing by an external tool. With the
+# SEARCHDATA_FILE tag the name of this file can be specified.
+# The default file is: searchdata.xml.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+SEARCHDATA_FILE        = searchdata.xml
+
+# When SERVER_BASED_SEARCH and EXTERNAL_SEARCH are both enabled the
+# EXTERNAL_SEARCH_ID tag can be used as an identifier for the project. This is
+# useful in combination with EXTRA_SEARCH_MAPPINGS to search through multiple
+# projects and redirect the results back to the right project.
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTERNAL_SEARCH_ID     =
+
+# The EXTRA_SEARCH_MAPPINGS tag can be used to enable searching through doxygen
+# projects other than the one defined by this configuration file, but that are
+# all added to the same external search index. Each project needs to have a
+# unique id set via EXTERNAL_SEARCH_ID. The search mapping then maps the id of
+# to a relative location where the documentation can be found. The format is:
+# EXTRA_SEARCH_MAPPINGS = tagname1=loc1 tagname2=loc2 ...
+# This tag requires that the tag SEARCHENGINE is set to YES.
+
+EXTRA_SEARCH_MAPPINGS  =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_LATEX tag is set to YES doxygen will generate LaTeX output.
+# The default value is: YES.
+
+GENERATE_LATEX         = NO
+
+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: latex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_OUTPUT           = latex
+
+# The LATEX_CMD_NAME tag can be used to specify the LaTeX command name to be
+# invoked.
+#
+# Note that when enabling USE_PDFLATEX this option is only used for generating
+# bitmaps for formulas in the HTML output, but not in the Makefile that is
+# written to the output directory.
+# The default file is: latex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_CMD_NAME         = latex
+
+# The MAKEINDEX_CMD_NAME tag can be used to specify the command name to generate
+# index for LaTeX.
+# The default file is: makeindex.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+MAKEINDEX_CMD_NAME     = makeindex
+
+# If the COMPACT_LATEX tag is set to YES doxygen generates more compact LaTeX
+# documents. This may be useful for small projects and may help to save some
+# trees in general.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+COMPACT_LATEX          = YES
+
+# The PAPER_TYPE tag can be used to set the paper type that is used by the
+# printer.
+# Possible values are: a4 (210 x 297 mm), letter (8.5 x 11 inches), legal (8.5 x
+# 14 inches) and executive (7.25 x 10.5 inches).
+# The default value is: a4.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+PAPER_TYPE             = letter
+
+# The EXTRA_PACKAGES tag can be used to specify one or more LaTeX package names
+# that should be included in the LaTeX output. To get the times font for
+# instance you can specify
+# EXTRA_PACKAGES=times
+# If left blank no extra packages will be included.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+EXTRA_PACKAGES         = fullpage, \
+                         palatino
+
+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for the
+# generated LaTeX document. The header should contain everything until the first
+# chapter. If it is left blank doxygen will generate a standard header. See
+# section "Doxygen usage" for information on how to let doxygen write the
+# default header to a separate file.
+#
+# Note: Only use a user-defined header if you know what you are doing! The
+# following commands have a special meaning inside the header: $title,
+# $datetime, $date, $doxygenversion, $projectname, $projectnumber. Doxygen will
+# replace them by respectively the title of the page, the current date and time,
+# only the current date, the version number of doxygen, the project name (see
+# PROJECT_NAME), or the project number (see PROJECT_NUMBER).
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_HEADER           =
+
+# The LATEX_FOOTER tag can be used to specify a personal LaTeX footer for the
+# generated LaTeX document. The footer should contain everything after the last
+# chapter. If it is left blank doxygen will generate a standard footer.
+#
+# Note: Only use a user-defined footer if you know what you are doing!
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_FOOTER           =
+
+# The LATEX_EXTRA_FILES tag can be used to specify one or more extra images or
+# other source files which should be copied to the LATEX_OUTPUT output
+# directory. Note that the files will be copied as-is; there are no commands or
+# markers available.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_EXTRA_FILES      =
+
+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated is
+# prepared for conversion to PDF (using ps2pdf or pdflatex). The PDF file will
+# contain links (just like the HTML output) instead of page references. This
+# makes the output suitable for online browsing using a PDF viewer.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+PDF_HYPERLINKS         = YES
+
+# If the LATEX_PDFLATEX tag is set to YES, doxygen will use pdflatex to generate
+# the PDF file directly from the LaTeX files. Set this option to YES to get a
+# higher quality PDF documentation.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+USE_PDFLATEX           = YES
+
+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \batchmode
+# command to the generated LaTeX files. This will instruct LaTeX to keep running
+# if errors occur, instead of asking the user for help. This option is also used
+# when generating formulas in HTML.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_BATCHMODE        = YES
+
+# If the LATEX_HIDE_INDICES tag is set to YES then doxygen will not include the
+# index chapters (such as File Index, Compound Index, etc.) in the output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_HIDE_INDICES     = YES
+
+# If the LATEX_SOURCE_CODE tag is set to YES then doxygen will include source
+# code with syntax highlighting in the LaTeX output.
+#
+# Note that which sources are shown also depends on other settings such as
+# SOURCE_BROWSER.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_SOURCE_CODE      = NO
+
+# The LATEX_BIB_STYLE tag can be used to specify the style to use for the
+# bibliography, e.g. plainnat, or ieeetr. See
+# http://en.wikipedia.org/wiki/BibTeX and \cite for more info.
+# The default value is: plain.
+# This tag requires that the tag GENERATE_LATEX is set to YES.
+
+LATEX_BIB_STYLE        = plain
+
+#---------------------------------------------------------------------------
+# Configuration options related to the RTF output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_RTF tag is set to YES doxygen will generate RTF output. The
+# RTF output is optimized for Word 97 and may not look too pretty with other RTF
+# readers/editors.
+# The default value is: NO.
+
+GENERATE_RTF           = NO
+
+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: rtf.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_OUTPUT             = rtf
+
+# If the COMPACT_RTF tag is set to YES doxygen generates more compact RTF
+# documents. This may be useful for small projects and may help to save some
+# trees in general.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+COMPACT_RTF            = NO
+
+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated will
+# contain hyperlink fields. The RTF file will contain links (just like the HTML
+# output) instead of page references. This makes the output suitable for online
+# browsing using Word or some other Word compatible readers that support those
+# fields.
+#
+# Note: WordPad (write) and others do not support links.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_HYPERLINKS         = NO
+
+# Load stylesheet definitions from file. Syntax is similar to doxygen's config
+# file, i.e. a series of assignments. You only have to provide replacements,
+# missing definitions are set to their default value.
+#
+# See also section "Doxygen usage" for information on how to generate the
+# default style sheet that doxygen normally uses.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_STYLESHEET_FILE    =
+
+# Set optional variables used in the generation of an RTF document. Syntax is
+# similar to doxygen's config file. A template extensions file can be generated
+# using doxygen -e rtf extensionFile.
+# This tag requires that the tag GENERATE_RTF is set to YES.
+
+RTF_EXTENSIONS_FILE    =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the man page output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_MAN tag is set to YES doxygen will generate man pages for
+# classes and files.
+# The default value is: NO.
+
+GENERATE_MAN           = NO
+
+# The MAN_OUTPUT tag is used to specify where the man pages will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it. A directory man3 will be created inside the directory specified by
+# MAN_OUTPUT.
+# The default directory is: man.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_OUTPUT             = man
+
+# The MAN_EXTENSION tag determines the extension that is added to the generated
+# man pages. In case the manual section does not start with a number, the number
+# 3 is prepended. The dot (.) at the beginning of the MAN_EXTENSION tag is
+# optional.
+# The default value is: .3.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_EXTENSION          = .3
+
+# If the MAN_LINKS tag is set to YES and doxygen generates man output, then it
+# will generate one additional man file for each entity documented in the real
+# man page(s). These additional files only source the real man page, but without
+# them the man command would be unable to find the correct page.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_MAN is set to YES.
+
+MAN_LINKS              = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the XML output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_XML tag is set to YES doxygen will generate an XML file that
+# captures the structure of the code including all documentation.
+# The default value is: NO.
+
+GENERATE_XML           = NO
+
+# The XML_OUTPUT tag is used to specify where the XML pages will be put. If a
+# relative path is entered the value of OUTPUT_DIRECTORY will be put in front of
+# it.
+# The default directory is: xml.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_OUTPUT             = xml
+
+# The XML_SCHEMA tag can be used to specify a XML schema, which can be used by a
+# validating XML parser to check the syntax of the XML files.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_SCHEMA             =
+
+# The XML_DTD tag can be used to specify a XML DTD, which can be used by a
+# validating XML parser to check the syntax of the XML files.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_DTD                =
+
+# If the XML_PROGRAMLISTING tag is set to YES doxygen will dump the program
+# listings (including syntax highlighting and cross-referencing information) to
+# the XML output. Note that enabling this will significantly increase the size
+# of the XML output.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_XML is set to YES.
+
+XML_PROGRAMLISTING     = YES
+
+#---------------------------------------------------------------------------
+# Configuration options related to the DOCBOOK output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_DOCBOOK tag is set to YES doxygen will generate Docbook files
+# that can be used to generate PDF.
+# The default value is: NO.
+
+GENERATE_DOCBOOK       = NO
+
+# The DOCBOOK_OUTPUT tag is used to specify where the Docbook pages will be put.
+# If a relative path is entered the value of OUTPUT_DIRECTORY will be put in
+# front of it.
+# The default directory is: docbook.
+# This tag requires that the tag GENERATE_DOCBOOK is set to YES.
+
+DOCBOOK_OUTPUT         = docbook
+
+#---------------------------------------------------------------------------
+# Configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_AUTOGEN_DEF tag is set to YES doxygen will generate an AutoGen
+# Definitions (see http://autogen.sf.net) file that captures the structure of
+# the code including all documentation. Note that this feature is still
+# experimental and incomplete at the moment.
+# The default value is: NO.
+
+GENERATE_AUTOGEN_DEF   = NO
+
+#---------------------------------------------------------------------------
+# Configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+
+# If the GENERATE_PERLMOD tag is set to YES doxygen will generate a Perl module
+# file that captures the structure of the code including all documentation.
+#
+# Note that this feature is still experimental and incomplete at the moment.
+# The default value is: NO.
+
+GENERATE_PERLMOD       = NO
+
+# If the PERLMOD_LATEX tag is set to YES doxygen will generate the necessary
+# Makefile rules, Perl scripts and LaTeX code to be able to generate PDF and DVI
+# output from the Perl module output.
+# The default value is: NO.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_LATEX          = NO
+
+# If the PERLMOD_PRETTY tag is set to YES the Perl module output will be nicely
+# formatted so it can be parsed by a human reader. This is useful if you want to
+# understand what is going on. On the other hand, if this tag is set to NO the
+# size of the Perl module output will be much smaller and Perl will parse it
+# just the same.
+# The default value is: YES.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_PRETTY         = YES
+
+# The names of the make variables in the generated doxyrules.make file are
+# prefixed with the string contained in PERLMOD_MAKEVAR_PREFIX. This is useful
+# so different doxyrules.make files included by the same Makefile don't
+# overwrite each other's variables.
+# This tag requires that the tag GENERATE_PERLMOD is set to YES.
+
+PERLMOD_MAKEVAR_PREFIX =
+
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor
+#---------------------------------------------------------------------------
+
+# If the ENABLE_PREPROCESSING tag is set to YES doxygen will evaluate all
+# C-preprocessor directives found in the sources and include files.
+# The default value is: YES.
+
+ENABLE_PREPROCESSING   = YES
+
+# If the MACRO_EXPANSION tag is set to YES doxygen will expand all macro names
+# in the source code. If set to NO only conditional compilation will be
+# performed. Macro expansion can be done in a controlled way by setting
+# EXPAND_ONLY_PREDEF to YES.
+# The default value is: NO.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+MACRO_EXPANSION        = NO
+
+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES then
+# the macro expansion is limited to the macros specified with the PREDEFINED and
+# EXPAND_AS_DEFINED tags.
+# The default value is: NO.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+EXPAND_ONLY_PREDEF     = NO
+
+# If the SEARCH_INCLUDES tag is set to YES the includes files in the
+# INCLUDE_PATH will be searched if a #include is found.
+# The default value is: YES.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+SEARCH_INCLUDES        = YES
+
+# The INCLUDE_PATH tag can be used to specify one or more directories that
+# contain include files that are not input files but should be processed by the
+# preprocessor.
+# This tag requires that the tag SEARCH_INCLUDES is set to YES.
+
+INCLUDE_PATH           =
+
+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard
+# patterns (like *.h and *.hpp) to filter out the header-files in the
+# directories. If left blank, the patterns specified with FILE_PATTERNS will be
+# used.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+INCLUDE_FILE_PATTERNS  =
+
+# The PREDEFINED tag can be used to specify one or more macro names that are
+# defined before the preprocessor is started (similar to the -D option of e.g.
+# gcc). The argument of the tag is a list of macros of the form: name or
+# name=definition (no spaces). If the definition and the "=" are omitted, "=1"
+# is assumed. To prevent a macro definition from being undefined via #undef or
+# recursively expanded use the := operator instead of the = operator.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+PREDEFINED             =
+
+# If the MACRO_EXPANSION and EXPAND_ONLY_PREDEF tags are set to YES then this
+# tag can be used to specify a list of macro names that should be expanded. The
+# macro definition that is found in the sources will be used. Use the PREDEFINED
+# tag if you want to use a different macro definition that overrules the
+# definition found in the source code.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+EXPAND_AS_DEFINED      =
+
+# If the SKIP_FUNCTION_MACROS tag is set to YES then doxygen's preprocessor will
+# remove all refrences to function-like macros that are alone on a line, have an
+# all uppercase name, and do not end with a semicolon. Such function macros are
+# typically used for boiler-plate code, and will confuse the parser if not
+# removed.
+# The default value is: YES.
+# This tag requires that the tag ENABLE_PREPROCESSING is set to YES.
+
+SKIP_FUNCTION_MACROS   = YES
+
+#---------------------------------------------------------------------------
+# Configuration options related to external references
+#---------------------------------------------------------------------------
+
+# The TAGFILES tag can be used to specify one or more tag files. For each tag
+# file the location of the external documentation should be added. The format of
+# a tag file without this location is as follows:
+# TAGFILES = file1 file2 ...
+# Adding location for the tag files is done as follows:
+# TAGFILES = file1=loc1 "file2 = loc2" ...
+# where loc1 and loc2 can be relative or absolute paths or URLs. See the
+# section "Linking to external documentation" for more information about the use
+# of tag files.
+# Note: Each tag file must have an unique name (where the name does NOT include
+# the path). If a tag file is not located in the directory in which doxygen is
+# run, you must also specify the path to the tagfile here.
+
+TAGFILES               =
+
+# When a file name is specified after GENERATE_TAGFILE, doxygen will create a
+# tag file that is based on the input files it reads. See section "Linking to
+# external documentation" for more information about the usage of tag files.
+
+GENERATE_TAGFILE       =
+
+# If the ALLEXTERNALS tag is set to YES all external class will be listed in the
+# class index. If set to NO only the inherited external classes will be listed.
+# The default value is: NO.
+
+ALLEXTERNALS           = NO
+
+# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed in
+# the modules index. If set to NO, only the current project's groups will be
+# listed.
+# The default value is: YES.
+
+EXTERNAL_GROUPS        = YES
+
+# If the EXTERNAL_PAGES tag is set to YES all external pages will be listed in
+# the related pages index. If set to NO, only the current project's pages will
+# be listed.
+# The default value is: YES.
+
+EXTERNAL_PAGES         = YES
+
+# The PERL_PATH should be the absolute path and name of the perl script
+# interpreter (i.e. the result of 'which perl').
+# The default file (with absolute path) is: /usr/bin/perl.
+
+PERL_PATH              = /usr/bin/perl
+
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool
+#---------------------------------------------------------------------------
+
+# If the CLASS_DIAGRAMS tag is set to YES doxygen will generate a class diagram
+# (in HTML and LaTeX) for classes with base or super classes. Setting the tag to
+# NO turns the diagrams off. Note that this option also works with HAVE_DOT
+# disabled, but it is recommended to install and use dot, since it yields more
+# powerful graphs.
+# The default value is: YES.
+
+CLASS_DIAGRAMS         = YES
+
+# You can define message sequence charts within doxygen comments using the \msc
+# command. Doxygen will then run the mscgen tool (see:
+# http://www.mcternan.me.uk/mscgen/)) to produce the chart and insert it in the
+# documentation. The MSCGEN_PATH tag allows you to specify the directory where
+# the mscgen tool resides. If left empty the tool is assumed to be found in the
+# default search path.
+
+MSCGEN_PATH            =
+
+# If set to YES, the inheritance and collaboration graphs will hide inheritance
+# and usage relations if the target is undocumented or is not a class.
+# The default value is: YES.
+
+HIDE_UNDOC_RELATIONS   = YES
+
+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is
+# available from the path. This tool is part of Graphviz (see:
+# http://www.graphviz.org/), a graph visualization toolkit from AT&T and Lucent
+# Bell Labs. The other options in this section have no effect if this option is
+# set to NO
+# The default value is: NO.
+
+HAVE_DOT               = NO
+
+# The DOT_NUM_THREADS specifies the number of dot invocations doxygen is allowed
+# to run in parallel. When set to 0 doxygen will base this on the number of
+# processors available in the system. You can set it explicitly to a value
+# larger than 0 to get control over the balance between CPU load and processing
+# speed.
+# Minimum value: 0, maximum value: 32, default value: 0.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_NUM_THREADS        = 0
+
+# When you want a differently looking font n the dot files that doxygen
+# generates you can specify the font name using DOT_FONTNAME. You need to make
+# sure dot is able to find the font, which can be done by putting it in a
+# standard location or by setting the DOTFONTPATH environment variable or by
+# setting DOT_FONTPATH to the directory containing the font.
+# The default value is: Helvetica.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTNAME           = FreeSans
+
+# The DOT_FONTSIZE tag can be used to set the size (in points) of the font of
+# dot graphs.
+# Minimum value: 4, maximum value: 24, default value: 10.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTSIZE           = 10
+
+# By default doxygen will tell dot to use the default font as specified with
+# DOT_FONTNAME. If you specify a different font using DOT_FONTNAME you can set
+# the path where dot can find it using this tag.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_FONTPATH           =
+
+# If the CLASS_GRAPH tag is set to YES then doxygen will generate a graph for
+# each documented class showing the direct and indirect inheritance relations.
+# Setting this tag to YES will force the CLASS_DIAGRAMS tag to NO.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CLASS_GRAPH            = YES
+
+# If the COLLABORATION_GRAPH tag is set to YES then doxygen will generate a
+# graph for each documented class showing the direct and indirect implementation
+# dependencies (inheritance, containment, and class references variables) of the
+# class with other documented classes.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+COLLABORATION_GRAPH    = YES
+
+# If the GROUP_GRAPHS tag is set to YES then doxygen will generate a graph for
+# groups, showing the direct groups dependencies.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GROUP_GRAPHS           = YES
+
+# If the UML_LOOK tag is set to YES doxygen will generate inheritance and
+# collaboration diagrams in a style similar to the OMG's Unified Modeling
+# Language.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+UML_LOOK               = NO
+
+# If the UML_LOOK tag is enabled, the fields and methods are shown inside the
+# class node. If there are many fields or methods and many nodes the graph may
+# become too big to be useful. The UML_LIMIT_NUM_FIELDS threshold limits the
+# number of items for each type to make the size more manageable. Set this to 0
+# for no limit. Note that the threshold may be exceeded by 50% before the limit
+# is enforced. So when you set the threshold to 10, up to 15 fields may appear,
+# but if the number exceeds 15, the total amount of fields shown is limited to
+# 10.
+# Minimum value: 0, maximum value: 100, default value: 10.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+UML_LIMIT_NUM_FIELDS   = 10
+
+# If the TEMPLATE_RELATIONS tag is set to YES then the inheritance and
+# collaboration graphs will show the relations between templates and their
+# instances.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+TEMPLATE_RELATIONS     = YES
+
+# If the INCLUDE_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are set to
+# YES then doxygen will generate a graph for each documented file showing the
+# direct and indirect include dependencies of the file with other documented
+# files.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INCLUDE_GRAPH          = YES
+
+# If the INCLUDED_BY_GRAPH, ENABLE_PREPROCESSING and SEARCH_INCLUDES tags are
+# set to YES then doxygen will generate a graph for each documented file showing
+# the direct and indirect include dependencies of the file with other documented
+# files.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INCLUDED_BY_GRAPH      = YES
+
+# If the CALL_GRAPH tag is set to YES then doxygen will generate a call
+# dependency graph for every global function or class method.
+#
+# Note that enabling this option will significantly increase the time of a run.
+# So in most cases it will be better to enable call graphs for selected
+# functions only using the \callgraph command.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CALL_GRAPH             = NO
+
+# If the CALLER_GRAPH tag is set to YES then doxygen will generate a caller
+# dependency graph for every global function or class method.
+#
+# Note that enabling this option will significantly increase the time of a run.
+# So in most cases it will be better to enable caller graphs for selected
+# functions only using the \callergraph command.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+CALLER_GRAPH           = NO
+
+# If the GRAPHICAL_HIERARCHY tag is set to YES then doxygen will graphical
+# hierarchy of all classes instead of a textual one.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GRAPHICAL_HIERARCHY    = YES
+
+# If the DIRECTORY_GRAPH tag is set to YES then doxygen will show the
+# dependencies a directory has on other directories in a graphical way. The
+# dependency relations are determined by the #include relations between the
+# files in the directories.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DIRECTORY_GRAPH        = YES
+
+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images
+# generated by dot.
+# Note: If you choose svg you need to set HTML_FILE_EXTENSION to xhtml in order
+# to make the SVG files visible in IE 9+ (other browsers do not have this
+# requirement).
+# Possible values are: png, jpg, gif and svg.
+# The default value is: png.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_IMAGE_FORMAT       = png
+
+# If DOT_IMAGE_FORMAT is set to svg, then this option can be set to YES to
+# enable generation of interactive SVG images that allow zooming and panning.
+#
+# Note that this requires a modern browser other than Internet Explorer. Tested
+# and working are Firefox, Chrome, Safari, and Opera.
+# Note: For IE 9+ you need to set HTML_FILE_EXTENSION to xhtml in order to make
+# the SVG files visible. Older versions of IE do not have SVG support.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+INTERACTIVE_SVG        = NO
+
+# The DOT_PATH tag can be used to specify the path where the dot tool can be
+# found. If left blank, it is assumed the dot tool can be found in the path.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_PATH               =
+
+# The DOTFILE_DIRS tag can be used to specify one or more directories that
+# contain dot files that are included in the documentation (see the \dotfile
+# command).
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOTFILE_DIRS           =
+
+# The MSCFILE_DIRS tag can be used to specify one or more directories that
+# contain msc files that are included in the documentation (see the \mscfile
+# command).
+
+MSCFILE_DIRS           =
+
+# The DOT_GRAPH_MAX_NODES tag can be used to set the maximum number of nodes
+# that will be shown in the graph. If the number of nodes in a graph becomes
+# larger than this value, doxygen will truncate the graph, which is visualized
+# by representing a node as a red box. Note that doxygen if the number of direct
+# children of the root node in a graph is already larger than
+# DOT_GRAPH_MAX_NODES then the graph will not be shown at all. Also note that
+# the size of a graph can be further restricted by MAX_DOT_GRAPH_DEPTH.
+# Minimum value: 0, maximum value: 10000, default value: 50.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_GRAPH_MAX_NODES    = 50
+
+# The MAX_DOT_GRAPH_DEPTH tag can be used to set the maximum depth of the graphs
+# generated by dot. A depth value of 3 means that only nodes reachable from the
+# root by following a path via at most 3 edges will be shown. Nodes that lay
+# further from the root node will be omitted. Note that setting this option to 1
+# or 2 may greatly reduce the computation time needed for large code bases. Also
+# note that the size of a graph can be further restricted by
+# DOT_GRAPH_MAX_NODES. Using a depth of 0 means no depth restriction.
+# Minimum value: 0, maximum value: 1000, default value: 0.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+MAX_DOT_GRAPH_DEPTH    = 0
+
+# Set the DOT_TRANSPARENT tag to YES to generate images with a transparent
+# background. This is disabled by default, because dot on Windows does not seem
+# to support this out of the box.
+#
+# Warning: Depending on the platform used, enabling this option may lead to
+# badly anti-aliased labels on the edges of a graph (i.e. they become hard to
+# read).
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_TRANSPARENT        = YES
+
+# Set the DOT_MULTI_TARGETS tag to YES allow dot to generate multiple output
+# files in one run (i.e. multiple -o and -T options on the command line). This
+# makes dot run faster, but since only newer versions of dot (>1.8.10) support
+# this, this feature is disabled by default.
+# The default value is: NO.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_MULTI_TARGETS      = NO
+
+# If the GENERATE_LEGEND tag is set to YES doxygen will generate a legend page
+# explaining the meaning of the various boxes and arrows in the dot generated
+# graphs.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+GENERATE_LEGEND        = YES
+
+# If the DOT_CLEANUP tag is set to YES doxygen will remove the intermediate dot
+# files that are used to generate the various graphs.
+# The default value is: YES.
+# This tag requires that the tag HAVE_DOT is set to YES.
+
+DOT_CLEANUP            = YES
diff -ru --new-file blender-2.76b.old/extern/voro++/src/cell.cc blender-2.76b/extern/voro++/src/cell.cc
--- blender-2.76b.old/extern/voro++/src/cell.cc	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/cell.cc	2016-01-27 19:00:53.491533303 +0300
@@ -0,0 +1,2252 @@
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \file cell.cc
+ * \brief Function implementations for the voronoicell and related classes. */
+
+#include <cmath>
+#include <cstring>
+
+#include "config.hh"
+#include "common.hh"
+#include "cell.hh"
+
+namespace voro {
+
+/** Constructs a Voronoi cell and sets up the initial memory. */
+voronoicell_base::voronoicell_base() :
+	current_vertices(init_vertices), current_vertex_order(init_vertex_order),
+	current_delete_size(init_delete_size), current_delete2_size(init_delete2_size),
+	ed(new int*[current_vertices]), nu(new int[current_vertices]),
+	pts(new double[3*current_vertices]), mem(new int[current_vertex_order]),
+	mec(new int[current_vertex_order]), mep(new int*[current_vertex_order]),
+	ds(new int[current_delete_size]), stacke(ds+current_delete_size),
+	ds2(new int[current_delete2_size]), stacke2(ds2+current_delete_size),
+	current_marginal(init_marginal), marg(new int[current_marginal]) {
+	int i;
+	for(i=0;i<3;i++) {
+		mem[i]=init_n_vertices;mec[i]=0;
+		mep[i]=new int[init_n_vertices*((i<<1)+1)];
+	}
+	mem[3]=init_3_vertices;mec[3]=0;
+	mep[3]=new int[init_3_vertices*7];
+	for(i=4;i<current_vertex_order;i++) {
+		mem[i]=init_n_vertices;mec[i]=0;
+		mep[i]=new int[init_n_vertices*((i<<1)+1)];
+	}
+}
+
+/** The voronoicell destructor deallocates all the dynamic memory. */
+voronoicell_base::~voronoicell_base() {
+	for(int i=current_vertex_order-1;i>=0;i--) if(mem[i]>0) delete [] mep[i];
+	delete [] marg;
+	delete [] ds2;delete [] ds;
+	delete [] mep;delete [] mec;
+	delete [] mem;delete [] pts;
+	delete [] nu;delete [] ed;
+}
+
+/** Ensures that enough memory is allocated prior to carrying out a copy.
+ * \param[in] vc a reference to the specialized version of the calling class.
+ * \param[in] vb a pointered to the class to be copied. */
+template<class vc_class>
+void voronoicell_base::check_memory_for_copy(vc_class &vc,voronoicell_base* vb) {
+	while(current_vertex_order<vb->current_vertex_order) add_memory_vorder(vc);
+	for(int i=0;i<current_vertex_order;i++) while(mem[i]<vb->mec[i]) add_memory(vc,i,ds2);
+	while(current_vertices<vb->p) add_memory_vertices(vc);
+}
+
+/** Copies the vertex and edge information from another class. The routine
+ * assumes that enough memory is available for the copy.
+ * \param[in] vb a pointer to the class to copy. */
+void voronoicell_base::copy(voronoicell_base* vb) {
+	int i,j;
+	p=vb->p;up=0;
+	for(i=0;i<current_vertex_order;i++) {
+		mec[i]=vb->mec[i];
+		for(j=0;j<mec[i]*(2*i+1);j++) mep[i][j]=vb->mep[i][j];
+		for(j=0;j<mec[i]*(2*i+1);j+=2*i+1) ed[mep[i][j+2*i]]=mep[i]+j;
+	}
+	for(i=0;i<p;i++) nu[i]=vb->nu[i];
+	for(i=0;i<3*p;i++) pts[i]=vb->pts[i];
+}
+
+/** Copies the information from another voronoicell class into this
+ * class, extending memory allocation if necessary.
+ * \param[in] c the class to copy. */
+void voronoicell_neighbor::operator=(voronoicell &c) {
+	voronoicell_base *vb=((voronoicell_base*) &c);
+	check_memory_for_copy(*this,vb);copy(vb);
+	int i,j;
+	for(i=0;i<c.current_vertex_order;i++) {
+		for(j=0;j<c.mec[i]*i;j++) mne[i][j]=0;
+		for(j=0;j<c.mec[i];j++) ne[c.mep[i][(2*i+1)*j+2*i]]=mne[i]+(j*i);
+	}
+}
+
+/** Copies the information from another voronoicell_neighbor class into this
+ * class, extending memory allocation if necessary.
+ * \param[in] c the class to copy. */
+void voronoicell_neighbor::operator=(voronoicell_neighbor &c) {
+	voronoicell_base *vb=((voronoicell_base*) &c);
+	check_memory_for_copy(*this,vb);copy(vb);
+	int i,j;
+	for(i=0;i<c.current_vertex_order;i++) {
+		for(j=0;j<c.mec[i]*i;j++) mne[i][j]=c.mne[i][j];
+		for(j=0;j<c.mec[i];j++) ne[c.mep[i][(2*i+1)*j+2*i]]=mne[i]+(j*i);
+	}
+}
+
+/** Translates the vertices of the Voronoi cell by a given vector.
+ * \param[in] (x,y,z) the coordinates of the vector. */
+void voronoicell_base::translate(double x,double y,double z) {
+	x*=2;y*=2;z*=2;
+	double *ptsp=pts;
+	while(ptsp<pts+3*p) {
+		*(ptsp++)=x;*(ptsp++)=y;*(ptsp++)=z;
+	}
+}
+
+/** Increases the memory storage for a particular vertex order, by increasing
+ * the size of the of the corresponding mep array. If the arrays already exist,
+ * their size is doubled; if they don't exist, then new ones of size
+ * init_n_vertices are allocated. The routine also ensures that the pointers in
+ * the ed array are updated, by making use of the back pointers. For the cases
+ * where the back pointer has been temporarily overwritten in the marginal
+ * vertex code, the auxiliary delete stack is scanned to find out how to update
+ * the ed value. If the template has been instantiated with the neighbor
+ * tracking turned on, then the routine also reallocates the corresponding mne
+ * array.
+ * \param[in] i the order of the vertex memory to be increased. */
+template<class vc_class>
+void voronoicell_base::add_memory(vc_class &vc,int i,int *stackp2) {
+	int s=(i<<1)+1;
+	if(mem[i]==0) {
+		vc.n_allocate(i,init_n_vertices);
+		mep[i]=new int[init_n_vertices*s];
+		mem[i]=init_n_vertices;
+#if VOROPP_VERBOSE >=2
+		fprintf(stderr,"Order %d vertex memory created\n",i);
+#endif
+	} else {
+		int j=0,k,*l;
+		mem[i]<<=1;
+		if(mem[i]>max_n_vertices) voro_fatal_error("Point memory allocation exceeded absolute maximum",VOROPP_MEMORY_ERROR);
+#if VOROPP_VERBOSE >=2
+		fprintf(stderr,"Order %d vertex memory scaled up to %d\n",i,mem[i]);
+#endif
+		l=new int[s*mem[i]];
+		int m=0;
+		vc.n_allocate_aux1(i);
+		while(j<s*mec[i]) {
+			k=mep[i][j+(i<<1)];
+			if(k>=0) {
+				ed[k]=l+j;
+				vc.n_set_to_aux1_offset(k,m);
+			} else {
+				int *dsp;
+				for(dsp=ds2;dsp<stackp2;dsp++) {
+					if(ed[*dsp]==mep[i]+j) {
+						ed[*dsp]=l+j;
+						vc.n_set_to_aux1_offset(*dsp,m);
+						break;
+					}
+				}
+				if(dsp==stackp2) voro_fatal_error("Couldn't relocate dangling pointer",VOROPP_INTERNAL_ERROR);
+#if VOROPP_VERBOSE >=3
+				fputs("Relocated dangling pointer",stderr);
+#endif
+			}
+			for(k=0;k<s;k++,j++) l[j]=mep[i][j];
+			for(k=0;k<i;k++,m++) vc.n_copy_to_aux1(i,m);
+		}
+		delete [] mep[i];
+		mep[i]=l;
+		vc.n_switch_to_aux1(i);
+	}
+}
+
+/** Doubles the maximum number of vertices allowed, by reallocating the ed, nu,
+ * and pts arrays. If the allocation exceeds the absolute maximum set in
+ * max_vertices, then the routine exits with a fatal error. If the template has
+ * been instantiated with the neighbor tracking turned on, then the routine
+ * also reallocates the ne array. */
+template<class vc_class>
+void voronoicell_base::add_memory_vertices(vc_class &vc) {
+	int i=(current_vertices<<1),j,**pp,*pnu;
+	if(i>max_vertices) voro_fatal_error("Vertex memory allocation exceeded absolute maximum",VOROPP_MEMORY_ERROR);
+#if VOROPP_VERBOSE >=2
+	fprintf(stderr,"Vertex memory scaled up to %d\n",i);
+#endif
+	double *ppts;
+	pp=new int*[i];
+	for(j=0;j<current_vertices;j++) pp[j]=ed[j];
+	delete [] ed;ed=pp;
+	vc.n_add_memory_vertices(i);
+	pnu=new int[i];
+	for(j=0;j<current_vertices;j++) pnu[j]=nu[j];
+	delete [] nu;nu=pnu;
+	ppts=new double[3*i];
+	for(j=0;j<3*current_vertices;j++) ppts[j]=pts[j];
+	delete [] pts;pts=ppts;
+	current_vertices=i;
+}
+
+/** Doubles the maximum allowed vertex order, by reallocating mem, mep, and mec
+ * arrays. If the allocation exceeds the absolute maximum set in
+ * max_vertex_order, then the routine causes a fatal error. If the template has
+ * been instantiated with the neighbor tracking turned on, then the routine
+ * also reallocates the mne array. */
+template<class vc_class>
+void voronoicell_base::add_memory_vorder(vc_class &vc) {
+	int i=(current_vertex_order<<1),j,*p1,**p2;
+	if(i>max_vertex_order) voro_fatal_error("Vertex order memory allocation exceeded absolute maximum",VOROPP_MEMORY_ERROR);
+#if VOROPP_VERBOSE >=2
+	fprintf(stderr,"Vertex order memory scaled up to %d\n",i);
+#endif
+	p1=new int[i];
+	for(j=0;j<current_vertex_order;j++) p1[j]=mem[j];while(j<i) p1[j++]=0;
+	delete [] mem;mem=p1;
+	p2=new int*[i];
+	for(j=0;j<current_vertex_order;j++) p2[j]=mep[j];
+	delete [] mep;mep=p2;
+	p1=new int[i];
+	for(j=0;j<current_vertex_order;j++) p1[j]=mec[j];while(j<i) p1[j++]=0;
+	delete [] mec;mec=p1;
+	vc.n_add_memory_vorder(i);
+	current_vertex_order=i;
+}
+
+/** Doubles the size allocation of the main delete stack. If the allocation
+ * exceeds the absolute maximum set in max_delete_size, then routine causes a
+ * fatal error. */
+void voronoicell_base::add_memory_ds(int *&stackp) {
+	current_delete_size<<=1;
+	if(current_delete_size>max_delete_size) voro_fatal_error("Delete stack 1 memory allocation exceeded absolute maximum",VOROPP_MEMORY_ERROR);
+#if VOROPP_VERBOSE >=2
+	fprintf(stderr,"Delete stack 1 memory scaled up to %d\n",current_delete_size);
+#endif
+	int *dsn=new int[current_delete_size],*dsnp=dsn,*dsp=ds;
+	while(dsp<stackp) *(dsnp++)=*(dsp++);
+	delete [] ds;ds=dsn;stackp=dsnp;
+	stacke=ds+current_delete_size;
+}
+
+/** Doubles the size allocation of the auxiliary delete stack. If the
+ * allocation exceeds the absolute maximum set in max_delete2_size, then the
+ * routine causes a fatal error. */
+void voronoicell_base::add_memory_ds2(int *&stackp2) {
+	current_delete2_size<<=1;
+	if(current_delete2_size>max_delete2_size) voro_fatal_error("Delete stack 2 memory allocation exceeded absolute maximum",VOROPP_MEMORY_ERROR);
+#if VOROPP_VERBOSE >=2
+	fprintf(stderr,"Delete stack 2 memory scaled up to %d\n",current_delete2_size);
+#endif
+	int *dsn=new int[current_delete2_size],*dsnp=dsn,*dsp=ds2;
+	while(dsp<stackp2) *(dsnp++)=*(dsp++);
+	delete [] ds2;ds2=dsn;stackp2=dsnp;
+	stacke2=ds2+current_delete2_size;
+}
+
+/** Initializes a Voronoi cell as a rectangular box with the given dimensions.
+ * \param[in] (xmin,xmax) the minimum and maximum x coordinates.
+ * \param[in] (ymin,ymax) the minimum and maximum y coordinates.
+ * \param[in] (zmin,zmax) the minimum and maximum z coordinates. */
+void voronoicell_base::init_base(double xmin,double xmax,double ymin,double ymax,double zmin,double zmax) {
+	for(int i=0;i<current_vertex_order;i++) mec[i]=0;up=0;
+	mec[3]=p=8;xmin*=2;xmax*=2;ymin*=2;ymax*=2;zmin*=2;zmax*=2;
+	*pts=xmin;pts[1]=ymin;pts[2]=zmin;
+	pts[3]=xmax;pts[4]=ymin;pts[5]=zmin;
+	pts[6]=xmin;pts[7]=ymax;pts[8]=zmin;
+	pts[9]=xmax;pts[10]=ymax;pts[11]=zmin;
+	pts[12]=xmin;pts[13]=ymin;pts[14]=zmax;
+	pts[15]=xmax;pts[16]=ymin;pts[17]=zmax;
+	pts[18]=xmin;pts[19]=ymax;pts[20]=zmax;
+	pts[21]=xmax;pts[22]=ymax;pts[23]=zmax;
+	int *q=mep[3];
+	*q=1;q[1]=4;q[2]=2;q[3]=2;q[4]=1;q[5]=0;q[6]=0;
+	q[7]=3;q[8]=5;q[9]=0;q[10]=2;q[11]=1;q[12]=0;q[13]=1;
+	q[14]=0;q[15]=6;q[16]=3;q[17]=2;q[18]=1;q[19]=0;q[20]=2;
+	q[21]=2;q[22]=7;q[23]=1;q[24]=2;q[25]=1;q[26]=0;q[27]=3;
+	q[28]=6;q[29]=0;q[30]=5;q[31]=2;q[32]=1;q[33]=0;q[34]=4;
+	q[35]=4;q[36]=1;q[37]=7;q[38]=2;q[39]=1;q[40]=0;q[41]=5;
+	q[42]=7;q[43]=2;q[44]=4;q[45]=2;q[46]=1;q[47]=0;q[48]=6;
+	q[49]=5;q[50]=3;q[51]=6;q[52]=2;q[53]=1;q[54]=0;q[55]=7;
+	*ed=q;ed[1]=q+7;ed[2]=q+14;ed[3]=q+21;
+	ed[4]=q+28;ed[5]=q+35;ed[6]=q+42;ed[7]=q+49;
+	*nu=nu[1]=nu[2]=nu[3]=nu[4]=nu[5]=nu[6]=nu[7]=3;
+}
+
+/** Initializes a Voronoi cell as a regular octahedron.
+ * \param[in] l The distance from the octahedron center to a vertex. Six
+ *              vertices are initialized at (-l,0,0), (l,0,0), (0,-l,0),
+ *              (0,l,0), (0,0,-l), and (0,0,l). */
+void voronoicell_base::init_octahedron_base(double l) {
+	for(int i=0;i<current_vertex_order;i++) mec[i]=0;up=0;
+	mec[4]=p=6;l*=2;
+	*pts=-l;pts[1]=0;pts[2]=0;
+	pts[3]=l;pts[4]=0;pts[5]=0;
+	pts[6]=0;pts[7]=-l;pts[8]=0;
+	pts[9]=0;pts[10]=l;pts[11]=0;
+	pts[12]=0;pts[13]=0;pts[14]=-l;
+	pts[15]=0;pts[16]=0;pts[17]=l;
+	int *q=mep[4];
+	*q=2;q[1]=5;q[2]=3;q[3]=4;q[4]=0;q[5]=0;q[6]=0;q[7]=0;q[8]=0;
+	q[9]=2;q[10]=4;q[11]=3;q[12]=5;q[13]=2;q[14]=2;q[15]=2;q[16]=2;q[17]=1;
+	q[18]=0;q[19]=4;q[20]=1;q[21]=5;q[22]=0;q[23]=3;q[24]=0;q[25]=1;q[26]=2;
+	q[27]=0;q[28]=5;q[29]=1;q[30]=4;q[31]=2;q[32]=3;q[33]=2;q[34]=1;q[35]=3;
+	q[36]=0;q[37]=3;q[38]=1;q[39]=2;q[40]=3;q[41]=3;q[42]=1;q[43]=1;q[44]=4;
+	q[45]=0;q[46]=2;q[47]=1;q[48]=3;q[49]=1;q[50]=3;q[51]=3;q[52]=1;q[53]=5;
+	*ed=q;ed[1]=q+9;ed[2]=q+18;ed[3]=q+27;ed[4]=q+36;ed[5]=q+45;
+	*nu=nu[1]=nu[2]=nu[3]=nu[4]=nu[5]=4;
+}
+
+/** Initializes a Voronoi cell as a tetrahedron. It assumes that the normal to
+ * the face for the first three vertices points inside.
+ * \param (x0,y0,z0) a position vector for the first vertex.
+ * \param (x1,y1,z1) a position vector for the second vertex.
+ * \param (x2,y2,z2) a position vector for the third vertex.
+ * \param (x3,y3,z3) a position vector for the fourth vertex. */
+void voronoicell_base::init_tetrahedron_base(double x0,double y0,double z0,double x1,double y1,double z1,double x2,double y2,double z2,double x3,double y3,double z3) {
+	for(int i=0;i<current_vertex_order;i++) mec[i]=0;up=0;
+	mec[3]=p=4;
+	*pts=x0*2;pts[1]=y0*2;pts[2]=z0*2;
+	pts[3]=x1*2;pts[4]=y1*2;pts[5]=z1*2;
+	pts[6]=x2*2;pts[7]=y2*2;pts[8]=z2*2;
+	pts[9]=x3*2;pts[10]=y3*2;pts[11]=z3*2;
+	int *q=mep[3];
+	*q=1;q[1]=3;q[2]=2;q[3]=0;q[4]=0;q[5]=0;q[6]=0;
+	q[7]=0;q[8]=2;q[9]=3;q[10]=0;q[11]=2;q[12]=1;q[13]=1;
+	q[14]=0;q[15]=3;q[16]=1;q[17]=2;q[18]=2;q[19]=1;q[20]=2;
+	q[21]=0;q[22]=1;q[23]=2;q[24]=1;q[25]=2;q[26]=1;q[27]=3;
+	*ed=q;ed[1]=q+7;ed[2]=q+14;ed[3]=q+21;
+	*nu=nu[1]=nu[2]=nu[3]=3;
+}
+
+/** Checks that the relational table of the Voronoi cell is accurate, and
+ * prints out any errors. This algorithm is O(p), so running it every time the
+ * plane routine is called will result in a significant slowdown. */
+void voronoicell_base::check_relations() {
+	int i,j;
+	for(i=0;i<p;i++) for(j=0;j<nu[i];j++) if(ed[ed[i][j]][ed[i][nu[i]+j]]!=i)
+		printf("Relational error at point %d, edge %d.\n",i,j);
+}
+
+/** This routine checks for any two vertices that are connected by more than
+ * one edge. The plane algorithm is designed so that this should not happen, so
+ * any occurrences are most likely errors. Note that the routine is O(p), so
+ * running it every time the plane routine is called will result in a
+ * significant slowdown. */
+void voronoicell_base::check_duplicates() {
+	int i,j,k;
+	for(i=0;i<p;i++) for(j=1;j<nu[i];j++) for(k=0;k<j;k++) if(ed[i][j]==ed[i][k])
+		printf("Duplicate edges: (%d,%d) and (%d,%d) [%d]\n",i,j,i,k,ed[i][j]);
+}
+
+/** Constructs the relational table if the edges have been specified. */
+void voronoicell_base::construct_relations() {
+	int i,j,k,l;
+	for(i=0;i<p;i++) for(j=0;j<nu[i];j++) {
+		k=ed[i][j];
+		l=0;
+		while(ed[k][l]!=i) {
+			l++;
+			if(l==nu[k]) voro_fatal_error("Relation table construction failed",VOROPP_INTERNAL_ERROR);
+		}
+		ed[i][nu[i]+j]=l;
+	}
+}
+
+/** Starting from a point within the current cutting plane, this routine attempts
+ * to find an edge to a point outside the cutting plane. This prevents the plane
+ * routine from .
+ * \param[in] vc a reference to the specialized version of the calling class.
+ * \param[in,out] up */
+template<class vc_class>
+inline bool voronoicell_base::search_for_outside_edge(vc_class &vc,int &up) {
+	int i,lp,lw,*j(ds2),*stackp2(ds2);
+	double l;
+	*(stackp2++)=up;
+	while(j<stackp2) {
+		up=*(j++);
+		for(i=0;i<nu[up];i++) {
+			lp=ed[up][i];
+			lw=m_test(lp,l);
+			if(lw==-1) return true;
+			else if(lw==0) add_to_stack(vc,lp,stackp2);
+		}
+	}
+	return false;
+}
+
+/** Adds a point to the auxiliary delete stack if it is not already there.
+ * \param[in] vc a reference to the specialized version of the calling class.
+ * \param[in] lp the index of the point to add.
+ * \param[in,out] stackp2 a pointer to the end of the stack entries. */
+template<class vc_class>
+inline void voronoicell_base::add_to_stack(vc_class &vc,int lp,int *&stackp2) {
+	for(int *k(ds2);k<stackp2;k++) if(*k==lp) return;
+	if(stackp2==stacke2) add_memory_ds2(stackp2);
+	*(stackp2++)=lp;
+}
+
+/** Cuts the Voronoi cell by a particle whose center is at a separation of
+ * (x,y,z) from the cell center. The value of rsq should be initially set to
+ * \f$x^2+y^2+z^2\f$.
+ * \param[in] vc a reference to the specialized version of the calling class.
+ * \param[in] (x,y,z) the normal vector to the plane.
+ * \param[in] rsq the distance along this vector of the plane.
+ * \param[in] p_id the plane ID (for neighbor tracking only).
+ * \return False if the plane cut deleted the cell entirely, true otherwise. */
+template<class vc_class>
+bool voronoicell_base::nplane(vc_class &vc,double x,double y,double z,double rsq,int p_id) {
+	int count=0,i,j,k,lp=up,cp,qp,rp,*stackp(ds),*stackp2(ds2),*dsp;
+	int us=0,ls=0,qs,iqs,cs,uw,qw,lw;
+	int *edp,*edd;
+	double u,l,r,q;bool complicated_setup=false,new_double_edge=false,double_edge=false;
+
+	// Initialize the safe testing routine
+	n_marg=0;px=x;py=y;pz=z;prsq=rsq;
+
+	// Test approximately sqrt(n)/4 points for their proximity to the plane
+	// and keep the one which is closest
+	uw=m_test(up,u);
+
+	// Starting from an initial guess, we now move from vertex to vertex,
+	// to try and find an edge which intersects the cutting plane,
+	// or a vertex which is on the plane
+	try {
+		if(uw==1) {
+
+			// The test point is inside the cutting plane.
+			us=0;
+			do {
+				lp=ed[up][us];
+				lw=m_test(lp,l);
+				if(l<u) break;
+				us++;
+			} while (us<nu[up]);
+
+			if(us==nu[up]) {
+				return false;
+			}
+
+			ls=ed[up][nu[up]+us];
+			while(lw==1) {
+				if(++count>=p) throw true;
+				u=l;up=lp;
+				for(us=0;us<ls;us++) {
+					lp=ed[up][us];
+					lw=m_test(lp,l);
+					if(l<u) break;
+				}
+				if(us==ls) {
+					us++;
+					while(us<nu[up]) {
+						lp=ed[up][us];
+						lw=m_test(lp,l);
+						if(l<u) break;
+						us++;
+					}
+					if(us==nu[up]) {
+						return false;
+					}
+				}
+				ls=ed[up][nu[up]+us];
+			}
+
+			// If the last point in the iteration is within the
+			// plane, we need to do the complicated setup
+			// routine. Otherwise, we use the regular iteration.
+			if(lw==0) {
+				up=lp;
+				complicated_setup=true;
+			} else complicated_setup=false;
+		} else if(uw==-1) {
+			us=0;
+			do {
+				qp=ed[up][us];
+				qw=m_test(qp,q);
+				if(u<q) break;
+				us++;
+			} while (us<nu[up]);
+			if(us==nu[up]) return true;
+
+			while(qw==-1) {
+				qs=ed[up][nu[up]+us];
+				if(++count>=p) throw true;
+				u=q;up=qp;
+				for(us=0;us<qs;us++) {
+					qp=ed[up][us];
+					qw=m_test(qp,q);
+					if(u<q) break;
+				}
+				if(us==qs) {
+					us++;
+					while(us<nu[up]) {
+						qp=ed[up][us];
+						qw=m_test(qp,q);
+						if(u<q) break;
+						us++;
+					}
+					if(us==nu[up]) return true;
+				}
+			}
+			if(qw==1) {
+				lp=up;ls=us;l=u;
+				up=qp;us=ed[lp][nu[lp]+ls];u=q;
+				complicated_setup=false;
+			} else {
+				up=qp;
+				complicated_setup=true;
+			}
+		} else {
+
+			// Our original test point was on the plane, so we
+			// automatically head for the complicated setup
+			// routine
+			complicated_setup=true;
+		}
+	}
+	catch(bool except) {
+		// This routine is a fall-back, in case floating point errors
+		// cause the usual search routine to fail. In the fall-back
+		// routine, we just test every edge to find one straddling
+		// the plane.
+#if VOROPP_VERBOSE >=1
+		fputs("Bailed out of convex calculation\n",stderr);
+#endif
+		qw=1;lw=0;
+		for(qp=0;qp<p;qp++) {
+			qw=m_test(qp,q);
+			if(qw==1) {
+
+				// The point is inside the cutting space. Now
+				// see if we can find a neighbor which isn't.
+				for(us=0;us<nu[qp];us++) {
+					lp=ed[qp][us];
+					if(lp<qp) {
+						lw=m_test(lp,l);
+						if(lw!=1) break;
+					}
+				}
+				if(us<nu[qp]) {
+					up=qp;
+					if(lw==0) {
+						complicated_setup=true;
+					} else {
+						complicated_setup=false;
+						u=q;
+						ls=ed[up][nu[up]+us];
+					}
+					break;
+				}
+			} else if(qw==-1) {
+
+				// The point is outside the cutting space. See
+				// if we can find a neighbor which isn't.
+				for(ls=0;ls<nu[qp];ls++) {
+					up=ed[qp][ls];
+					if(up<qp) {
+						uw=m_test(up,u);
+						if(uw!=-1) break;
+					}
+				}
+				if(ls<nu[qp]) {
+					if(uw==0) {
+						up=qp;
+						complicated_setup=true;
+					} else {
+						complicated_setup=false;
+						lp=qp;l=q;
+						us=ed[lp][nu[lp]+ls];
+					}
+					break;
+				}
+			} else {
+
+				// The point is in the plane, so we just
+				// proceed with the complicated setup routine
+				up=qp;
+				complicated_setup=true;
+				break;
+			}
+		}
+		if(qp==p) return qw==-1?true:false;
+	}
+
+	// We're about to add the first point of the new facet. In either
+	// routine, we have to add a point, so first check there's space for
+	// it.
+	if(p==current_vertices) add_memory_vertices(vc);
+
+	if(complicated_setup) {
+
+		// We want to be strict about reaching the conclusion that the
+		// cell is entirely within the cutting plane. It's not enough
+		// to find a vertex that has edges which are all inside or on
+		// the plane. If the vertex has neighbors that are also on the
+		// plane, we should check those too.
+		if(!search_for_outside_edge(vc,up)) return false;
+
+		// The search algorithm found a point which is on the cutting
+		// plane. We leave that point in place, and create a new one at
+		// the same location.
+		pts[3*p]=pts[3*up];
+		pts[3*p+1]=pts[3*up+1];
+		pts[3*p+2]=pts[3*up+2];
+
+		// Search for a collection of edges of the test vertex which
+		// are outside of the cutting space. Begin by testing the
+		// zeroth edge.
+		i=0;
+		lp=*ed[up];
+		lw=m_test(lp,l);
+		if(lw!=-1) {
+
+			// The first edge is either inside the cutting space,
+			// or lies within the cutting plane. Test the edges
+			// sequentially until we find one that is outside.
+			rp=lw;
+			do {
+				i++;
+
+				// If we reached the last edge with no luck
+				// then all of the vertices are inside
+				// or on the plane, so the cell is completely
+				// deleted
+				if(i==nu[up]) return false;
+				lp=ed[up][i];
+				lw=m_test(lp,l);
+			} while (lw!=-1);
+			j=i+1;
+
+			// We found an edge outside the cutting space. Keep
+			// moving through these edges until we find one that's
+			// inside or on the plane.
+			while(j<nu[up]) {
+				lp=ed[up][j];
+				lw=m_test(lp,l);
+				if(lw!=-1) break;
+				j++;
+			}
+
+			// Compute the number of edges for the new vertex. In
+			// general it will be the number of outside edges
+			// found, plus two. But we need to recognize the
+			// special case when all but one edge is outside, and
+			// the remaining one is on the plane. For that case we
+			// have to reduce the edge count by one to prevent
+			// doubling up.
+			if(j==nu[up]&&i==1&&rp==0) {
+				nu[p]=nu[up];
+				double_edge=true;
+			} else nu[p]=j-i+2;
+			k=1;
+
+			// Add memory for the new vertex if needed, and
+			// initialize
+			while (nu[p]>=current_vertex_order) add_memory_vorder(vc);
+			if(mec[nu[p]]==mem[nu[p]]) add_memory(vc,nu[p],stackp2);
+			vc.n_set_pointer(p,nu[p]);
+			ed[p]=mep[nu[p]]+((nu[p]<<1)+1)*mec[nu[p]]++;
+			ed[p][nu[p]<<1]=p;
+
+			// Copy the edges of the original vertex into the new
+			// one. Delete the edges of the original vertex, and
+			// update the relational table.
+			us=cycle_down(i,up);
+			while(i<j) {
+				qp=ed[up][i];
+				qs=ed[up][nu[up]+i];
+				vc.n_copy(p,k,up,i);
+				ed[p][k]=qp;
+				ed[p][nu[p]+k]=qs;
+				ed[qp][qs]=p;
+				ed[qp][nu[qp]+qs]=k;
+				ed[up][i]=-1;
+				i++;k++;
+			}
+			qs=i==nu[up]?0:i;
+		} else {
+
+			// In this case, the zeroth edge is outside the cutting
+			// plane. Begin by searching backwards from the last
+			// edge until we find an edge which isn't outside.
+			i=nu[up]-1;
+			lp=ed[up][i];
+			lw=m_test(lp,l);
+			while(lw==-1) {
+				i--;
+
+				// If i reaches zero, then we have a point in
+				// the plane all of whose edges are outside
+				// the cutting space, so we just exit
+				if(i==0) return true;
+				lp=ed[up][i];
+				lw=m_test(lp,l);
+			}
+
+			// Now search forwards from zero
+			j=1;
+			qp=ed[up][j];
+			qw=m_test(qp,q);
+			while(qw==-1) {
+				j++;
+				qp=ed[up][j];
+				qw=m_test(qp,l);
+			}
+
+			// Compute the number of edges for the new vertex. In
+			// general it will be the number of outside edges
+			// found, plus two. But we need to recognize the
+			// special case when all but one edge is outside, and
+			// the remaining one is on the plane. For that case we
+			// have to reduce the edge count by one to prevent
+			// doubling up.
+			if(i==j&&qw==0) {
+				double_edge=true;
+				nu[p]=nu[up];
+			} else {
+				nu[p]=nu[up]-i+j+1;
+			}
+
+			// Add memory to store the vertex if it doesn't exist
+			// already
+			k=1;
+			while(nu[p]>=current_vertex_order) add_memory_vorder(vc);
+			if(mec[nu[p]]==mem[nu[p]]) add_memory(vc,nu[p],stackp2);
+
+			// Copy the edges of the original vertex into the new
+			// one. Delete the edges of the original vertex, and
+			// update the relational table.
+			vc.n_set_pointer(p,nu[p]);
+			ed[p]=mep[nu[p]]+((nu[p]<<1)+1)*mec[nu[p]]++;
+			ed[p][nu[p]<<1]=p;
+			us=i++;
+			while(i<nu[up]) {
+				qp=ed[up][i];
+				qs=ed[up][nu[up]+i];
+				vc.n_copy(p,k,up,i);
+				ed[p][k]=qp;
+				ed[p][nu[p]+k]=qs;
+				ed[qp][qs]=p;
+				ed[qp][nu[qp]+qs]=k;
+				ed[up][i]=-1;
+				i++;k++;
+			}
+			i=0;
+			while(i<j) {
+				qp=ed[up][i];
+				qs=ed[up][nu[up]+i];
+				vc.n_copy(p,k,up,i);
+				ed[p][k]=qp;
+				ed[p][nu[p]+k]=qs;
+				ed[qp][qs]=p;
+				ed[qp][nu[qp]+qs]=k;
+				ed[up][i]=-1;
+				i++;k++;
+			}
+			qs=j;
+		}
+		if(!double_edge) {
+			vc.n_copy(p,k,up,qs);
+			vc.n_set(p,0,p_id);
+		} else vc.n_copy(p,0,up,qs);
+
+		// Add this point to the auxiliary delete stack
+		if(stackp2==stacke2) add_memory_ds2(stackp2);
+		*(stackp2++)=up;
+
+		// Look at the edges on either side of the group that was
+		// detected. We're going to commence facet computation by
+		// moving along one of them. We are going to end up coming back
+		// along the other one.
+		cs=k;
+		qp=up;q=u;
+		i=ed[up][us];
+		us=ed[up][nu[up]+us];
+		up=i;
+		ed[qp][nu[qp]<<1]=-p;
+
+	} else {
+
+		// The search algorithm found an intersected edge between the
+		// points lp and up. Create a new vertex between them which
+		// lies on the cutting plane. Since u and l differ by at least
+		// the tolerance, this division should never screw up.
+		if(stackp==stacke) add_memory_ds(stackp);
+		*(stackp++)=up;
+		r=u/(u-l);l=1-r;
+		pts[3*p]=pts[3*lp]*r+pts[3*up]*l;
+		pts[3*p+1]=pts[3*lp+1]*r+pts[3*up+1]*l;
+		pts[3*p+2]=pts[3*lp+2]*r+pts[3*up+2]*l;
+
+		// This point will always have three edges. Connect one of them
+		// to lp.
+		nu[p]=3;
+		if(mec[3]==mem[3]) add_memory(vc,3,stackp2);
+		vc.n_set_pointer(p,3);
+		vc.n_set(p,0,p_id);
+		vc.n_copy(p,1,up,us);
+		vc.n_copy(p,2,lp,ls);
+		ed[p]=mep[3]+7*mec[3]++;
+		ed[p][6]=p;
+		ed[up][us]=-1;
+		ed[lp][ls]=p;
+		ed[lp][nu[lp]+ls]=1;
+		ed[p][1]=lp;
+		ed[p][nu[p]+1]=ls;
+		cs=2;
+
+		// Set the direction to move in
+		qs=cycle_up(us,up);
+		qp=up;q=u;
+	}
+
+	// When the code reaches here, we have initialized the first point, and
+	// we have a direction for moving it to construct the rest of the facet
+	cp=p;rp=p;p++;
+	while(qp!=up||qs!=us) {
+
+		// We're currently tracing round an intersected facet. Keep
+		// moving around it until we find a point or edge which
+		// intersects the plane.
+		lp=ed[qp][qs];
+		lw=m_test(lp,l);
+
+		if(lw==1) {
+
+			// The point is still in the cutting space. Just add it
+			// to the delete stack and keep moving.
+			qs=cycle_up(ed[qp][nu[qp]+qs],lp);
+			qp=lp;
+			q=l;
+			if(stackp==stacke) add_memory_ds(stackp);
+			*(stackp++)=qp;
+
+		} else if(lw==-1) {
+
+			// The point is outside of the cutting space, so we've
+			// found an intersected edge. Introduce a regular point
+			// at the point of intersection. Connect it to the
+			// point we just tested. Also connect it to the previous
+			// new point in the facet we're constructing.
+			if(p==current_vertices) add_memory_vertices(vc);
+			r=q/(q-l);l=1-r;
+			pts[3*p]=pts[3*lp]*r+pts[3*qp]*l;
+			pts[3*p+1]=pts[3*lp+1]*r+pts[3*qp+1]*l;
+			pts[3*p+2]=pts[3*lp+2]*r+pts[3*qp+2]*l;
+			nu[p]=3;
+			if(mec[3]==mem[3]) add_memory(vc,3,stackp2);
+			ls=ed[qp][qs+nu[qp]];
+			vc.n_set_pointer(p,3);
+			vc.n_set(p,0,p_id);
+			vc.n_copy(p,1,qp,qs);
+			vc.n_copy(p,2,lp,ls);
+			ed[p]=mep[3]+7*mec[3]++;
+			*ed[p]=cp;
+			ed[p][1]=lp;
+			ed[p][3]=cs;
+			ed[p][4]=ls;
+			ed[p][6]=p;
+			ed[lp][ls]=p;
+			ed[lp][nu[lp]+ls]=1;
+			ed[cp][cs]=p;
+			ed[cp][nu[cp]+cs]=0;
+			ed[qp][qs]=-1;
+			qs=cycle_up(qs,qp);
+			cp=p++;
+			cs=2;
+		} else {
+
+			// We've found a point which is on the cutting plane.
+			// We're going to introduce a new point right here, but
+			// first we need to figure out the number of edges it
+			// has.
+			if(p==current_vertices) add_memory_vertices(vc);
+
+			// If the previous vertex detected a double edge, our
+			// new vertex will have one less edge.
+			k=double_edge?0:1;
+			qs=ed[qp][nu[qp]+qs];
+			qp=lp;
+			iqs=qs;
+
+			// Start testing the edges of the current point until
+			// we find one which isn't outside the cutting space
+			do {
+				k++;
+				qs=cycle_up(qs,qp);
+				lp=ed[qp][qs];
+				lw=m_test(lp,l);
+			} while (lw==-1);
+
+			// Now we need to find out whether this marginal vertex
+			// we are on has been visited before, because if that's
+			// the case, we need to add vertices to the existing
+			// new vertex, rather than creating a fresh one. We also
+			// need to figure out whether we're in a case where we
+			// might be creating a duplicate edge.
+			j=-ed[qp][nu[qp]<<1];
+	 		if(qp==up&&qs==us) {
+
+				// If we're heading into the final part of the
+				// new facet, then we never worry about the
+				// duplicate edge calculation.
+				new_double_edge=false;
+				if(j>0) k+=nu[j];
+			} else {
+				if(j>0) {
+
+					// This vertex was visited before, so
+					// count those vertices to the ones we
+					// already have.
+					k+=nu[j];
+
+					// The only time when we might make a
+					// duplicate edge is if the point we're
+					// going to move to next is also a
+					// marginal point, so test for that
+					// first.
+					if(lw==0) {
+
+						// Now see whether this marginal point
+						// has been visited before.
+						i=-ed[lp][nu[lp]<<1];
+						if(i>0) {
+
+							// Now see if the last edge of that other
+							// marginal point actually ends up here.
+							if(ed[i][nu[i]-1]==j) {
+								new_double_edge=true;
+								k-=1;
+							} else new_double_edge=false;
+						} else {
+
+							// That marginal point hasn't been visited
+							// before, so we probably don't have to worry
+							// about duplicate edges, except in the
+							// case when that's the way into the end
+							// of the facet, because that way always creates
+							// an edge.
+							if(j==rp&&lp==up&&ed[qp][nu[qp]+qs]==us) {
+								new_double_edge=true;
+								k-=1;
+							} else new_double_edge=false;
+						}
+					} else new_double_edge=false;
+				} else {
+
+					// The vertex hasn't been visited
+					// before, but let's see if it's
+					// marginal
+					if(lw==0) {
+
+						// If it is, we need to check
+						// for the case that it's a
+						// small branch, and that we're
+						// heading right back to where
+						// we came from
+						i=-ed[lp][nu[lp]<<1];
+						if(i==cp) {
+							new_double_edge=true;
+							k-=1;
+						} else new_double_edge=false;
+					} else new_double_edge=false;
+				}
+			}
+
+			// k now holds the number of edges of the new vertex
+			// we are forming. Add memory for it if it doesn't exist
+			// already.
+			while(k>=current_vertex_order) add_memory_vorder(vc);
+			if(mec[k]==mem[k]) add_memory(vc,k,stackp2);
+
+			// Now create a new vertex with order k, or augment
+			// the existing one
+			if(j>0) {
+
+				// If we're augmenting a vertex but we don't
+				// actually need any more edges, just skip this
+				// routine to avoid memory confusion
+				if(nu[j]!=k) {
+					// Allocate memory and copy the edges
+					// of the previous instance into it
+					vc.n_set_aux1(k);
+					edp=mep[k]+((k<<1)+1)*mec[k]++;
+					i=0;
+					while(i<nu[j]) {
+						vc.n_copy_aux1(j,i);
+						edp[i]=ed[j][i];
+						edp[k+i]=ed[j][nu[j]+i];
+						i++;
+					}
+					edp[k<<1]=j;
+
+					// Remove the previous instance with
+					// fewer vertices from the memory
+					// structure
+					edd=mep[nu[j]]+((nu[j]<<1)+1)*--mec[nu[j]];
+					if(edd!=ed[j]) {
+						for(lw=0;lw<=(nu[j]<<1);lw++) ed[j][lw]=edd[lw];
+						vc.n_set_aux2_copy(j,nu[j]);
+						vc.n_copy_pointer(edd[nu[j]<<1],j);
+						ed[edd[nu[j]<<1]]=ed[j];
+					}
+					vc.n_set_to_aux1(j);
+					ed[j]=edp;
+				} else i=nu[j];
+			} else {
+
+				// Allocate a new vertex of order k
+				vc.n_set_pointer(p,k);
+				ed[p]=mep[k]+((k<<1)+1)*mec[k]++;
+				ed[p][k<<1]=p;
+				if(stackp2==stacke2) add_memory_ds2(stackp2);
+				*(stackp2++)=qp;
+				pts[3*p]=pts[3*qp];
+				pts[3*p+1]=pts[3*qp+1];
+				pts[3*p+2]=pts[3*qp+2];
+				ed[qp][nu[qp]<<1]=-p;
+				j=p++;
+				i=0;
+			}
+			nu[j]=k;
+
+			// Unless the previous case was a double edge, connect
+			// the first available edge of the new vertex to the
+			// last one in the facet
+			if(!double_edge) {
+				ed[j][i]=cp;
+				ed[j][nu[j]+i]=cs;
+				vc.n_set(j,i,p_id);
+				ed[cp][cs]=j;
+				ed[cp][nu[cp]+cs]=i;
+				i++;
+			}
+
+			// Copy in the edges of the underlying vertex,
+			// and do one less if this was a double edge
+			qs=iqs;
+			while(i<(new_double_edge?k:k-1)) {
+				qs=cycle_up(qs,qp);
+				lp=ed[qp][qs];ls=ed[qp][nu[qp]+qs];
+				vc.n_copy(j,i,qp,qs);
+				ed[j][i]=lp;
+				ed[j][nu[j]+i]=ls;
+				ed[lp][ls]=j;
+				ed[lp][nu[lp]+ls]=i;
+				ed[qp][qs]=-1;
+				i++;
+			}
+			qs=cycle_up(qs,qp);
+			cs=i;
+			cp=j;
+			vc.n_copy(j,new_double_edge?0:cs,qp,qs);
+
+			// Update the double_edge flag, to pass it
+			// to the next instance of this routine
+			double_edge=new_double_edge;
+		}
+	}
+
+	// Connect the final created vertex to the initial one
+	ed[cp][cs]=rp;
+	*ed[rp]=cp;
+	ed[cp][nu[cp]+cs]=0;
+	ed[rp][nu[rp]]=cs;
+
+	// Delete points: first, remove any duplicates
+	dsp=ds;
+	while(dsp<stackp) {
+		j=*dsp;
+		if(ed[j][nu[j]]!=-1) {
+			ed[j][nu[j]]=-1;
+			dsp++;
+		} else *dsp=*(--stackp);
+	}
+
+	// Add the points in the auxiliary delete stack,
+	// and reset their back pointers
+	for(dsp=ds2;dsp<stackp2;dsp++) {
+		j=*dsp;
+		ed[j][nu[j]<<1]=j;
+		if(ed[j][nu[j]]!=-1) {
+			ed[j][nu[j]]=-1;
+			if(stackp==stacke) add_memory_ds(stackp);
+			*(stackp++)=j;
+		}
+	}
+
+	// Scan connections and add in extras
+	for(dsp=ds;dsp<stackp;dsp++) {
+		cp=*dsp;
+		for(edp=ed[cp];edp<ed[cp]+nu[cp];edp++) {
+			qp=*edp;
+			if(qp!=-1&&ed[qp][nu[qp]]!=-1) {
+				if(stackp==stacke) {
+					int dis=stackp-dsp;
+					add_memory_ds(stackp);
+					dsp=ds+dis;
+				}
+				*(stackp++)=qp;
+				ed[qp][nu[qp]]=-1;
+			}
+		}
+	}
+	up=0;
+
+	// Delete them from the array structure
+	while(stackp>ds) {
+		--p;
+		while(ed[p][nu[p]]==-1) {
+			j=nu[p];
+			edp=ed[p];edd=(mep[j]+((j<<1)+1)*--mec[j]);
+			while(edp<ed[p]+(j<<1)+1) *(edp++)=*(edd++);
+			vc.n_set_aux2_copy(p,j);
+			vc.n_copy_pointer(ed[p][(j<<1)],p);
+			ed[ed[p][(j<<1)]]=ed[p];
+			--p;
+		}
+		up=*(--stackp);
+		if(up<p) {
+
+			// Vertex management
+			pts[3*up]=pts[3*p];
+			pts[3*up+1]=pts[3*p+1];
+			pts[3*up+2]=pts[3*p+2];
+
+			// Memory management
+			j=nu[up];
+			edp=ed[up];edd=(mep[j]+((j<<1)+1)*--mec[j]);
+			while(edp<ed[up]+(j<<1)+1) *(edp++)=*(edd++);
+			vc.n_set_aux2_copy(up,j);
+			vc.n_copy_pointer(ed[up][j<<1],up);
+			vc.n_copy_pointer(up,p);
+			ed[ed[up][j<<1]]=ed[up];
+
+			// Edge management
+			ed[up]=ed[p];
+			nu[up]=nu[p];
+			for(i=0;i<nu[up];i++) ed[ed[up][i]][ed[up][nu[up]+i]]=up;
+			ed[up][nu[up]<<1]=up;
+		} else up=p++;
+	}
+
+	// Check for any vertices of zero order
+	if(*mec>0) voro_fatal_error("Zero order vertex formed",VOROPP_INTERNAL_ERROR);
+
+	// Collapse any order 2 vertices and exit
+	return collapse_order2(vc);
+}
+
+/** During the creation of a new facet in the plane routine, it is possible
+ * that some order two vertices may arise. This routine removes them.
+ * Suppose an order two vertex joins c and d. If there's a edge between
+ * c and d already, then the order two vertex is just removed; otherwise,
+ * the order two vertex is removed and c and d are joined together directly.
+ * It is possible this process will create order two or order one vertices,
+ * and the routine is continually run until all of them are removed.
+ * \return False if the vertex removal was unsuccessful, indicative of the cell
+ *         reducing to zero volume and disappearing; true if the vertex removal
+ *         was successful. */
+template<class vc_class>
+inline bool voronoicell_base::collapse_order2(vc_class &vc) {
+	if(!collapse_order1(vc)) return false;
+	int a,b,i,j,k,l;
+	while(mec[2]>0) {
+
+		// Pick a order 2 vertex and read in its edges
+		i=--mec[2];
+		j=mep[2][5*i];k=mep[2][5*i+1];
+		if(j==k) {
+#if VOROPP_VERBOSE >=1
+			fputs("Order two vertex joins itself",stderr);
+#endif
+			return false;
+		}
+
+		// Scan the edges of j to see if joins k
+		for(l=0;l<nu[j];l++) {
+			if(ed[j][l]==k) break;
+		}
+
+		// If j doesn't already join k, join them together.
+		// Otherwise delete the connection to the current
+		// vertex from j and k.
+		a=mep[2][5*i+2];b=mep[2][5*i+3];i=mep[2][5*i+4];
+		if(l==nu[j]) {
+			ed[j][a]=k;
+			ed[k][b]=j;
+			ed[j][nu[j]+a]=b;
+			ed[k][nu[k]+b]=a;
+		} else {
+			if(!delete_connection(vc,j,a,false)) return false;
+			if(!delete_connection(vc,k,b,true)) return false;
+		}
+
+		// Compact the memory
+		--p;
+		if(up==i) up=0;
+		if(p!=i) {
+			if(up==p) up=i;
+			pts[3*i]=pts[3*p];
+			pts[3*i+1]=pts[3*p+1];
+			pts[3*i+2]=pts[3*p+2];
+			for(k=0;k<nu[p];k++) ed[ed[p][k]][ed[p][nu[p]+k]]=i;
+			vc.n_copy_pointer(i,p);
+			ed[i]=ed[p];
+			nu[i]=nu[p];
+			ed[i][nu[i]<<1]=i;
+		}
+
+		// Collapse any order 1 vertices if they were created
+		if(!collapse_order1(vc)) return false;
+	}
+	return true;
+}
+
+/** Order one vertices can potentially be created during the order two collapse
+ * routine. This routine keeps removing them until there are none left.
+ * \return False if the vertex removal was unsuccessful, indicative of the cell
+ *         having zero volume and disappearing; true if the vertex removal was
+ *         successful. */
+template<class vc_class>
+inline bool voronoicell_base::collapse_order1(vc_class &vc) {
+	int i,j,k;
+	while(mec[1]>0) {
+		up=0;
+#if VOROPP_VERBOSE >=1
+		fputs("Order one collapse\n",stderr);
+#endif
+		i=--mec[1];
+		j=mep[1][3*i];k=mep[1][3*i+1];
+		i=mep[1][3*i+2];
+		if(!delete_connection(vc,j,k,false)) return false;
+		--p;
+		if(up==i) up=0;
+		if(p!=i) {
+			if(up==p) up=i;
+			pts[3*i]=pts[3*p];
+			pts[3*i+1]=pts[3*p+1];
+			pts[3*i+2]=pts[3*p+2];
+			for(k=0;k<nu[p];k++) ed[ed[p][k]][ed[p][nu[p]+k]]=i;
+			vc.n_copy_pointer(i,p);
+			ed[i]=ed[p];
+			nu[i]=nu[p];
+			ed[i][nu[i]<<1]=i;
+		}
+	}
+	return true;
+}
+
+/** This routine deletes the kth edge of vertex j and reorganizes the memory.
+ * If the neighbor computation is enabled, we also have to supply an handedness
+ * flag to decide whether to preserve the plane on the left or right of the
+ * connection.
+ * \return False if a zero order vertex was formed, indicative of the cell
+ *         disappearing; true if the vertex removal was successful. */
+template<class vc_class>
+inline bool voronoicell_base::delete_connection(vc_class &vc,int j,int k,bool hand) {
+	int q=hand?k:cycle_up(k,j);
+	int i=nu[j]-1,l,*edp,*edd,m;
+#if VOROPP_VERBOSE >=1
+	if(i<1) {
+		fputs("Zero order vertex formed\n",stderr);
+		return false;
+	}
+#endif
+	if(mec[i]==mem[i]) add_memory(vc,i,ds2);
+	vc.n_set_aux1(i);
+	for(l=0;l<q;l++) vc.n_copy_aux1(j,l);
+	while(l<i) {
+		vc.n_copy_aux1_shift(j,l);
+		l++;
+	}
+	edp=mep[i]+((i<<1)+1)*mec[i]++;
+	edp[i<<1]=j;
+	for(l=0;l<k;l++) {
+		edp[l]=ed[j][l];
+		edp[l+i]=ed[j][l+nu[j]];
+	}
+	while(l<i) {
+		m=ed[j][l+1];
+		edp[l]=m;
+		k=ed[j][l+nu[j]+1];
+		edp[l+i]=k;
+		ed[m][nu[m]+k]--;
+		l++;
+	}
+
+	edd=mep[nu[j]]+((nu[j]<<1)+1)*--mec[nu[j]];
+	for(l=0;l<=(nu[j]<<1);l++) ed[j][l]=edd[l];
+	vc.n_set_aux2_copy(j,nu[j]);
+	vc.n_set_to_aux2(edd[nu[j]<<1]);
+	vc.n_set_to_aux1(j);
+	ed[edd[nu[j]<<1]]=edd;
+	ed[j]=edp;
+	nu[j]=i;
+	return true;
+}
+
+/** Calculates the volume of the Voronoi cell, by decomposing the cell into
+ * tetrahedra extending outward from the zeroth vertex, whose volumes are
+ * evaluated using a scalar triple product.
+ * \return A floating point number holding the calculated volume. */
+double voronoicell_base::volume() {
+	const double fe=1/48.0;
+	double vol=0;
+	int i,j,k,l,m,n;
+	double ux,uy,uz,vx,vy,vz,wx,wy,wz;
+	for(i=1;i<p;i++) {
+		ux=*pts-pts[3*i];
+		uy=pts[1]-pts[3*i+1];
+		uz=pts[2]-pts[3*i+2];
+		for(j=0;j<nu[i];j++) {
+			k=ed[i][j];
+			if(k>=0) {
+				ed[i][j]=-1-k;
+				l=cycle_up(ed[i][nu[i]+j],k);
+				vx=pts[3*k]-*pts;
+				vy=pts[3*k+1]-pts[1];
+				vz=pts[3*k+2]-pts[2];
+				m=ed[k][l];ed[k][l]=-1-m;
+				while(m!=i) {
+					n=cycle_up(ed[k][nu[k]+l],m);
+					wx=pts[3*m]-*pts;
+					wy=pts[3*m+1]-pts[1];
+					wz=pts[3*m+2]-pts[2];
+					vol+=ux*vy*wz+uy*vz*wx+uz*vx*wy-uz*vy*wx-uy*vx*wz-ux*vz*wy;
+					k=m;l=n;vx=wx;vy=wy;vz=wz;
+					m=ed[k][l];ed[k][l]=-1-m;
+				}
+			}
+		}
+	}
+	reset_edges();
+	return vol*fe;
+}
+
+/** Calculates the areas of each face of the Voronoi cell and prints the
+ * results to an output stream.
+ * \param[out] v the vector to store the results in. */
+void voronoicell_base::face_areas(std::vector<double> &v) {
+	double area;
+	v.clear();
+	int i,j,k,l,m,n;
+	double ux,uy,uz,vx,vy,vz,wx,wy,wz;
+	for(i=1;i<p;i++) for(j=0;j<nu[i];j++) {
+		k=ed[i][j];
+		if(k>=0) {
+			area=0;
+			ed[i][j]=-1-k;
+			l=cycle_up(ed[i][nu[i]+j],k);
+			m=ed[k][l];ed[k][l]=-1-m;
+			while(m!=i) {
+				n=cycle_up(ed[k][nu[k]+l],m);
+				ux=pts[3*k]-pts[3*i];
+				uy=pts[3*k+1]-pts[3*i+1];
+				uz=pts[3*k+2]-pts[3*i+2];
+				vx=pts[3*m]-pts[3*i];
+				vy=pts[3*m+1]-pts[3*i+1];
+				vz=pts[3*m+2]-pts[3*i+2];
+				wx=uy*vz-uz*vy;
+				wy=uz*vx-ux*vz;
+				wz=ux*vy-uy*vx;
+				area+=sqrt(wx*wx+wy*wy+wz*wz);
+				k=m;l=n;
+				m=ed[k][l];ed[k][l]=-1-m;
+			}
+			v.push_back(0.125*area);
+		}
+	}
+	reset_edges();
+}
+
+
+/** Calculates the total surface area of the Voronoi cell.
+ * \return The computed area. */
+double voronoicell_base::surface_area() {
+	double area=0;
+	int i,j,k,l,m,n;
+	double ux,uy,uz,vx,vy,vz,wx,wy,wz;
+	for(i=1;i<p;i++) for(j=0;j<nu[i];j++) {
+		k=ed[i][j];
+		if(k>=0) {
+			ed[i][j]=-1-k;
+			l=cycle_up(ed[i][nu[i]+j],k);
+			m=ed[k][l];ed[k][l]=-1-m;
+			while(m!=i) {
+				n=cycle_up(ed[k][nu[k]+l],m);
+				ux=pts[3*k]-pts[3*i];
+				uy=pts[3*k+1]-pts[3*i+1];
+				uz=pts[3*k+2]-pts[3*i+2];
+				vx=pts[3*m]-pts[3*i];
+				vy=pts[3*m+1]-pts[3*i+1];
+				vz=pts[3*m+2]-pts[3*i+2];
+				wx=uy*vz-uz*vy;
+				wy=uz*vx-ux*vz;
+				wz=ux*vy-uy*vx;
+				area+=sqrt(wx*wx+wy*wy+wz*wz);
+				k=m;l=n;
+				m=ed[k][l];ed[k][l]=-1-m;
+			}
+		}
+	}
+	reset_edges();
+	return 0.125*area;
+}
+
+
+/** Calculates the centroid of the Voronoi cell, by decomposing the cell into
+ * tetrahedra extending outward from the zeroth vertex.
+ * \param[out] (cx,cy,cz) references to floating point numbers in which to
+ *                        pass back the centroid vector. */
+void voronoicell_base::centroid(double &cx,double &cy,double &cz) {
+	double tvol,vol=0;cx=cy=cz=0;
+	int i,j,k,l,m,n;
+	double ux,uy,uz,vx,vy,vz,wx,wy,wz;
+	for(i=1;i<p;i++) {
+		ux=*pts-pts[3*i];
+		uy=pts[1]-pts[3*i+1];
+		uz=pts[2]-pts[3*i+2];
+		for(j=0;j<nu[i];j++) {
+			k=ed[i][j];
+			if(k>=0) {
+				ed[i][j]=-1-k;
+				l=cycle_up(ed[i][nu[i]+j],k);
+				vx=pts[3*k]-*pts;
+				vy=pts[3*k+1]-pts[1];
+				vz=pts[3*k+2]-pts[2];
+				m=ed[k][l];ed[k][l]=-1-m;
+				while(m!=i) {
+					n=cycle_up(ed[k][nu[k]+l],m);
+					wx=pts[3*m]-*pts;
+					wy=pts[3*m+1]-pts[1];
+					wz=pts[3*m+2]-pts[2];
+					tvol=ux*vy*wz+uy*vz*wx+uz*vx*wy-uz*vy*wx-uy*vx*wz-ux*vz*wy;
+					vol+=tvol;
+					cx+=(wx+vx-ux)*tvol;
+					cy+=(wy+vy-uy)*tvol;
+					cz+=(wz+vz-uz)*tvol;
+					k=m;l=n;vx=wx;vy=wy;vz=wz;
+					m=ed[k][l];ed[k][l]=-1-m;
+				}
+			}
+		}
+	}
+	reset_edges();
+	if(vol>tolerance_sq) {
+		vol=0.125/vol;
+		cx=cx*vol+0.5*(*pts);
+		cy=cy*vol+0.5*pts[1];
+		cz=cz*vol+0.5*pts[2];
+	} else cx=cy=cz=0;
+}
+
+/** Computes the maximum radius squared of a vertex from the center of the
+ * cell. It can be used to determine when enough particles have been testing an
+ * all planes that could cut the cell have been considered.
+ * \return The maximum radius squared of a vertex.*/
+double voronoicell_base::max_radius_squared() {
+	double r,s,*ptsp=pts+3,*ptse=pts+3*p;
+	r=*pts*(*pts)+pts[1]*pts[1]+pts[2]*pts[2];
+	while(ptsp<ptse) {
+		s=*ptsp*(*ptsp);ptsp++;
+		s+=*ptsp*(*ptsp);ptsp++;
+		s+=*ptsp*(*ptsp);ptsp++;
+		if(s>r) r=s;
+	}
+	return r;
+}
+
+/** Calculates the total edge distance of the Voronoi cell.
+ * \return A floating point number holding the calculated distance. */
+double voronoicell_base::total_edge_distance() {
+	int i,j,k;
+	double dis=0,dx,dy,dz;
+	for(i=0;i<p-1;i++) for(j=0;j<nu[i];j++) {
+		k=ed[i][j];
+		if(k>i) {
+			dx=pts[3*k]-pts[3*i];
+			dy=pts[3*k+1]-pts[3*i+1];
+			dz=pts[3*k+2]-pts[3*i+2];
+			dis+=sqrt(dx*dx+dy*dy+dz*dz);
+		}
+	}
+	return 0.5*dis;
+}
+
+/** Outputs the edges of the Voronoi cell in POV-Ray format to an open file
+ * stream, displacing the cell by given vector.
+ * \param[in] (x,y,z) a displacement vector to be added to the cell's position.
+ * \param[in] fp a file handle to write to. */
+void voronoicell_base::draw_pov(double x,double y,double z,FILE* fp) {
+	int i,j,k;double *ptsp=pts,*pt2;
+	char posbuf1[128],posbuf2[128];
+	for(i=0;i<p;i++,ptsp+=3) {
+		sprintf(posbuf1,"%g,%g,%g",x+*ptsp*0.5,y+ptsp[1]*0.5,z+ptsp[2]*0.5);
+		fprintf(fp,"sphere{<%s>,r}\n",posbuf1);
+		for(j=0;j<nu[i];j++) {
+			k=ed[i][j];
+			if(k<i) {
+				pt2=pts+3*k;
+				sprintf(posbuf2,"%g,%g,%g",x+*pt2*0.5,y+0.5*pt2[1],z+0.5*pt2[2]);
+				if(strcmp(posbuf1,posbuf2)!=0) fprintf(fp,"cylinder{<%s>,<%s>,r}\n",posbuf1,posbuf2);
+			}
+		}
+	}
+}
+
+/** Outputs the edges of the Voronoi cell in gnuplot format to an output stream.
+ * \param[in] (x,y,z) a displacement vector to be added to the cell's position.
+ * \param[in] fp a file handle to write to. */
+void voronoicell_base::draw_gnuplot(double x,double y,double z,FILE *fp) {
+	int i,j,k,l,m;
+	for(i=1;i<p;i++) for(j=0;j<nu[i];j++) {
+		k=ed[i][j];
+		if(k>=0) {
+			fprintf(fp,"%g %g %g\n",x+0.5*pts[3*i],y+0.5*pts[3*i+1],z+0.5*pts[3*i+2]);
+			l=i;m=j;
+			do {
+				ed[k][ed[l][nu[l]+m]]=-1-l;
+				ed[l][m]=-1-k;
+				l=k;
+				fprintf(fp,"%g %g %g\n",x+0.5*pts[3*k],y+0.5*pts[3*k+1],z+0.5*pts[3*k+2]);
+			} while (search_edge(l,m,k));
+			fputs("\n\n",fp);
+		}
+	}
+	reset_edges();
+}
+
+inline bool voronoicell_base::search_edge(int l,int &m,int &k) {
+	for(m=0;m<nu[l];m++) {
+		k=ed[l][m];
+		if(k>=0) return true;
+	}
+	return false;
+}
+
+/** Outputs the Voronoi cell in the POV mesh2 format, described in section
+ * 1.3.2.2 of the POV-Ray documentation. The mesh2 output consists of a list of
+ * vertex vectors, followed by a list of triangular faces. The routine also
+ * makes use of the optional inside_vector specification, which makes the mesh
+ * object solid, so the the POV-Ray Constructive Solid Geometry (CSG) can be
+ * applied.
+ * \param[in] (x,y,z) a displacement vector to be added to the cell's position.
+ * \param[in] fp a file handle to write to. */
+void voronoicell_base::draw_pov_mesh(double x,double y,double z,FILE *fp) {
+	int i,j,k,l,m,n;
+	double *ptsp=pts;
+	fprintf(fp,"mesh2 {\nvertex_vectors {\n%d\n",p);
+	for(i=0;i<p;i++,ptsp+=3) fprintf(fp,",<%g,%g,%g>\n",x+*ptsp*0.5,y+ptsp[1]*0.5,z+ptsp[2]*0.5);
+	fprintf(fp,"}\nface_indices {\n%d\n",(p-2)<<1);
+	for(i=1;i<p;i++) for(j=0;j<nu[i];j++) {
+		k=ed[i][j];
+		if(k>=0) {
+			ed[i][j]=-1-k;
+			l=cycle_up(ed[i][nu[i]+j],k);
+			m=ed[k][l];ed[k][l]=-1-m;
+			while(m!=i) {
+				n=cycle_up(ed[k][nu[k]+l],m);
+				fprintf(fp,",<%d,%d,%d>\n",i,k,m);
+				k=m;l=n;
+				m=ed[k][l];ed[k][l]=-1-m;
+			}
+		}
+	}
+	fputs("}\ninside_vector <0,0,1>\n}\n",fp);
+	reset_edges();
+}
+
+/** Several routines in the class that gather cell-based statistics internally
+ * track their progress by flipping edges to negative so that they know what
+ * parts of the cell have already been tested. This function resets them back
+ * to positive. When it is called, it assumes that every edge in the routine
+ * should have already been flipped to negative, and it bails out with an
+ * internal error if it encounters a positive edge. */
+inline void voronoicell_base::reset_edges() {
+	int i,j;
+	for(i=0;i<p;i++) for(j=0;j<nu[i];j++) {
+		if(ed[i][j]>=0) voro_fatal_error("Edge reset routine found a previously untested edge",VOROPP_INTERNAL_ERROR);
+		ed[i][j]=-1-ed[i][j];
+	}
+}
+
+/** Checks to see if a given vertex is inside, outside or within the test
+ * plane. If the point is far away from the test plane, the routine immediately
+ * returns whether it is inside or outside. If the routine is close the the
+ * plane and within the specified tolerance, then the special check_marginal()
+ * routine is called.
+ * \param[in] n the vertex to test.
+ * \param[out] ans the result of the scalar product used in evaluating the
+ *                 location of the point.
+ * \return -1 if the point is inside the plane, 1 if the point is outside the
+ *         plane, or 0 if the point is within the plane. */
+inline int voronoicell_base::m_test(int n,double &ans) {
+	double *pp=pts+n+(n<<1);
+	ans=*(pp++)*px;
+	ans+=*(pp++)*py;
+	ans+=*pp*pz-prsq;
+	if(ans<-tolerance2) {
+		return -1;
+	} else if(ans>tolerance2) {
+		return 1;
+	}
+	return check_marginal(n,ans);
+}
+
+/** Checks to see if a given vertex is inside, outside or within the test
+ * plane, for the case when the point has been detected to be very close to the
+ * plane. The routine ensures that the returned results are always consistent
+ * with previous tests, by keeping a table of any marginal results. The routine
+ * first sees if the vertex is in the table, and if it finds a previously
+ * computed result it uses that. Otherwise, it computes a result for this
+ * vertex and adds it the table.
+ * \param[in] n the vertex to test.
+ * \param[in] ans the result of the scalar product used in evaluating
+ *                the location of the point.
+ * \return -1 if the point is inside the plane, 1 if the point is outside the
+ *         plane, or 0 if the point is within the plane. */
+int voronoicell_base::check_marginal(int n,double &ans) {
+	int i;
+	for(i=0;i<n_marg;i+=2) if(marg[i]==n) return marg[i+1];
+	if(n_marg==current_marginal) {
+		current_marginal<<=1;
+		if(current_marginal>max_marginal)
+			voro_fatal_error("Marginal case buffer allocation exceeded absolute maximum",VOROPP_MEMORY_ERROR);
+#if VOROPP_VERBOSE >=2
+		fprintf(stderr,"Marginal cases buffer scaled up to %d\n",i);
+#endif
+		int *pmarg=new int[current_marginal];
+		for(int j=0;j<n_marg;j++) pmarg[j]=marg[j];
+		delete [] marg;
+		marg=pmarg;
+	}
+	marg[n_marg++]=n;
+	marg[n_marg++]=ans>tolerance?1:(ans<-tolerance?-1:0);
+	return marg[n_marg-1];
+}
+
+/** For each face of the Voronoi cell, this routine prints the out the normal
+ * vector of the face, and scales it to the distance from the cell center to
+ * that plane.
+ * \param[out] v the vector to store the results in. */
+void voronoicell_base::normals(std::vector<double> &v) {
+	int i,j,k;
+	v.clear();
+	for(i=1;i<p;i++) for(j=0;j<nu[i];j++) {
+		k=ed[i][j];
+		if(k>=0) normals_search(v,i,j,k);
+	}
+	reset_edges();
+}
+
+/** This inline routine is called by normals(). It attempts to construct a
+ * single normal vector that is associated with a particular face. It first
+ * traces around the face, trying to find two vectors along the face edges
+ * whose vector product is above the numerical tolerance. It then constructs
+ * the normal vector using this product. If the face is too small, and none of
+ * the vector products are large enough, the routine may return (0,0,0) as the
+ * normal vector.
+ * \param[in] v the vector to store the results in.
+ * \param[in] i the initial vertex of the face to test.
+ * \param[in] j the index of an edge of the vertex.
+ * \param[in] k the neighboring vertex of i, set to ed[i][j]. */
+inline void voronoicell_base::normals_search(std::vector<double> &v,int i,int j,int k) {
+	ed[i][j]=-1-k;
+	int l=cycle_up(ed[i][nu[i]+j],k),m;
+	double ux,uy,uz,vx,vy,vz,wx,wy,wz,wmag;
+	do {
+		m=ed[k][l];ed[k][l]=-1-m;
+		ux=pts[3*m]-pts[3*k];
+		uy=pts[3*m+1]-pts[3*k+1];
+		uz=pts[3*m+2]-pts[3*k+2];
+
+		// Test to see if the length of this edge is above the tolerance
+		if(ux*ux+uy*uy+uz*uz>tolerance_sq) {
+			while(m!=i) {
+				l=cycle_up(ed[k][nu[k]+l],m);
+				k=m;m=ed[k][l];ed[k][l]=-1-m;
+				vx=pts[3*m]-pts[3*k];
+				vy=pts[3*m+1]-pts[3*k+1];
+				vz=pts[3*m+2]-pts[3*k+2];
+
+				// Construct the vector product of this edge with
+				// the previous one
+				wx=uz*vy-uy*vz;
+				wy=ux*vz-uz*vx;
+				wz=uy*vx-ux*vy;
+				wmag=wx*wx+wy*wy+wz*wz;
+
+				// Test to see if this vector product of the
+				// two edges is above the tolerance
+				if(wmag>tolerance_sq) {
+
+					// Construct the normal vector and print it
+					wmag=1/sqrt(wmag);
+					v.push_back(wx*wmag);
+					v.push_back(wy*wmag);
+					v.push_back(wz*wmag);
+
+					// Mark all of the remaining edges of this
+					// face and exit
+					while(m!=i) {
+						l=cycle_up(ed[k][nu[k]+l],m);
+						k=m;m=ed[k][l];ed[k][l]=-1-m;
+					}
+					return;
+				}
+			}
+			v.push_back(0);
+			v.push_back(0);
+			v.push_back(0);
+			return;
+		}
+		l=cycle_up(ed[k][nu[k]+l],m);
+		k=m;
+	} while (k!=i);
+	v.push_back(0);
+	v.push_back(0);
+	v.push_back(0);
+}
+
+
+/** Returns the number of faces of a computed Voronoi cell.
+ * \return The number of faces. */
+int voronoicell_base::number_of_faces() {
+	int i,j,k,l,m,s=0;
+	for(i=1;i<p;i++) for(j=0;j<nu[i];j++) {
+		k=ed[i][j];
+		if(k>=0) {
+			s++;
+			ed[i][j]=-1-k;
+			l=cycle_up(ed[i][nu[i]+j],k);
+			do {
+				m=ed[k][l];
+				ed[k][l]=-1-m;
+				l=cycle_up(ed[k][nu[k]+l],m);
+				k=m;
+			} while (k!=i);
+
+		}
+	}
+	reset_edges();
+	return s;
+}
+
+/** Returns a vector of the vertex orders.
+ * \param[out] v the vector to store the results in. */
+void voronoicell_base::vertex_orders(std::vector<int> &v) {
+	v.resize(p);
+	for(int i=0;i<p;i++) v[i]=nu[i];
+}
+
+/** Outputs the vertex orders.
+ * \param[out] fp the file handle to write to. */
+void voronoicell_base::output_vertex_orders(FILE *fp) {
+	if(p>0) {
+		fprintf(fp,"%d",*nu);
+		for(int *nup=nu+1;nup<nu+p;nup++) fprintf(fp," %d",*nup);
+	}
+}
+
+/** Returns a vector of the vertex vectors using the local coordinate system.
+ * \param[out] v the vector to store the results in. */
+void voronoicell_base::vertices(std::vector<double> &v) {
+	v.resize(3*p);
+	double *ptsp=pts;
+	for(int i=0;i<3*p;i+=3) {
+		v[i]=*(ptsp++)*0.5;
+		v[i+1]=*(ptsp++)*0.5;
+		v[i+2]=*(ptsp++)*0.5;
+	}
+}
+
+/** Outputs the vertex vectors using the local coordinate system.
+ * \param[out] fp the file handle to write to. */
+void voronoicell_base::output_vertices(FILE *fp) {
+	if(p>0) {
+		fprintf(fp,"(%g,%g,%g)",*pts*0.5,pts[1]*0.5,pts[2]*0.5);
+		for(double *ptsp=pts+3;ptsp<pts+3*p;ptsp+=3) fprintf(fp," (%g,%g,%g)",*ptsp*0.5,ptsp[1]*0.5,ptsp[2]*0.5);
+	}
+}
+
+
+/** Returns a vector of the vertex vectors in the global coordinate system.
+ * \param[out] v the vector to store the results in.
+ * \param[in] (x,y,z) the position vector of the particle in the global
+ *                    coordinate system. */
+void voronoicell_base::vertices(double x,double y,double z,std::vector<double> &v) {
+	v.resize(3*p);
+	double *ptsp=pts;
+	for(int i=0;i<3*p;i+=3) {
+		v[i]=x+*(ptsp++)*0.5;
+		v[i+1]=y+*(ptsp++)*0.5;
+		v[i+2]=z+*(ptsp++)*0.5;
+	}
+}
+
+/** Outputs the vertex vectors using the global coordinate system.
+ * \param[out] fp the file handle to write to.
+ * \param[in] (x,y,z) the position vector of the particle in the global
+ *                    coordinate system. */
+void voronoicell_base::output_vertices(double x,double y,double z,FILE *fp) {
+	if(p>0) {
+		fprintf(fp,"(%g,%g,%g)",x+*pts*0.5,y+pts[1]*0.5,z+pts[2]*0.5);
+		for(double *ptsp=pts+3;ptsp<pts+3*p;ptsp+=3) fprintf(fp," (%g,%g,%g)",x+*ptsp*0.5,y+ptsp[1]*0.5,z+ptsp[2]*0.5);
+	}
+}
+
+/** This routine returns the perimeters of each face.
+ * \param[out] v the vector to store the results in. */
+void voronoicell_base::face_perimeters(std::vector<double> &v) {
+	v.clear();
+	int i,j,k,l,m;
+	double dx,dy,dz,perim;
+	for(i=1;i<p;i++) for(j=0;j<nu[i];j++) {
+		k=ed[i][j];
+		if(k>=0) {
+			dx=pts[3*k]-pts[3*i];
+			dy=pts[3*k+1]-pts[3*i+1];
+			dz=pts[3*k+2]-pts[3*i+2];
+			perim=sqrt(dx*dx+dy*dy+dz*dz);
+			ed[i][j]=-1-k;
+			l=cycle_up(ed[i][nu[i]+j],k);
+			do {
+				m=ed[k][l];
+				dx=pts[3*m]-pts[3*k];
+				dy=pts[3*m+1]-pts[3*k+1];
+				dz=pts[3*m+2]-pts[3*k+2];
+				perim+=sqrt(dx*dx+dy*dy+dz*dz);
+				ed[k][l]=-1-m;
+				l=cycle_up(ed[k][nu[k]+l],m);
+				k=m;
+			} while (k!=i);
+			v.push_back(0.5*perim);
+		}
+	}
+	reset_edges();
+}
+
+/** For each face, this routine outputs a bracketed sequence of numbers
+ * containing a list of all the vertices that make up that face.
+ * \param[out] v the vector to store the results in. */
+void voronoicell_base::face_vertices(std::vector<int> &v) {
+	int i,j,k,l,m,vp(0),vn;
+	v.clear();
+	for(i=1;i<p;i++) for(j=0;j<nu[i];j++) {
+		k=ed[i][j];
+		if(k>=0) {
+			v.push_back(0);
+			v.push_back(i);
+			ed[i][j]=-1-k;
+			l=cycle_up(ed[i][nu[i]+j],k);
+			do {
+				v.push_back(k);
+				m=ed[k][l];
+				ed[k][l]=-1-m;
+				l=cycle_up(ed[k][nu[k]+l],m);
+				k=m;
+			} while (k!=i);
+			vn=v.size();
+			v[vp]=vn-vp-1;
+			vp=vn;
+		}
+	}
+	reset_edges();
+}
+
+/** Outputs a list of the number of edges in each face.
+ * \param[out] v the vector to store the results in. */
+void voronoicell_base::face_orders(std::vector<int> &v) {
+	int i,j,k,l,m,q;
+	v.clear();
+	for(i=1;i<p;i++) for(j=0;j<nu[i];j++) {
+		k=ed[i][j];
+		if(k>=0) {
+			q=1;
+			ed[i][j]=-1-k;
+			l=cycle_up(ed[i][nu[i]+j],k);
+			do {
+				q++;
+				m=ed[k][l];
+				ed[k][l]=-1-m;
+				l=cycle_up(ed[k][nu[k]+l],m);
+				k=m;
+			} while (k!=i);
+			v.push_back(q);;
+		}
+	}
+	reset_edges();
+}
+
+/** Computes the number of edges that each face has and outputs a frequency
+ * table of the results.
+ * \param[out] v the vector to store the results in. */
+void voronoicell_base::face_freq_table(std::vector<int> &v) {
+	int i,j,k,l,m,q;
+	v.clear();
+	for(i=1;i<p;i++) for(j=0;j<nu[i];j++) {
+		k=ed[i][j];
+		if(k>=0) {
+			q=1;
+			ed[i][j]=-1-k;
+			l=cycle_up(ed[i][nu[i]+j],k);
+			do {
+				q++;
+				m=ed[k][l];
+				ed[k][l]=-1-m;
+				l=cycle_up(ed[k][nu[k]+l],m);
+				k=m;
+			} while (k!=i);
+			if((unsigned int) q>=v.size()) v.resize(q+1,0);
+			v[q]++;
+		}
+	}
+	reset_edges();
+}
+
+/** This routine tests to see whether the cell intersects a plane by starting
+ * from the guess point up. If up intersects, then it immediately returns true.
+ * Otherwise, it calls the plane_intersects_track() routine.
+ * \param[in] (x,y,z) the normal vector to the plane.
+ * \param[in] rsq the distance along this vector of the plane.
+ * \return False if the plane does not intersect the plane, true if it does. */
+bool voronoicell_base::plane_intersects(double x,double y,double z,double rsq) {
+	double g=x*pts[3*up]+y*pts[3*up+1]+z*pts[3*up+2];
+	if(g<rsq) return plane_intersects_track(x,y,z,rsq,g);
+	return true;
+}
+
+/** This routine tests to see if a cell intersects a plane. It first tests a
+ * random sample of approximately sqrt(p)/4 points. If any of those are
+ * intersect, then it immediately returns true. Otherwise, it takes the closest
+ * point and passes that to plane_intersect_track() routine.
+ * \param[in] (x,y,z) the normal vector to the plane.
+ * \param[in] rsq the distance along this vector of the plane.
+ * \return False if the plane does not intersect the plane, true if it does. */
+bool voronoicell_base::plane_intersects_guess(double x,double y,double z,double rsq) {
+	up=0;
+	double g=x*pts[3*up]+y*pts[3*up+1]+z*pts[3*up+2];
+	if(g<rsq) {
+		int ca=1,cc=p>>3,mp=1;
+		double m;
+		while(ca<cc) {
+			m=x*pts[3*mp]+y*pts[3*mp+1]+z*pts[3*mp+2];
+			if(m>g) {
+				if(m>rsq) return true;
+				g=m;up=mp;
+			}
+			ca+=mp++;
+		}
+		return plane_intersects_track(x,y,z,rsq,g);
+	}
+	return true;
+}
+
+/* This routine tests to see if a cell intersects a plane, by tracing over the cell from
+ * vertex to vertex, starting at up. It is meant to be called either by plane_intersects()
+ * or plane_intersects_track(), when those routines cannot immediately resolve the case.
+ * \param[in] (x,y,z) the normal vector to the plane.
+ * \param[in] rsq the distance along this vector of the plane.
+ * \param[in] g the distance of up from the plane.
+ * \return False if the plane does not intersect the plane, true if it does. */
+inline bool voronoicell_base::plane_intersects_track(double x,double y,double z,double rsq,double g) {
+	int count=0,ls,us,tp;
+	double t;
+
+	// The test point is outside of the cutting space
+	for(us=0;us<nu[up];us++) {
+		tp=ed[up][us];
+		t=x*pts[3*tp]+y*pts[3*tp+1]+z*pts[3*tp+2];
+		if(t>g) {
+			ls=ed[up][nu[up]+us];
+			up=tp;
+			while (t<rsq) {
+				if(++count>=p) {
+#if VOROPP_VERBOSE >=1
+					fputs("Bailed out of convex calculation",stderr);
+#endif
+					for(tp=0;tp<p;tp++) if(x*pts[3*tp]+y*pts[3*tp+1]+z*pts[3*tp+2]>rsq) return true;
+					return false;
+				}
+
+				// Test all the neighbors of the current point
+				// and find the one which is closest to the
+				// plane
+				for(us=0;us<ls;us++) {
+					tp=ed[up][us];
+					g=x*pts[3*tp]+y*pts[3*tp+1]+z*pts[3*tp+2];
+					if(g>t) break;
+				}
+				if(us==ls) {
+					us++;
+					while(us<nu[up]) {
+						tp=ed[up][us];
+						g=x*pts[3*tp]+y*pts[3*tp+1]+z*pts[3*tp+2];
+						if(g>t) break;
+						us++;
+					}
+					if(us==nu[up]) return false;
+				}
+				ls=ed[up][nu[up]+us];up=tp;t=g;
+			}
+			return true;
+		}
+	}
+	return false;
+}
+
+/** Counts the number of edges of the Voronoi cell.
+ * \return the number of edges. */
+int voronoicell_base::number_of_edges() {
+	int edges=0,*nup=nu;
+	while(nup<nu+p) edges+=*(nup++);
+	return edges>>1;
+}
+
+/** Outputs a custom string of information about the Voronoi cell. The string
+ * of information follows a similar style as the C printf command, and detailed
+ * information about its format is available at
+ * http://math.lbl.gov/voro++/doc/custom.html.
+ * \param[in] format the custom string to print.
+ * \param[in] i the ID of the particle associated with this Voronoi cell.
+ * \param[in] (x,y,z) the position of the particle associated with this Voronoi
+ *                    cell.
+ * \param[in] r a radius associated with the particle.
+ * \param[in] fp the file handle to write to. */
+void voronoicell_base::output_custom(const char *format,int i,double x,double y,double z,double r,FILE *fp) {
+	char *fmp=(const_cast<char*>(format));
+	std::vector<int> vi;
+	std::vector<double> vd;
+	while(*fmp!=0) {
+		if(*fmp=='%') {
+			fmp++;
+			switch(*fmp) {
+
+				// Particle-related output
+				case 'i': fprintf(fp,"%d",i);break;
+				case 'x': fprintf(fp,"%g",x);break;
+				case 'y': fprintf(fp,"%g",y);break;
+				case 'z': fprintf(fp,"%g",z);break;
+				case 'q': fprintf(fp,"%g %g %g",x,y,z);break;
+				case 'r': fprintf(fp,"%g",r);break;
+
+				// Vertex-related output
+				case 'w': fprintf(fp,"%d",p);break;
+				case 'p': output_vertices(fp);break;
+				case 'P': output_vertices(x,y,z,fp);break;
+				case 'o': output_vertex_orders(fp);break;
+				case 'm': fprintf(fp,"%g",0.25*max_radius_squared());break;
+
+				// Edge-related output
+				case 'g': fprintf(fp,"%d",number_of_edges());break;
+				case 'E': fprintf(fp,"%g",total_edge_distance());break;
+				case 'e': face_perimeters(vd);voro_print_vector(vd,fp);break;
+
+				// Face-related output
+				case 's': fprintf(fp,"%d",number_of_faces());break;
+				case 'F': fprintf(fp,"%g",surface_area());break;
+				case 'A': {
+						  face_freq_table(vi);
+						  voro_print_vector(vi,fp);
+					  } break;
+				case 'a': face_orders(vi);voro_print_vector(vi,fp);break;
+				case 'f': face_areas(vd);voro_print_vector(vd,fp);break;
+				case 't': {
+						  face_vertices(vi);
+						  voro_print_face_vertices(vi,fp);
+					  } break;
+				case 'l': normals(vd);
+					  voro_print_positions(vd,fp);
+					  break;
+				case 'n': neighbors(vi);
+					  voro_print_vector(vi,fp);
+					  break;
+
+				// Volume-related output
+				case 'v': fprintf(fp,"%g",volume());break;
+				case 'c': {
+						  double cx,cy,cz;
+						  centroid(cx,cy,cz);
+						  fprintf(fp,"%g %g %g",cx,cy,cz);
+					  } break;
+				case 'C': {
+						  double cx,cy,cz;
+						  centroid(cx,cy,cz);
+						  fprintf(fp,"%g %g %g",x+cx,y+cy,z+cz);
+					  } break;
+
+				// End-of-string reached
+				case 0: fmp--;break;
+
+				// The percent sign is not part of a
+				// control sequence
+				default: putc('%',fp);putc(*fmp,fp);
+			}
+		} else putc(*fmp,fp);
+		fmp++;
+	}
+	fputs("\n",fp);
+}
+
+/** This initializes the class to be a rectangular box. It calls the base class
+ * initialization routine to set up the edge and vertex information, and then
+ * sets up the neighbor information, with initial faces being assigned ID
+ * numbers from -1 to -6.
+ * \param[in] (xmin,xmax) the minimum and maximum x coordinates.
+ * \param[in] (ymin,ymax) the minimum and maximum y coordinates.
+ * \param[in] (zmin,zmax) the minimum and maximum z coordinates. */
+void voronoicell_neighbor::init(double xmin,double xmax,double ymin,double ymax,double zmin,double zmax) {
+	init_base(xmin,xmax,ymin,ymax,zmin,zmax);
+	int *q=mne[3];
+	*q=-5;q[1]=-3;q[2]=-1;
+	q[3]=-5;q[4]=-2;q[5]=-3;
+	q[6]=-5;q[7]=-1;q[8]=-4;
+	q[9]=-5;q[10]=-4;q[11]=-2;
+	q[12]=-6;q[13]=-1;q[14]=-3;
+	q[15]=-6;q[16]=-3;q[17]=-2;
+	q[18]=-6;q[19]=-4;q[20]=-1;
+	q[21]=-6;q[22]=-2;q[23]=-4;
+	*ne=q;ne[1]=q+3;ne[2]=q+6;ne[3]=q+9;
+	ne[4]=q+12;ne[5]=q+15;ne[6]=q+18;ne[7]=q+21;
+}
+
+/** This initializes the class to be an octahedron. It calls the base class
+ * initialization routine to set up the edge and vertex information, and then
+ * sets up the neighbor information, with the initial faces being assigned ID
+ * numbers from -1 to -8.
+ * \param[in] l The distance from the octahedron center to a vertex. Six
+ *              vertices are initialized at (-l,0,0), (l,0,0), (0,-l,0),
+ *              (0,l,0), (0,0,-l), and (0,0,l). */
+void voronoicell_neighbor::init_octahedron(double l) {
+	init_octahedron_base(l);
+	int *q=mne[4];
+	*q=-5;q[1]=-6;q[2]=-7;q[3]=-8;
+	q[4]=-1;q[5]=-2;q[6]=-3;q[7]=-4;
+	q[8]=-6;q[9]=-5;q[10]=-2;q[11]=-1;
+	q[12]=-8;q[13]=-7;q[14]=-4;q[15]=-3;
+	q[16]=-5;q[17]=-8;q[18]=-3;q[19]=-2;
+	q[20]=-7;q[21]=-6;q[22]=-1;q[23]=-4;
+	*ne=q;ne[1]=q+4;ne[2]=q+8;ne[3]=q+12;ne[4]=q+16;ne[5]=q+20;
+}
+
+/** This initializes the class to be a tetrahedron. It calls the base class
+ * initialization routine to set up the edge and vertex information, and then
+ * sets up the neighbor information, with the initial faces being assigned ID
+ * numbers from -1 to -4.
+ * \param (x0,y0,z0) a position vector for the first vertex.
+ * \param (x1,y1,z1) a position vector for the second vertex.
+ * \param (x2,y2,z2) a position vector for the third vertex.
+ * \param (x3,y3,z3) a position vector for the fourth vertex. */
+void voronoicell_neighbor::init_tetrahedron(double x0,double y0,double z0,double x1,double y1,double z1,double x2,double y2,double z2,double x3,double y3,double z3) {
+	init_tetrahedron_base(x0,y0,z0,x1,y1,z1,x2,y2,z2,x3,y3,z3);
+	int *q=mne[3];
+	*q=-4;q[1]=-3;q[2]=-2;
+	q[3]=-3;q[4]=-4;q[5]=-1;
+	q[6]=-4;q[7]=-2;q[8]=-1;
+	q[9]=-2;q[10]=-3;q[11]=-1;
+	*ne=q;ne[1]=q+3;ne[2]=q+6;ne[3]=q+9;
+}
+
+/** This routine checks to make sure the neighbor information of each face is
+ * consistent. */
+void voronoicell_neighbor::check_facets() {
+	int i,j,k,l,m,q;
+	for(i=1;i<p;i++) for(j=0;j<nu[i];j++) {
+		k=ed[i][j];
+		if(k>=0) {
+			ed[i][j]=-1-k;
+			q=ne[i][j];
+			l=cycle_up(ed[i][nu[i]+j],k);
+			do {
+				m=ed[k][l];
+				ed[k][l]=-1-m;
+				if(ne[k][l]!=q) fprintf(stderr,"Facet error at (%d,%d)=%d, started from (%d,%d)=%d\n",k,l,ne[k][l],i,j,q);
+				l=cycle_up(ed[k][nu[k]+l],m);
+				k=m;
+			} while (k!=i);
+		}
+	}
+	reset_edges();
+}
+
+/** The class constructor allocates memory for storing neighbor information. */
+voronoicell_neighbor::voronoicell_neighbor() {
+	int i;
+	mne=new int*[current_vertex_order];
+	ne=new int*[current_vertices];
+	for(i=0;i<3;i++) mne[i]=new int[init_n_vertices*i];
+	mne[3]=new int[init_3_vertices*3];
+	for(i=4;i<current_vertex_order;i++) mne[i]=new int[init_n_vertices*i];
+}
+
+/** The class destructor frees the dynamically allocated memory for storing
+ * neighbor information. */
+voronoicell_neighbor::~voronoicell_neighbor() {
+	for(int i=current_vertex_order-1;i>=0;i--) if(mem[i]>0) delete [] mne[i];
+	delete [] mne;
+	delete [] ne;
+}
+
+/** Computes a vector list of neighbors. */
+void voronoicell_neighbor::neighbors(std::vector<int> &v) {
+	v.clear();
+	int i,j,k,l,m;
+	for(i=1;i<p;i++) for(j=0;j<nu[i];j++) {
+		k=ed[i][j];
+		if(k>=0) {
+			v.push_back(ne[i][j]);
+			ed[i][j]=-1-k;
+			l=cycle_up(ed[i][nu[i]+j],k);
+			do {
+				m=ed[k][l];
+				ed[k][l]=-1-m;
+				l=cycle_up(ed[k][nu[k]+l],m);
+				k=m;
+			} while (k!=i);
+		}
+	}
+	reset_edges();
+}
+
+/** Prints the vertices, their edges, the relation table, and also notifies if
+ * any memory errors are visible. */
+void voronoicell_base::print_edges() {
+	int j;
+	double *ptsp=pts;
+	for(int i=0;i<p;i++,ptsp+=3) {
+		printf("%d %d  ",i,nu[i]);
+		for(j=0;j<nu[i];j++) printf(" %d",ed[i][j]);
+		printf("  ");
+		while(j<(nu[i]<<1)) printf(" %d",ed[i][j]);
+		printf("   %d",ed[i][j]);
+		print_edges_neighbors(i);
+		printf("  %g %g %g %p",*ptsp,ptsp[1],ptsp[2],(void*) ed[i]);
+		if(ed[i]>=mep[nu[i]]+mec[nu[i]]*((nu[i]<<1)+1)) puts(" Memory error");
+		else puts("");
+	}
+}
+
+/** This prints out the neighbor information for vertex i. */
+void voronoicell_neighbor::print_edges_neighbors(int i) {
+	if(nu[i]>0) {
+		int j=0;
+		printf("     (");
+		while(j<nu[i]-1) printf("%d,",ne[i][j++]);
+		printf("%d)",ne[i][j]);
+	} else printf("     ()");
+}
+
+// Explicit instantiation
+template bool voronoicell_base::nplane(voronoicell&,double,double,double,double,int);
+template bool voronoicell_base::nplane(voronoicell_neighbor&,double,double,double,double,int);
+template void voronoicell_base::check_memory_for_copy(voronoicell&,voronoicell_base*);
+template void voronoicell_base::check_memory_for_copy(voronoicell_neighbor&,voronoicell_base*);
+
+}
diff -ru --new-file blender-2.76b.old/extern/voro++/src/cell.hh blender-2.76b/extern/voro++/src/cell.hh
--- blender-2.76b.old/extern/voro++/src/cell.hh	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/cell.hh	2016-01-27 18:59:25.532187985 +0300
@@ -0,0 +1,514 @@
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \file cell.hh
+ * \brief Header file for the voronoicell and related classes. */
+
+#ifndef VOROPP_CELL_HH
+#define VOROPP_CELL_HH
+
+#include <vector>
+
+#include "config.hh"
+#include "common.hh"
+
+namespace voro {
+
+/** \brief A class representing a single Voronoi cell.
+ *
+ * This class represents a single Voronoi cell, as a collection of vertices
+ * that are connected by edges. The class contains routines for initializing
+ * the Voronoi cell to be simple shapes such as a box, tetrahedron, or octahedron.
+ * It the contains routines for recomputing the cell based on cutting it
+ * by a plane, which forms the key routine for the Voronoi cell computation.
+ * It contains numerous routine for computing statistics about the Voronoi cell,
+ * and it can output the cell in several formats.
+ *
+ * This class is not intended for direct use, but forms the base of the
+ * voronoicell and voronoicell_neighbor classes, which extend it based on
+ * whether neighboring particle ID information needs to be tracked. */
+class voronoicell_base {
+	public:
+		/** This holds the current size of the arrays ed and nu, which
+		 * hold the vertex information. If more vertices are created
+		 * than can fit in this array, then it is dynamically extended
+		 * using the add_memory_vertices routine. */
+		int current_vertices;
+		/** This holds the current maximum allowed order of a vertex,
+		 * which sets the size of the mem, mep, and mec arrays. If a
+		 * vertex is created with more vertices than this, the arrays
+		 * are dynamically extended using the add_memory_vorder routine.
+		 */
+		int current_vertex_order;
+		/** This sets the size of the main delete stack. */
+		int current_delete_size;
+		/** This sets the size of the auxiliary delete stack. */
+		int current_delete2_size;
+		/** This sets the total number of vertices in the current cell.
+		 */
+		int p;
+		/** This is the index of particular point in the cell, which is
+		 * used to start the tracing routines for plane intersection
+		 * and cutting. These routines will work starting from any
+		 * point, but it's often most efficient to start from the last
+		 * point considered, since in many cases, the cell construction
+		 * algorithm may consider many planes with similar vectors
+		 * concurrently. */
+		int up;
+		/** This is a two dimensional array that holds information
+		 * about the edge connections of the vertices that make up the
+		 * cell. The two dimensional array is not allocated in the
+		 * usual method. To account for the fact the different vertices
+		 * have different orders, and thus require different amounts of
+		 * storage, the elements of ed[i] point to one-dimensional
+		 * arrays in the mep[] array of different sizes.
+		 *
+		 * More specifically, if vertex i has order m, then ed[i]
+		 * points to a one-dimensional array in mep[m] that has 2*m+1
+		 * entries. The first m elements hold the neighboring edges, so
+		 * that the jth edge of vertex i is held in ed[i][j]. The next
+		 * m elements hold a table of relations which is redundant but
+		 * helps speed up the computation. It satisfies the relation
+		 * ed[ed[i][j]][ed[i][m+j]]=i. The final entry holds a back
+		 * pointer, so that ed[i+2*m]=i. The back pointers are used
+		 * when rearranging the memory. */
+		int **ed;
+		/** This array holds the order of the vertices in the Voronoi
+		 * cell. This array is dynamically allocated, with its current
+		 * size held by current_vertices. */
+		int *nu;
+		/** This in an array with size 3*current_vertices for holding
+		 * the positions of the vertices. */
+		double *pts;
+		voronoicell_base();
+		~voronoicell_base();
+		void init_base(double xmin,double xmax,double ymin,double ymax,double zmin,double zmax);
+		void init_octahedron_base(double l);
+		void init_tetrahedron_base(double x0,double y0,double z0,double x1,double y1,double z1,double x2,double y2,double z2,double x3,double y3,double z3);
+		void translate(double x,double y,double z);
+		void draw_pov(double x,double y,double z,FILE *fp=stdout);
+		/** Outputs the cell in POV-Ray format, using cylinders for edges
+		 * and spheres for vertices, to a given file.
+		 * \param[in] (x,y,z) a displacement to add to the cell's
+		 *                    position.
+		 * \param[in] filename the name of the file to write to. */
+		inline void draw_pov(double x,double y,double z,const char *filename) {
+			FILE *fp=safe_fopen(filename,"w");
+			draw_pov(x,y,z,fp);
+			fclose(fp);
+		};
+		void draw_pov_mesh(double x,double y,double z,FILE *fp=stdout);
+		/** Outputs the cell in POV-Ray format as a mesh2 object to a
+		 * given file.
+		 * \param[in] (x,y,z) a displacement to add to the cell's
+		 *                    position.
+		 * \param[in] filename the name of the file to write to. */
+		inline void draw_pov_mesh(double x,double y,double z,const char *filename) {
+			FILE *fp=safe_fopen(filename,"w");
+			draw_pov_mesh(x,y,z,fp);
+			fclose(fp);
+		}
+		void draw_gnuplot(double x,double y,double z,FILE *fp=stdout);
+		/** Outputs the cell in Gnuplot format a given file.
+		 * \param[in] (x,y,z) a displacement to add to the cell's
+		 *                    position.
+		 * \param[in] filename the name of the file to write to. */
+		inline void draw_gnuplot(double x,double y,double z,const char *filename) {
+			FILE *fp=safe_fopen(filename,"w");
+			draw_gnuplot(x,y,z,fp);
+			fclose(fp);
+		}
+		double volume();
+		double max_radius_squared();
+		double total_edge_distance();
+		double surface_area();
+		void centroid(double &cx,double &cy,double &cz);
+		int number_of_faces();
+		int number_of_edges();
+		void vertex_orders(std::vector<int> &v);
+		void output_vertex_orders(FILE *fp=stdout);
+		void vertices(std::vector<double> &v);
+		void output_vertices(FILE *fp=stdout);
+		void vertices(double x,double y,double z,std::vector<double> &v);
+		void output_vertices(double x,double y,double z,FILE *fp=stdout);
+		void face_areas(std::vector<double> &v);
+		/** Outputs the areas of the faces.
+		 * \param[in] fp the file handle to write to. */
+		inline void output_face_areas(FILE *fp=stdout) {
+			std::vector<double> v;face_areas(v);
+			voro_print_vector(v,fp);
+		}
+		void face_orders(std::vector<int> &v);
+		/** Outputs a list of the number of sides of each face.
+		 * \param[in] fp the file handle to write to. */
+		inline void output_face_orders(FILE *fp=stdout) {
+			std::vector<int> v;face_orders(v);
+			voro_print_vector(v,fp);
+		}
+		void face_freq_table(std::vector<int> &v);
+		/** Outputs a */
+		inline void output_face_freq_table(FILE *fp=stdout) {
+			std::vector<int> v;face_freq_table(v);
+			voro_print_vector(v,fp);
+		}
+		void face_vertices(std::vector<int> &v);
+		/** Outputs the */
+		inline void output_face_vertices(FILE *fp=stdout) {
+			std::vector<int> v;face_vertices(v);
+			voro_print_face_vertices(v,fp);
+		}
+		void face_perimeters(std::vector<double> &v);
+		/** Outputs a list of the perimeters of each face.
+		 * \param[in] fp the file handle to write to. */
+		inline void output_face_perimeters(FILE *fp=stdout) {
+			std::vector<double> v;face_perimeters(v);
+			voro_print_vector(v,fp);
+		}
+		void normals(std::vector<double> &v);
+		/** Outputs a list of the perimeters of each face.
+		 * \param[in] fp the file handle to write to. */
+		inline void output_normals(FILE *fp=stdout) {
+			std::vector<double> v;normals(v);
+			voro_print_positions(v,fp);
+		}
+		/** Outputs a custom string of information about the Voronoi
+		 * cell to a file. It assumes the cell is at (0,0,0) and has a
+		 * the default_radius associated with it.
+		 * \param[in] format the custom format string to use.
+		 * \param[in] fp the file handle to write to. */
+		inline void output_custom(const char *format,FILE *fp=stdout) {output_custom(format,0,0,0,0,default_radius,fp);}
+		void output_custom(const char *format,int i,double x,double y,double z,double r,FILE *fp=stdout);
+		template<class vc_class>
+		bool nplane(vc_class &vc,double x,double y,double z,double rsq,int p_id);
+		bool plane_intersects(double x,double y,double z,double rsq);
+		bool plane_intersects_guess(double x,double y,double z,double rsq);
+		void construct_relations();
+		void check_relations();
+		void check_duplicates();
+		void print_edges();
+		/** Returns a list of IDs of neighboring particles
+		 * corresponding to each face.
+		 * \param[out] v a reference to a vector in which to return the
+		 *               results. If no neighbor information is
+		 *               available, a blank vector is returned. */
+		virtual void neighbors(std::vector<int> &v) {v.clear();}
+		/** This is a virtual function that is overridden by a routine
+		 * to print a list of IDs of neighboring particles
+		 * corresponding to each face. By default, when no neighbor
+		 * information is available, the routine does nothing.
+		 * \param[in] fp the file handle to write to. */
+		virtual void output_neighbors(FILE *fp=stdout) {}
+		/** This a virtual function that is overridden by a routine to
+		 * print the neighboring particle IDs for a given vertex. By
+		 * default, when no neighbor information is available, the
+		 * routine does nothing.
+		 * \param[in] i the vertex to consider. */
+		virtual void print_edges_neighbors(int i) {};
+		/** This is a simple inline function for picking out the index
+		 * of the next edge counterclockwise at the current vertex.
+		 * \param[in] a the index of an edge of the current vertex.
+		 * \param[in] p the number of the vertex.
+		 * \return 0 if a=nu[p]-1, or a+1 otherwise. */
+		inline int cycle_up(int a,int p) {return a==nu[p]-1?0:a+1;}
+		/** This is a simple inline function for picking out the index
+		 * of the next edge clockwise from the current vertex.
+		 * \param[in] a the index of an edge of the current vertex.
+		 * \param[in] p the number of the vertex.
+		 * \return nu[p]-1 if a=0, or a-1 otherwise. */
+		inline int cycle_down(int a,int p) {return a==0?nu[p]-1:a-1;}
+	protected:
+		/** This a one dimensional array that holds the current sizes
+		 * of the memory allocations for them mep array.*/
+		int *mem;
+		/** This is a one dimensional array that holds the current
+		 * number of vertices of order p that are stored in the mep[p]
+		 * array. */
+		int *mec;
+		/** This is a two dimensional array for holding the information
+		 * about the edges of the Voronoi cell. mep[p] is a
+		 * one-dimensional array for holding the edge information about
+		 * all vertices of order p, with each vertex holding 2*p+1
+		 * integers of information. The total number of vertices held
+		 * on mep[p] is stored in mem[p]. If the space runs out, the
+		 * code allocates more using the add_memory() routine. */
+		int **mep;
+		inline void reset_edges();
+		template<class vc_class>
+		void check_memory_for_copy(vc_class &vc,voronoicell_base* vb);
+		void copy(voronoicell_base* vb);
+	private:
+		/** This is the delete stack, used to store the vertices which
+		 * are going to be deleted during the plane cutting procedure.
+		 */
+		int *ds,*stacke;
+		/** This is the auxiliary delete stack, which has size set by
+		 * current_delete2_size. */
+		int *ds2,*stacke2;
+		/** This stores the current memory allocation for the marginal
+		 * cases. */
+		int current_marginal;
+		/** This stores the total number of marginal points which are
+		 * currently in the buffer. */
+		int n_marg;
+		/** This array contains a list of the marginal points, and also
+		 * the outcomes of the marginal tests. */
+		int *marg;
+		/** The x coordinate of the normal vector to the test plane. */
+		double px;
+		/** The y coordinate of the normal vector to the test plane. */
+		double py;
+		/** The z coordinate of the normal vector to the test plane. */
+		double pz;
+		/** The magnitude of the normal vector to the test plane. */
+		double prsq;
+		template<class vc_class>
+		void add_memory(vc_class &vc,int i,int *stackp2);
+		template<class vc_class>
+		void add_memory_vertices(vc_class &vc);
+		template<class vc_class>
+		void add_memory_vorder(vc_class &vc);
+		void add_memory_ds(int *&stackp);
+		void add_memory_ds2(int *&stackp2);
+		template<class vc_class>
+		inline bool collapse_order1(vc_class &vc);
+		template<class vc_class>
+		inline bool collapse_order2(vc_class &vc);
+		template<class vc_class>
+		inline bool delete_connection(vc_class &vc,int j,int k,bool hand);
+		template<class vc_class>
+		inline bool search_for_outside_edge(vc_class &vc,int &up);
+		template<class vc_class>
+		inline void add_to_stack(vc_class &vc,int lp,int *&stackp2);
+		inline bool plane_intersects_track(double x,double y,double z,double rs,double g);
+		inline void normals_search(std::vector<double> &v,int i,int j,int k);
+		inline bool search_edge(int l,int &m,int &k);
+		inline int m_test(int n,double &ans);
+		int check_marginal(int n,double &ans);
+		friend class voronoicell;
+		friend class voronoicell_neighbor;
+};
+
+/** \brief Extension of the voronoicell_base class to represent a Voronoi
+ * cell without neighbor information.
+ *
+ * This class is an extension of the voronoicell_base class, in cases when
+ * is not necessary to track the IDs of neighboring particles associated
+ * with each face of the Voronoi cell. */
+class voronoicell : public voronoicell_base {
+	public:
+		using voronoicell_base::nplane;
+		/** Copies the information from another voronoicell class into
+		 * this class, extending memory allocation if necessary.
+		 * \param[in] c the class to copy. */
+		inline void operator=(voronoicell &c) {
+			voronoicell_base* vb((voronoicell_base*) &c);
+			check_memory_for_copy(*this,vb);copy(vb);
+		}
+		/** Cuts a Voronoi cell using by the plane corresponding to the
+		 * perpendicular bisector of a particle.
+		 * \param[in] (x,y,z) the position of the particle.
+		 * \param[in] rsq the modulus squared of the vector.
+		 * \param[in] p_id the plane ID, ignored for this case where no
+		 *                 neighbor tracking is enabled.
+		 * \return False if the plane cut deleted the cell entirely,
+		 *         true otherwise. */
+		inline bool nplane(double x,double y,double z,double rsq,int p_id) {
+			return nplane(*this,x,y,z,rsq,0);
+		}
+		/** Cuts a Voronoi cell using by the plane corresponding to the
+		 * perpendicular bisector of a particle.
+		 * \param[in] (x,y,z) the position of the particle.
+		 * \param[in] p_id the plane ID, ignored for this case where no
+		 *                 neighbor tracking is enabled.
+		 * \return False if the plane cut deleted the cell entirely,
+		 *         true otherwise. */
+		inline bool nplane(double x,double y,double z,int p_id) {
+			double rsq=x*x+y*y+z*z;
+			return nplane(*this,x,y,z,rsq,0);
+		}
+		/** Cuts a Voronoi cell using by the plane corresponding to the
+		 * perpendicular bisector of a particle.
+		 * \param[in] (x,y,z) the position of the particle.
+		 * \param[in] rsq the modulus squared of the vector.
+		 * \return False if the plane cut deleted the cell entirely,
+		 *         true otherwise. */
+		inline bool plane(double x,double y,double z,double rsq) {
+			return nplane(*this,x,y,z,rsq,0);
+		}
+		/** Cuts a Voronoi cell using by the plane corresponding to the
+		 * perpendicular bisector of a particle.
+		 * \param[in] (x,y,z) the position of the particle.
+		 * \return False if the plane cut deleted the cell entirely,
+		 *         true otherwise. */
+		inline bool plane(double x,double y,double z) {
+			double rsq=x*x+y*y+z*z;
+			return nplane(*this,x,y,z,rsq,0);
+		}
+		/** Initializes the Voronoi cell to be rectangular box with the
+		 * given dimensions.
+		 * \param[in] (xmin,xmax) the minimum and maximum x coordinates.
+		 * \param[in] (ymin,ymax) the minimum and maximum y coordinates.
+		 * \param[in] (zmin,zmax) the minimum and maximum z coordinates. */
+		inline void init(double xmin,double xmax,double ymin,double ymax,double zmin,double zmax) {
+			init_base(xmin,xmax,ymin,ymax,zmin,zmax);
+		}
+		/** Initializes the cell to be an octahedron with vertices at
+		 * (l,0,0), (-l,0,0), (0,l,0), (0,-l,0), (0,0,l), and (0,0,-l).
+		 * \param[in] l a parameter setting the size of the octahedron.
+		 */
+		inline void init_octahedron(double l) {
+			init_octahedron_base(l);
+		}
+		/** Initializes the cell to be a tetrahedron.
+		 * \param[in] (x0,y0,z0) the coordinates of the first vertex.
+		 * \param[in] (x1,y1,z1) the coordinates of the second vertex.
+		 * \param[in] (x2,y2,z2) the coordinates of the third vertex.
+		 * \param[in] (x3,y3,z3) the coordinates of the fourth vertex.
+		 */
+		inline void init_tetrahedron(double x0,double y0,double z0,double x1,double y1,double z1,double x2,double y2,double z2,double x3,double y3,double z3) {
+			init_tetrahedron_base(x0,y0,z0,x1,y1,z1,x2,y2,z2,x3,y3,z3);
+		}
+	private:
+		inline void n_allocate(int i,int m) {};
+		inline void n_add_memory_vertices(int i) {};
+		inline void n_add_memory_vorder(int i) {};
+		inline void n_set_pointer(int p,int n) {};
+		inline void n_copy(int a,int b,int c,int d) {};
+		inline void n_set(int a,int b,int c) {};
+		inline void n_set_aux1(int k) {};
+		inline void n_copy_aux1(int a,int b) {};
+		inline void n_copy_aux1_shift(int a,int b) {};
+		inline void n_set_aux2_copy(int a,int b) {};
+		inline void n_copy_pointer(int a,int b) {};
+		inline void n_set_to_aux1(int j) {};
+		inline void n_set_to_aux2(int j) {};
+		inline void n_allocate_aux1(int i) {};
+		inline void n_switch_to_aux1(int i) {};
+		inline void n_copy_to_aux1(int i,int m) {};
+		inline void n_set_to_aux1_offset(int k,int m) {};
+		inline void n_neighbors(std::vector<int> &v) {v.clear();};
+		friend class voronoicell_base;
+};
+
+/** \brief Extension of the voronoicell_base class to represent a Voronoi cell
+ * with neighbor information.
+ *
+ * This class is an extension of the voronoicell_base class, in cases when the
+ * IDs of neighboring particles associated with each face of the Voronoi cell.
+ * It contains additional data structures mne and ne for storing this
+ * information. */
+class voronoicell_neighbor : public voronoicell_base {
+	public:
+		using voronoicell_base::nplane;
+		/** This two dimensional array holds the neighbor information
+		 * associated with each vertex. mne[p] is a one dimensional
+		 * array which holds all of the neighbor information for
+		 * vertices of order p. */
+		int **mne;
+		/** This is a two dimensional array that holds the neighbor
+		 * information associated with each vertex. ne[i] points to a
+		 * one-dimensional array in mne[nu[i]]. ne[i][j] holds the
+		 * neighbor information associated with the jth edge of vertex
+		 * i. It is set to the ID number of the plane that made the
+		 * face that is clockwise from the jth edge. */
+		int **ne;
+		voronoicell_neighbor();
+		~voronoicell_neighbor();
+		void operator=(voronoicell &c);
+		void operator=(voronoicell_neighbor &c);
+		/** Cuts the Voronoi cell by a particle whose center is at a
+		 * separation of (x,y,z) from the cell center. The value of rsq
+		 * should be initially set to \f$x^2+y^2+z^2\f$.
+		 * \param[in] (x,y,z) the normal vector to the plane.
+		 * \param[in] rsq the distance along this vector of the plane.
+		 * \param[in] p_id the plane ID (for neighbor tracking only).
+		 * \return False if the plane cut deleted the cell entirely,
+		 * true otherwise. */
+		inline bool nplane(double x,double y,double z,double rsq,int p_id) {
+			return nplane(*this,x,y,z,rsq,p_id);
+		}
+		/** This routine calculates the modulus squared of the vector
+		 * before passing it to the main nplane() routine with full
+		 * arguments.
+		 * \param[in] (x,y,z) the vector to cut the cell by.
+		 * \param[in] p_id the plane ID (for neighbor tracking only).
+		 * \return False if the plane cut deleted the cell entirely,
+		 *         true otherwise. */
+		inline bool nplane(double x,double y,double z,int p_id) {
+			double rsq=x*x+y*y+z*z;
+			return nplane(*this,x,y,z,rsq,p_id);
+		}
+		/** This version of the plane routine just makes up the plane
+		 * ID to be zero. It will only be referenced if neighbor
+		 * tracking is enabled.
+		 * \param[in] (x,y,z) the vector to cut the cell by.
+		 * \param[in] rsq the modulus squared of the vector.
+		 * \return False if the plane cut deleted the cell entirely,
+		 *         true otherwise. */
+		inline bool plane(double x,double y,double z,double rsq) {
+			return nplane(*this,x,y,z,rsq,0);
+		}
+		/** Cuts a Voronoi cell using the influence of a particle at
+		 * (x,y,z), first calculating the modulus squared of this
+		 * vector before passing it to the main nplane() routine. Zero
+		 * is supplied as the plane ID, which will be ignored unless
+		 * neighbor tracking is enabled.
+		 * \param[in] (x,y,z) the vector to cut the cell by.
+		 * \return False if the plane cut deleted the cell entirely,
+		 *         true otherwise. */
+		inline bool plane(double x,double y,double z) {
+			double rsq=x*x+y*y+z*z;
+			return nplane(*this,x,y,z,rsq,0);
+		}
+		void init(double xmin,double xmax,double ymin,double ymax,double zmin,double zmax);
+		void init_octahedron(double l);
+		void init_tetrahedron(double x0,double y0,double z0,double x1,double y1,double z1,double x2,double y2,double z2,double x3,double y3,double z3);
+		void check_facets();
+		virtual void neighbors(std::vector<int> &v);
+		virtual void print_edges_neighbors(int i);
+		virtual void output_neighbors(FILE *fp=stdout) {
+			std::vector<int> v;neighbors(v);
+			voro_print_vector(v,fp);
+		}
+	private:
+		int *paux1;
+		int *paux2;
+		inline void n_allocate(int i,int m) {mne[i]=new int[m*i];}
+		inline void n_add_memory_vertices(int i) {
+			int **pp=new int*[i];
+			for(int j=0;j<current_vertices;j++) pp[j]=ne[j];
+			delete [] ne;ne=pp;
+		}
+		inline void n_add_memory_vorder(int i) {
+			int **p2=new int*[i];
+			for(int j=0;j<current_vertex_order;j++) p2[j]=mne[j];
+			delete [] mne;mne=p2;
+		}
+		inline void n_set_pointer(int p,int n) {
+			ne[p]=mne[n]+n*mec[n];
+		}
+		inline void n_copy(int a,int b,int c,int d) {ne[a][b]=ne[c][d];}
+		inline void n_set(int a,int b,int c) {ne[a][b]=c;}
+		inline void n_set_aux1(int k) {paux1=mne[k]+k*mec[k];}
+		inline void n_copy_aux1(int a,int b) {paux1[b]=ne[a][b];}
+		inline void n_copy_aux1_shift(int a,int b) {paux1[b]=ne[a][b+1];}
+		inline void n_set_aux2_copy(int a,int b) {
+			paux2=mne[b]+b*mec[b];
+			for(int i=0;i<b;i++) ne[a][i]=paux2[i];
+		}
+		inline void n_copy_pointer(int a,int b) {ne[a]=ne[b];}
+		inline void n_set_to_aux1(int j) {ne[j]=paux1;}
+		inline void n_set_to_aux2(int j) {ne[j]=paux2;}
+		inline void n_allocate_aux1(int i) {paux1=new int[i*mem[i]];}
+		inline void n_switch_to_aux1(int i) {delete [] mne[i];mne[i]=paux1;}
+		inline void n_copy_to_aux1(int i,int m) {paux1[m]=mne[i][m];}
+		inline void n_set_to_aux1_offset(int k,int m) {ne[k]=paux1+m;}
+		friend class voronoicell_base;
+};
+
+}
+
+#endif
diff -ru --new-file blender-2.76b.old/extern/voro++/src/c_interface.cc blender-2.76b/extern/voro++/src/c_interface.cc
--- blender-2.76b.old/extern/voro++/src/c_interface.cc	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/c_interface.cc	2016-01-27 18:57:15.797154165 +0300
@@ -0,0 +1,189 @@
+#include <stdio.h>
+
+#include "c_interface.hh"
+#include "voro++.hh"
+
+container* container_new(double ax_,double bx_,double ay_,double by_,double az_,double bz_,
+                         int nx_,int ny_,int nz_,int xperiodic_,int yperiodic_,int zperiodic_,int init_mem)
+{
+	
+	return (container*)(new voro::container(ax_, bx_, ay_, by_, az_, bz_, nx_, ny_, nz_,
+	                                        xperiodic_, yperiodic_, zperiodic_, init_mem));
+}
+
+particle_order* particle_order_new(void)
+{
+	return (particle_order*)(new voro::particle_order());
+}
+
+void container_put(container* con, particle_order* p_order, int n,double x,double y,double z)
+{
+	voro::container* c = (voro::container*)con;
+	voro::particle_order* po = (voro::particle_order*)p_order;
+	
+	if (po)
+	{
+		c->put(*po, n, x, y, z);
+	}
+	else
+	{
+		c->put(n, x, y, z);
+	}
+	
+}
+
+void container_compute_cells(container* con, cell* cells)
+{
+	int i = 0, v = 0, fo = 0, fv = 0, n = 0;
+	voro::container* cn = (voro::container*)con;
+	voro::voronoicell_neighbor vc;
+	voro::c_loop_all vl(*cn);
+	cell c;
+	if(vl.start()) {
+		do {
+			if (cn->compute_cell(vc,vl)) {
+
+				// adapted from voro++
+				std::vector<double> verts;
+				std::vector<int> face_orders;
+				std::vector<int> face_verts;
+				std::vector<int> neighbors;
+				double *pp, centroid[3];
+				pp = vl.p[vl.ijk]+vl.ps*vl.q;
+
+				// cell particle index
+				c.index = cn->id[vl.ijk][vl.q];
+
+				// verts
+				vc.vertices(*pp, pp[1], pp[2], verts);
+				c.totvert = vc.p;
+				c.verts = new float[c.totvert][3];
+				for (v = 0; v < c.totvert; v++) {
+					c.verts[v][0] = (float)verts[v * 3];
+					c.verts[v][1] = (float)verts[v * 3 + 1];
+					c.verts[v][2] = (float)verts[v * 3 + 2];
+				}
+
+				// faces
+				c.totpoly = vc.number_of_faces();
+				vc.face_orders(face_orders);
+				c.poly_totvert = new int[c.totpoly];
+
+				for (fo = 0; fo < c.totpoly; fo++) {
+					c.poly_totvert[fo] = face_orders[fo];
+				}
+
+				vc.face_vertices(face_verts);
+				c.poly_indices = new int*[c.totpoly];
+				int skip = 0;
+				for (fo = 0; fo < c.totpoly; fo++) {
+					int num_verts = c.poly_totvert[fo];
+					c.poly_indices[fo] = new int[num_verts];
+					for (fv = 0; fv < num_verts; fv++) {
+						c.poly_indices[fo][fv] = face_verts[skip + 1 + fv];
+					}
+					skip += (num_verts+1);
+				}
+
+				// neighbors
+				vc.neighbors(neighbors);
+				c.neighbors = new int[c.totpoly];
+				for (n = 0; n < c.totpoly; n++)
+				{
+					c.neighbors[n] = neighbors[n];
+				}
+
+				// centroid
+				vc.centroid(centroid[0], centroid[1], centroid[2]);
+				c.centroid[0] = (float)centroid[0] + (float)*pp;
+				c.centroid[1] = (float)centroid[1] + (float)pp[1];
+				c.centroid[2] = (float)centroid[2] + (float)pp[2];
+
+				// valid cell, store
+				cells[i] = c;
+
+			}
+			else { // invalid cell, set NULL XXX TODO (Somehow !!!)
+				c.centroid[0] = 0.0f;
+				c.centroid[1] = 0.0f;
+				c.centroid[2] = 0.0f;
+				c.index = 0;
+				c.neighbors = NULL;
+				c.totpoly = 0;
+				c.totvert = 0;
+				c.poly_totvert = NULL;
+				c.poly_indices = NULL;
+				c.verts = NULL;
+				cells[i] = c;
+			}
+			i++;
+		}
+		while(vl.inc());
+	}
+}
+
+void container_free(container* con)
+{
+	voro::container* c = (voro::container*)con;
+	delete c;
+}
+
+void particle_order_free(particle_order* p_order)
+{
+	voro::particle_order* po = (voro::particle_order*)p_order;
+	delete po;
+}
+
+cell* cells_new(int totcells)
+{
+	int i = 0;
+	cell c;
+	cell *cl;
+
+	//need to initalize properly in case we dont compute....
+	c.centroid[0] = 0.0f;
+	c.centroid[1] = 0.0f;
+	c.centroid[2] = 0.0f;
+	c.index = 0;
+	c.neighbors = NULL;
+	c.totpoly = 0;
+	c.totvert = 0;
+	c.poly_totvert = NULL;
+	c.poly_indices = NULL;
+	c.verts = NULL;
+
+	cl = new cell[totcells];
+	for (i = 0; i < totcells; i++)
+	{
+		cl[i] = c;
+	}
+
+	return cl;
+}
+
+void cells_free(cell *cells, int totcells)
+{
+	// XXX TODO free properly !
+	if (cells) {
+		int i = 0, j = 0;
+		for (i = 0; i < totcells; i++) {
+			cell c = cells[i];
+			if (c.verts)
+			{
+				delete [] c.verts;
+			}
+			if (c.neighbors) delete [] c.neighbors;
+			if (c.poly_indices)
+			{
+				for (j = 0; j < c.totpoly; j++)
+				{
+					delete [] c.poly_indices[j];
+				}
+				delete [] c.poly_indices;
+			}
+			if (c.poly_totvert) delete [] c.poly_totvert;
+		}
+		delete [] cells;
+	}
+
+}
diff -ru --new-file blender-2.76b.old/extern/voro++/src/c_interface.hh blender-2.76b/extern/voro++/src/c_interface.hh
--- blender-2.76b.old/extern/voro++/src/c_interface.hh	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/c_interface.hh	2016-01-27 18:56:30.942488370 +0300
@@ -0,0 +1,64 @@
+#ifndef VORO_C_INTERFACE_H
+#define VORO_C_INTERFACE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef void container;
+typedef void loop_order;
+
+typedef struct particle_order {
+	int *o;
+	int *op;
+	int size;
+} particle_order;
+
+/* Necessary Voro++ data for fracture:
+ * %i the particle/cell index
+ *
+ * %w number of vertices (totvert)
+ * %P global vertex coordinates
+ * v  vertex section delimiter
+ *
+ * %s number of faces (totpoly)
+ * %a number of vertices in each face (sum is totloop)
+ * %t the indices to the cell vertices, describes which vertices build each face
+ * %n neighboring cell index for each face
+ * f  face section delimiter
+ *
+ * %C the centroid of the voronoi cell
+ * c  centroid section delimiter
+ */
+
+typedef struct cell {
+	float (*verts)[3];
+	int *poly_totvert;
+	int **poly_indices;
+	int *neighbors;
+
+	float centroid[3];
+	int index;
+	int totvert;
+	int totpoly;
+} cell;
+
+container* container_new(double ax_,double bx_,double ay_,double by_,double az_,double bz_,
+                         int nx_,int ny_,int nz_,int xperiodic_,int yperiodic_,int zperiodic_,int init_mem);
+particle_order* particle_order_new(void);
+
+void container_put(container* con, particle_order* po, int n, double x, double y, double z);
+
+void container_free(container* con);
+void particle_order_free(particle_order* po);
+
+// cell array for direct access
+cell* cells_new(int totcell);
+void cells_free(cell* cells, int totcells);
+void container_compute_cells(container* con, cell* cells);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* VORO_C_INTERFACE_H */
diff -ru --new-file blender-2.76b.old/extern/voro++/src/c_loops.cc blender-2.76b/extern/voro++/src/c_loops.cc
--- blender-2.76b.old/extern/voro++/src/c_loops.cc	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/c_loops.cc	2016-01-27 18:58:31.452590652 +0300
@@ -0,0 +1,150 @@
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \file c_loops.cc
+ * \brief Function implementations for the loop classes. */
+
+#include "c_loops.hh"
+
+namespace voro {
+
+/** Initializes a c_loop_subset object to scan over all particles within a
+ * given sphere.
+ * \param[in] (vx,vy,vz) the position vector of the center of the sphere.
+ * \param[in] r the radius of the sphere.
+ * \param[in] bounds_test whether to do detailed bounds checking. If this is
+ *                        false then the class will loop over all particles in
+ *                        blocks that overlap the given sphere. If it is true,
+ *                        the particle will only loop over the particles which
+ *                        actually lie within the sphere.
+ * \return True if there is any valid point to loop over, false otherwise. */
+void c_loop_subset::setup_sphere(double vx,double vy,double vz,double r,bool bounds_test) {
+	if(bounds_test) {mode=sphere;v0=vx;v1=vy;v2=vz;v3=r*r;} else mode=no_check;
+	ai=step_int((vx-ax-r)*xsp);
+	bi=step_int((vx-ax+r)*xsp);
+	aj=step_int((vy-ay-r)*ysp);
+	bj=step_int((vy-ay+r)*ysp);
+	ak=step_int((vz-az-r)*zsp);
+	bk=step_int((vz-az+r)*zsp);
+	setup_common();
+}
+
+/** Initializes the class to loop over all particles in a rectangular subgrid
+ * of blocks.
+ * \param[in] (ai_,bi_) the subgrid range in the x-direction, inclusive of both
+ *                      ends.
+ * \param[in] (aj_,bj_) the subgrid range in the y-direction, inclusive of both
+ *                      ends.
+ * \param[in] (ak_,bk_) the subgrid range in the z-direction, inclusive of both
+ *                      ends.
+ * \return True if there is any valid point to loop over, false otherwise. */
+void c_loop_subset::setup_intbox(int ai_,int bi_,int aj_,int bj_,int ak_,int bk_) {
+	ai=ai_;bi=bi_;aj=aj_;bj=bj_;ak=ak_;bk=bk_;
+	mode=no_check;
+	setup_common();
+}
+
+/** Sets up all of the common constants used for the loop.
+ * \return True if there is any valid point to loop over, false otherwise. */
+void c_loop_subset::setup_common() {
+	if(!xperiodic) {
+		if(ai<0) {ai=0;if(bi<0) bi=0;}
+		if(bi>=nx) {bi=nx-1;if(ai>=nx) ai=nx-1;}
+	}
+	if(!yperiodic) {
+		if(aj<0) {aj=0;if(bj<0) bj=0;}
+		if(bj>=ny) {bj=ny-1;if(aj>=ny) aj=ny-1;}
+	}
+	if(!zperiodic) {
+		if(ak<0) {ak=0;if(bk<0) bk=0;}
+		if(bk>=nz) {bk=nz-1;if(ak>=nz) ak=nz-1;}
+	}
+	ci=ai;cj=aj;ck=ak;
+	di=i=step_mod(ci,nx);apx=px=step_div(ci,nx)*sx;
+	dj=j=step_mod(cj,ny);apy=py=step_div(cj,ny)*sy;
+	dk=k=step_mod(ck,nz);apz=pz=step_div(ck,nz)*sz;
+	inc1=di-step_mod(bi,nx);
+	inc2=nx*(ny+dj-step_mod(bj,ny))+inc1;
+	inc1+=nx;
+	ijk=di+nx*(dj+ny*dk);
+	q=0;
+}
+
+/** Starts the loop by finding the first particle within the container to
+ * consider.
+ * \return True if there is any particle to consider, false otherwise. */
+bool c_loop_subset::start() {
+	while(co[ijk]==0) {if(!next_block()) return false;}
+	while(mode!=no_check&&out_of_bounds()) {
+		q++;
+		while(q>=co[ijk]) {q=0;if(!next_block()) return false;}
+	}
+	return true;
+}
+
+/** Initializes the class to loop over all particles in a rectangular box.
+ * \param[in] (xmin,xmax) the minimum and maximum x coordinates of the box.
+ * \param[in] (ymin,ymax) the minimum and maximum y coordinates of the box.
+ * \param[in] (zmin,zmax) the minimum and maximum z coordinates of the box.
+ * \param[in] bounds_test whether to do detailed bounds checking. If this is
+ *                        false then the class will loop over all particles in
+ *                        blocks that overlap the given box. If it is true, the
+ *                        particle will only loop over the particles which
+ *                        actually lie within the box.
+ * \return True if there is any valid point to loop over, false otherwise. */
+void c_loop_subset::setup_box(double xmin,double xmax,double ymin,double ymax,double zmin,double zmax,bool bounds_test) {
+	if(bounds_test) {mode=box;v0=xmin;v1=xmax;v2=ymin;v3=ymax;v4=zmin;v5=zmax;} else mode=no_check;
+	ai=step_int((xmin-ax)*xsp);
+	bi=step_int((xmax-ax)*xsp);
+	aj=step_int((ymin-ay)*ysp);
+	bj=step_int((ymax-ay)*ysp);
+	ak=step_int((zmin-az)*zsp);
+	bk=step_int((zmax-az)*zsp);
+	setup_common();
+}
+
+/** Computes whether the current point is out of bounds, relative to the
+ * current loop setup.
+ * \return True if the point is out of bounds, false otherwise. */
+bool c_loop_subset::out_of_bounds() {
+	double *pp=p[ijk]+ps*q;
+	if(mode==sphere) {
+		double fx(*pp+px-v0),fy(pp[1]+py-v1),fz(pp[2]+pz-v2);
+		return fx*fx+fy*fy+fz*fz>v3;
+	} else {
+		double f(*pp+px);if(f<v0||f>v1) return true;
+		f=pp[1]+py;if(f<v2||f>v3) return true;
+		f=pp[2]+pz;return f<v4||f>v5;
+	}
+}
+
+/** Returns the next block to be tested in a loop, and updates the periodicity
+ * vector if necessary. */
+bool c_loop_subset::next_block() {
+	if(i<bi) {
+		i++;
+		if(ci<nx-1) {ci++;ijk++;} else {ci=0;ijk+=1-nx;px+=sx;}
+		return true;
+	} else if(j<bj) {
+		i=ai;ci=di;px=apx;j++;
+		if(cj<ny-1) {cj++;ijk+=inc1;} else {cj=0;ijk+=inc1-nxy;py+=sy;}
+		return true;
+	} else if(k<bk) {
+		i=ai;ci=di;j=aj;cj=dj;px=apx;py=apy;k++;
+		if(ck<nz-1) {ck++;ijk+=inc2;} else {ck=0;ijk+=inc2-nxyz;pz+=sz;}
+		return true;
+	} else return false;
+}
+
+/** Extends the memory available for storing the ordering. */
+void particle_order::add_ordering_memory() {
+	int *no=new int[size<<2],*nop=no,*opp=o;
+	while(opp<op) *(nop++)=*(opp++);
+	delete [] o;
+	size<<=1;o=no;op=nop;
+}
+
+}
diff -ru --new-file blender-2.76b.old/extern/voro++/src/c_loops.hh blender-2.76b/extern/voro++/src/c_loops.hh
--- blender-2.76b.old/extern/voro++/src/c_loops.hh	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/c_loops.hh	2016-01-27 18:57:58.388836896 +0300
@@ -0,0 +1,456 @@
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \file c_loops.hh
+ * \brief Header file for the loop classes. */
+
+#ifndef VOROPP_C_LOOPS_HH
+#define VOROPP_C_LOOPS_HH
+
+#include "config.hh"
+
+namespace voro {
+
+/** A type associated with a c_loop_subset class, determining what type of
+ * geometrical region to loop over. */
+enum c_loop_subset_mode {
+	sphere,
+	box,
+	no_check
+};
+
+/** \brief A class for storing ordering information when particles are added to
+ * a container.
+ *
+ * When particles are added to a container class, they are sorted into an
+ * internal computational grid of blocks. The particle_order class provides a
+ * mechanism for remembering which block particles were sorted into. The import
+ * and put routines in the container class have variants that also take a
+ * particle_order class. Each time they are called, they will store the block
+ * that the particle was sorted into, plus the position of the particle within
+ * the block. The particle_order class can used by the c_loop_order class to
+ * specifically loop over the particles that have their information stored
+ * within it. */
+class particle_order {
+	public:
+		/** A pointer to the array holding the ordering. */
+		int *o;
+		/** A pointer to the next position in the ordering array in
+		 * which to store an entry. */
+		int *op;
+		/** The current memory allocation for the class, set to the
+		 * number of entries which can be stored. */
+		int size;
+		/** The particle_order constructor allocates memory to store the
+		 * ordering information.
+		 * \param[in] init_size the initial amount of memory to
+		 *                      allocate. */
+		particle_order(int init_size=init_ordering_size)
+			: o(new int[init_size<<1]),op(o),size(init_size) {}
+		/** The particle_order destructor frees the dynamically allocated
+		 * memory used to store the ordering information. */
+		~particle_order() {
+			delete [] o;
+		}
+		/** Adds a record to the order, corresponding to the memory
+		 * address of where a particle was placed into the container.
+		 * \param[in] ijk the block into which the particle was placed.
+		 * \param[in] q the position within the block where the
+		 * 		particle was placed. */
+		inline void add(int ijk,int q) {
+			if(op==o+size) add_ordering_memory();
+			*(op++)=ijk;*(op++)=q;
+		}
+	private:
+		void add_ordering_memory();
+};
+
+/** \brief Base class for looping over particles in a container.
+ *
+ * This class forms the base of all classes that can loop over a subset of
+ * particles in a contaner in some order. When initialized, it stores constants
+ * about the corresponding container geometry. It also contains a number of
+ * routines for interrogating which particle currently being considered by the
+ * loop, which are common between all of the derived classes. */
+class c_loop_base {
+	public:
+		/** The number of blocks in the x direction. */
+		const int nx;
+		/** The number of blocks in the y direction. */
+		const int ny;
+		/** The number of blocks in the z direction. */
+		const int nz;
+		/** A constant, set to the value of nx multiplied by ny, which
+		 * is used in the routines that step through blocks in
+		 * sequence. */
+		const int nxy;
+		/** A constant, set to the value of nx*ny*nz, which is used in
+		 * the routines that step through blocks in sequence. */
+		const int nxyz;
+		/** The number of floating point numbers per particle in the
+		 * associated container data structure. */
+		const int ps;
+		/** A pointer to the particle position information in the
+		 * associated container data structure. */
+		double **p;
+		/** A pointer to the particle ID information in the associated
+		 * container data structure. */
+		int **id;
+		/** A pointer to the particle counts in the associated
+		 * container data structure. */
+		int *co;
+		/** The current x-index of the block under consideration by the
+		 * loop. */
+		int i;
+		/** The current y-index of the block under consideration by the
+		 * loop. */
+		int j;
+		/** The current z-index of the block under consideration by the
+		 * loop. */
+		int k;
+		/** The current index of the block under consideration by the
+		 * loop. */
+		int ijk;
+		/** The index of the particle under consideration within the current
+		 * block. */
+		int q;
+		/** The constructor copies several necessary constants from the
+		 * base container class.
+		 * \param[in] con the container class to use. */
+		template<class c_class>
+		c_loop_base(c_class &con) : nx(con.nx), ny(con.ny), nz(con.nz),
+					    nxy(con.nxy), nxyz(con.nxyz), ps(con.ps),
+					    p(con.p), id(con.id), co(con.co) {}
+		/** Returns the position vector of the particle currently being
+		 * considered by the loop.
+		 * \param[out] (x,y,z) the position vector of the particle. */
+		inline void pos(double &x,double &y,double &z) {
+			double *pp=p[ijk]+ps*q;
+			x=*(pp++);y=*(pp++);z=*pp;
+		}
+		/** Returns the ID, position vector, and radius of the particle
+		 * currently being considered by the loop.
+		 * \param[out] pid the particle ID.
+		 * \param[out] (x,y,z) the position vector of the particle.
+		 * \param[out] r the radius of the particle. If no radius
+		 * 		 information is available the default radius
+		 * 		 value is returned. */
+		inline void pos(int &pid,double &x,double &y,double &z,double &r) {
+			pid=id[ijk][q];
+			double *pp=p[ijk]+ps*q;
+			x=*(pp++);y=*(pp++);z=*pp;
+			r=ps==3?default_radius:*(++pp);
+		}
+		/** Returns the x position of the particle currently being
+		 * considered by the loop. */
+		inline double x() {return p[ijk][ps*q];}
+		/** Returns the y position of the particle currently being
+		 * considered by the loop. */
+		inline double y() {return p[ijk][ps*q+1];}
+		/** Returns the z position of the particle currently being
+		 * considered by the loop. */
+		inline double z() {return p[ijk][ps*q+2];}
+		/** Returns the ID of the particle currently being considered
+		 * by the loop. */
+		inline int pid() {return id[ijk][q];}
+};
+
+/** \brief Class for looping over all of the particles in a container.
+ *
+ * This is one of the simplest loop classes, that scans the computational
+ * blocks in order, and scans all the particles within each block in order. */
+class c_loop_all : public c_loop_base {
+	public:
+		/** The constructor copies several necessary constants from the
+		 * base container class.
+		 * \param[in] con the container class to use. */
+		template<class c_class>
+		c_loop_all(c_class &con) : c_loop_base(con) {}
+		/** Sets the class to consider the first particle.
+		 * \return True if there is any particle to consider, false
+		 * otherwise. */
+		inline bool start() {
+			i=j=k=ijk=q=0;
+			while(co[ijk]==0) if(!next_block()) return false;
+			return true;
+		}
+		/** Finds the next particle to test.
+		 * \return True if there is another particle, false if no more
+		 * particles are available. */
+		inline bool inc() {
+			q++;
+			if(q>=co[ijk]) {
+				q=0;
+				do {
+					if(!next_block()) return false;
+				} while(co[ijk]==0);
+			}
+			return true;
+		}
+	private:
+		/** Updates the internal variables to find the next
+		 * computational block with any particles.
+		 * \return True if another block is found, false if there are
+		 * no more blocks. */
+		inline bool next_block() {
+			ijk++;
+			i++;
+			if(i==nx) {
+				i=0;j++;
+				if(j==ny) {
+					j=0;k++;
+					if(ijk==nxyz) return false;
+				}
+			}
+			return true;
+		}
+};
+
+/** \brief Class for looping over a subset of particles in a container.
+ *
+ * This class can loop over a subset of particles in a certain geometrical
+ * region within the container. The class can be set up to loop over a
+ * rectangular box or sphere. It can also rectangular group of internal
+ * computational blocks. */
+class c_loop_subset : public c_loop_base {
+	public:
+		/** The current mode of operation, determining whether tests
+		 * should be applied to particles to ensure they are within a
+		 * certain geometrical object. */
+		c_loop_subset_mode mode;
+		/** The constructor copies several necessary constants from the
+		 * base container class.
+		 * \param[in] con the container class to use. */
+		template<class c_class>
+		c_loop_subset(c_class &con) : c_loop_base(con), ax(con.ax), ay(con.ay), az(con.az),
+			sx(con.bx-ax), sy(con.by-ay), sz(con.bz-az), xsp(con.xsp), ysp(con.ysp), zsp(con.zsp),
+			xperiodic(con.xperiodic), yperiodic(con.yperiodic), zperiodic(con.zperiodic) {}
+		void setup_sphere(double vx,double vy,double vz,double r,bool bounds_test=true);
+		void setup_box(double xmin,double xmax,double ymin,double ymax,double zmin,double zmax,bool bounds_test=true);
+		void setup_intbox(int ai_,int bi_,int aj_,int bj_,int ak_,int bk_);
+		bool start();
+		/** Finds the next particle to test.
+		 * \return True if there is another particle, false if no more
+		 * particles are available. */
+		inline bool inc() {
+			do {
+				q++;
+				while(q>=co[ijk]) {q=0;if(!next_block()) return false;}
+			} while(mode!=no_check&&out_of_bounds());
+			return true;
+		}
+	private:
+		const double ax,ay,az,sx,sy,sz,xsp,ysp,zsp;
+		const bool xperiodic,yperiodic,zperiodic;
+		double px,py,pz,apx,apy,apz;
+		double v0,v1,v2,v3,v4,v5;
+		int ai,bi,aj,bj,ak,bk;
+		int ci,cj,ck,di,dj,dk,inc1,inc2;
+		inline int step_mod(int a,int b) {return a>=0?a%b:b-1-(b-1-a)%b;}
+		inline int step_div(int a,int b) {return a>=0?a/b:-1+(a+1)/b;}
+		inline int step_int(double a) {return a<0?int(a)-1:int(a);}
+		void setup_common();
+		bool next_block();
+		bool out_of_bounds();
+};
+
+/** \brief Class for looping over all of the particles specified in a
+ * pre-assembled particle_order class.
+ *
+ * The particle_order class can be used to create a specific order of particles
+ * within the container. This class can then loop over these particles in this
+ * order. The class is particularly useful in cases where the ordering of the
+ * output must match the ordering of particles as they were inserted into the
+ * container. */
+class c_loop_order : public c_loop_base {
+	public:
+		/** A reference to the ordering class to use. */
+		particle_order &vo;
+		/** A pointer to the current position in the ordering class. */
+		int *cp;
+		/** A pointer to the end position in the ordering class. */
+		int *op;
+		/** The constructor copies several necessary constants from the
+		 * base class, and sets up a reference to the ordering class to
+		 * use.
+		 * \param[in] con the container class to use.
+		 * \param[in] vo_ the ordering class to use. */
+		template<class c_class>
+		c_loop_order(c_class &con,particle_order &vo_)
+		: c_loop_base(con), vo(vo_), nx(con.nx), nxy(con.nxy) {}
+		/** Sets the class to consider the first particle.
+		 * \return True if there is any particle to consider, false
+		 * otherwise. */
+		inline bool start() {
+			cp=vo.o;op=vo.op;
+			if(cp!=op) {
+				ijk=*(cp++);decode();
+				q=*(cp++);
+				return true;
+			} else return false;
+		}
+		/** Finds the next particle to test.
+		 * \return True if there is another particle, false if no more
+		 * particles are available. */
+		inline bool inc() {
+			if(cp==op) return false;
+			ijk=*(cp++);decode();
+			q=*(cp++);
+			return true;
+		}
+	private:
+		/** The number of computational blocks in the x direction. */
+		const int nx;
+		/** The number of computational blocks in a z-slice. */
+		const int nxy;
+		/** Takes the current block index and computes indices in the
+		 * x, y, and z directions. */
+		inline void decode() {
+			k=ijk/nxy;
+			int ijkt=ijk-nxy*k;
+			j=ijkt/nx;
+			i=ijkt-j*nx;
+		}
+};
+
+/** \brief A class for looping over all particles in a container_periodic or
+ * container_periodic_poly class.
+ *
+ * Since the container_periodic and container_periodic_poly classes have a
+ * fundamentally different memory organization, the regular loop classes cannot
+ * be used with them. */
+class c_loop_all_periodic : public c_loop_base {
+	public:
+		/** The constructor copies several necessary constants from the
+		 * base periodic container class.
+		 * \param[in] con the periodic container class to use. */
+		template<class c_class>
+		c_loop_all_periodic(c_class &con) : c_loop_base(con), ey(con.ey), ez(con.ez), wy(con.wy), wz(con.wz),
+			ijk0(nx*(ey+con.oy*ez)), inc2(2*nx*con.ey+1) {}
+		/** Sets the class to consider the first particle.
+		 * \return True if there is any particle to consider, false
+		 * otherwise. */
+		inline bool start() {
+			i=0;
+			j=ey;
+			k=ez;
+			ijk=ijk0;
+			q=0;
+			while(co[ijk]==0) if(!next_block()) return false;
+			return true;
+		}
+		/** Finds the next particle to test.
+		 * \return True if there is another particle, false if no more
+		 * particles are available. */
+		inline bool inc() {
+			q++;
+			if(q>=co[ijk]) {
+				q=0;
+				do {
+					if(!next_block()) return false;
+				} while(co[ijk]==0);
+			}
+			return true;
+		}
+	private:
+		/** The lower y index (inclusive) of the primary domain within
+		 * the block structure. */
+		int ey;
+		/** The lower y index (inclusive) of the primary domain within
+		 * the block structure. */
+		int ez;
+		/** The upper y index (exclusive) of the primary domain within
+		 * the block structure. */
+		int wy;
+		/** The upper z index (exclusive) of the primary domain within
+		 * the block structure. */
+		int wz;
+		/** The index of the (0,0,0) block within the block structure.
+		 */
+		int ijk0;
+		/** A value to increase ijk by when the z index is increased.
+		 */
+		int inc2;
+		/** Updates the internal variables to find the next
+		 * computational block with any particles.
+		 * \return True if another block is found, false if there are
+		 * no more blocks. */
+		inline bool next_block() {
+			i++;
+			if(i==nx) {
+				i=0;j++;
+				if(j==wy) {
+					j=ey;k++;
+					if(k==wz) return false;
+					ijk+=inc2;
+				} else ijk++;
+			} else ijk++;
+			return true;
+		}
+};
+
+/** \brief Class for looping over all of the particles specified in a
+ * pre-assembled particle_order class, for use with container_periodic classes.
+ *
+ * The particle_order class can be used to create a specific order of particles
+ * within the container. This class can then loop over these particles in this
+ * order. The class is particularly useful in cases where the ordering of the
+ * output must match the ordering of particles as they were inserted into the
+ * container. */
+class c_loop_order_periodic : public c_loop_base {
+	public:
+		/** A reference to the ordering class to use. */
+		particle_order &vo;
+		/** A pointer to the current position in the ordering class. */
+		int *cp;
+		/** A pointer to the end position in the ordering class. */
+		int *op;
+		/** The constructor copies several necessary constants from the
+		 * base class, and sets up a reference to the ordering class to
+		 * use.
+		 * \param[in] con the container class to use.
+		 * \param[in] vo_ the ordering class to use. */
+		template<class c_class>
+		c_loop_order_periodic(c_class &con,particle_order &vo_)
+		: c_loop_base(con), vo(vo_), nx(con.nx), oxy(con.nx*con.oy) {}
+		/** Sets the class to consider the first particle.
+		 * \return True if there is any particle to consider, false
+		 * otherwise. */
+		inline bool start() {
+			cp=vo.o;op=vo.op;
+			if(cp!=op) {
+				ijk=*(cp++);decode();
+				q=*(cp++);
+				return true;
+			} else return false;
+		}
+		/** Finds the next particle to test.
+		 * \return True if there is another particle, false if no more
+		 * particles are available. */
+		inline bool inc() {
+			if(cp==op) return false;
+			ijk=*(cp++);decode();
+			q=*(cp++);
+			return true;
+		}
+	private:
+		/** The number of computational blocks in the x direction. */
+		const int nx;
+		/** The number of computational blocks in a z-slice. */
+		const int oxy;
+		/** Takes the current block index and computes indices in the
+		 * x, y, and z directions. */
+		inline void decode() {
+			k=ijk/oxy;
+			int ijkt=ijk-oxy*k;
+			j=ijkt/nx;
+			i=ijkt-j*nx;
+		}
+};
+
+}
+
+#endif
diff -ru --new-file blender-2.76b.old/extern/voro++/src/cmd_line.cc blender-2.76b/extern/voro++/src/cmd_line.cc
--- blender-2.76b.old/extern/voro++/src/cmd_line.cc	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/cmd_line.cc	2016-01-27 19:01:36.538213015 +0300
@@ -0,0 +1,497 @@
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \file cmd_line.cc
+ * \brief Source code for the command-line utility. */
+
+#include <cstring>
+
+#include "voro++.hh"
+using namespace voro;
+
+enum blocks_mode {
+	none,
+	length_scale,
+	specified
+};
+
+// A maximum allowed number of regions, to prevent enormous amounts of memory
+// being allocated
+const int max_regions=16777216;
+
+// This message gets displayed if the user requests the help flag
+void help_message() {
+	puts("Voro++ version 0.4.5, by Chris H. Rycroft (UC Berkeley/LBL)\n\n"
+	     "Syntax: voro++ [options] <x_min> <x_max> <y_min>\n"
+	     "               <y_max> <z_min> <z_max> <filename>\n\n"
+	     "By default, the utility reads in the input file of particle IDs and positions,\n"
+	     "computes the Voronoi cell for each, and then creates <filename.vol> with an\n"
+	     "additional column containing the volume of each Voronoi cell.\n\n"
+	     "Available options:\n"
+	     " -c <str>   : Specify a custom output string\n"
+	     " -g         : Turn on the gnuplot output to <filename.gnu>\n"
+	     " -h/--help  : Print this information\n"
+	     " -hc        : Print information about custom output\n"
+	     " -l <len>   : Manually specify a length scale to configure the internal\n"
+	     "              computational grid\n"
+	     " -m <mem>   : Manually choose the memory allocation per grid block\n"
+	     "              (default 8)\n"
+	     " -n [3]     : Manually specify the internal grid size\n"
+	     " -o         : Ensure that the output file has the same order as the input\n"
+	     "              file\n"
+	     " -p         : Make container periodic in all three directions\n"
+	     " -px        : Make container periodic in the x direction\n"
+	     " -py        : Make container periodic in the y direction\n"
+	     " -pz        : Make container periodic in the z direction\n"
+	     " -r         : Assume the input file has an extra coordinate for radii\n"
+	     " -v         : Verbose output\n"
+	     " --version  : Print version information\n"
+	     " -wb [6]    : Add six plane wall objects to make rectangular box containing\n"
+	     "              the space x1<x<x2, x3<y<x4, x5<z<x6\n"
+	     " -wc [7]    : Add a cylinder wall object, centered on (x1,x2,x3),\n"
+	     "              pointing in (x4,x5,x6), radius x7\n"
+	     " -wo [7]    : Add a conical wall object, apex at (x1,x2,x3), axis\n"
+	     "              along (x4,x5,x6), angle x7 in radians\n"
+	     " -ws [4]    : Add a sphere wall object, centered on (x1,x2,x3),\n"
+	     "              with radius x4\n"
+	     " -wp [4]    : Add a plane wall object, with normal (x1,x2,x3),\n"
+	     "              and displacement x4\n"
+	     " -y         : Save POV-Ray particles to <filename_p.pov> and POV-Ray Voronoi\n"
+	     "              cells to <filename_v.pov>\n"
+	     " -yp        : Save only POV-Ray particles to <filename_p.pov>\n"
+	     " -yv        : Save only POV-Ray Voronoi cells to <filename_v.pov>");
+}
+
+// This message gets displayed if the user requests information about doing
+// custom output
+void custom_output_message() {
+	puts("The \"-c\" option allows a string to be specified that will customize the output\n"
+	     "file to contain a variety of statistics about each computed Voronoi cell. The\n"
+	     "string is similar to the standard C printf() function, made up of text with\n"
+	     "additional control sequences that begin with percentage signs that are expanded\n"
+	     "to different statistics. See http://math.lbl.gov/voro++/doc/custom.html for more\n"
+	     "information.\n"
+	     "\nParticle-related:\n"
+	     "  %i The particle ID number\n"
+	     "  %x The x coordinate of the particle\n"
+	     "  %y The y coordinate of the particle\n"
+	     "  %z The z coordinate of the particle\n"
+	     "  %q The position vector of the particle, short for \"%x %y %z\"\n"
+	     "  %r The radius of the particle (only printed if -p enabled)\n"
+	     "\nVertex-related:\n"
+	     "  %w The number of vertices in the Voronoi cell\n"
+	     "  %p A list of the vertices of the Voronoi cell in the format (x,y,z),\n"
+	     "     relative to the particle center\n"
+	     "  %P A list of the vertices of the Voronoi cell in the format (x,y,z),\n"
+	     "     relative to the global coordinate system\n"
+	     "  %o A list of the orders of each vertex\n"
+	     "  %m The maximum radius squared of a vertex position, relative to the\n"
+	     "     particle center\n"
+	     "\nEdge-related:\n"
+	     "  %g The number of edges of the Voronoi cell\n"
+	     "  %E The total edge distance\n"
+	     "  %e A list of perimeters of each face\n"
+	     "\nFace-related:\n"
+	     "  %s The number of faces of the Voronoi cell\n"
+	     "  %F The total surface area of the Voronoi cell\n"
+	     "  %A A frequency table of the number of edges for each face\n"
+	     "  %a A list of the number of edges for each face\n"
+	     "  %f A list of areas of each face\n"
+	     "  %t A list of bracketed sequences of vertices that make up each face\n"
+	     "  %l A list of normal vectors for each face\n"
+	     "  %n A list of neighboring particle or wall IDs corresponding to each face\n"
+	     "\nVolume-related:\n"
+	     "  %v The volume of the Voronoi cell\n"
+	     "  %c The centroid of the Voronoi cell, relative to the particle center\n"
+	     "  %C The centroid of the Voronoi cell, in the global coordinate system");
+}
+
+// Ths message is displayed if the user requests version information
+void version_message() {
+	puts("Voro++ version 0.4.5 (July 27th 2012)");
+}
+
+// Prints an error message. This is called when the program is unable to make
+// sense of the command-line options.
+void error_message() {
+	fputs("voro++: Unrecognized command-line options; type \"voro++ -h\" for more\ninformation.\n",stderr);
+}
+
+// Carries out the Voronoi computation and outputs the results to the requested
+// files
+template<class c_loop,class c_class>
+void cmd_line_output(c_loop &vl,c_class &con,const char* format,FILE* outfile,FILE* gnu_file,FILE* povp_file,FILE* povv_file,bool verbose,double &vol,int &vcc,int &tp) {
+	int pid,ps=con.ps;double x,y,z,r;
+	if(con.contains_neighbor(format)) {
+		voronoicell_neighbor c;
+		if(vl.start()) do if(con.compute_cell(c,vl)) {
+			vl.pos(pid,x,y,z,r);
+			if(outfile!=NULL) c.output_custom(format,pid,x,y,z,r,outfile);
+			if(gnu_file!=NULL) c.draw_gnuplot(x,y,z,gnu_file);
+			if(povp_file!=NULL) {
+				fprintf(povp_file,"// id %d\n",pid);
+				if(ps==4) fprintf(povp_file,"sphere{<%g,%g,%g>,%g}\n",x,y,z,r);
+				else fprintf(povp_file,"sphere{<%g,%g,%g>,s}\n",x,y,z);
+			}
+			if(povv_file!=NULL) {
+				fprintf(povv_file,"// cell %d\n",pid);
+				c.draw_pov(x,y,z,povv_file);
+			}
+			if(verbose) {vol+=c.volume();vcc++;}
+		} while(vl.inc());
+	} else {
+		voronoicell c;
+		if(vl.start()) do if(con.compute_cell(c,vl)) {
+			vl.pos(pid,x,y,z,r);
+			if(outfile!=NULL) c.output_custom(format,pid,x,y,z,r,outfile);
+			if(gnu_file!=NULL) c.draw_gnuplot(x,y,z,gnu_file);
+			if(povp_file!=NULL) {
+				fprintf(povp_file,"// id %d\n",pid);
+				if(ps==4) fprintf(povp_file,"sphere{<%g,%g,%g>,%g}\n",x,y,z,r);
+				else fprintf(povp_file,"sphere{<%g,%g,%g>,s}\n",x,y,z);
+			}
+			if(povv_file!=NULL) {
+				fprintf(povv_file,"// cell %d\n",pid);
+				c.draw_pov(x,y,z,povv_file);
+			}
+			if(verbose) {vol+=c.volume();vcc++;}
+		} while(vl.inc());
+	}
+	if(verbose) tp=con.total_particles();
+}
+
+int main(int argc,char **argv) {
+	int i=1,j=-7,custom_output=0,nx,ny,nz,init_mem(8);
+	double ls=0;
+	blocks_mode bm=none;
+	bool gnuplot_output=false,povp_output=false,povv_output=false,polydisperse=false;
+	bool xperiodic=false,yperiodic=false,zperiodic=false,ordered=false,verbose=false;
+	pre_container *pcon=NULL;pre_container_poly *pconp=NULL;
+	wall_list wl;
+
+	// If there's one argument, check to see if it's requesting help.
+	// Otherwise, bail out with an error.
+	if(argc==2) {
+		if(strcmp(argv[1],"-h")==0||strcmp(argv[1],"--help")==0) {
+			help_message();return 0;
+		} else if(strcmp(argv[1],"-hc")==0) {
+			custom_output_message();return 0;
+		} else if(strcmp(argv[1],"--version")==0) {
+			version_message();return 0;
+		} else {
+			error_message();
+			return VOROPP_CMD_LINE_ERROR;
+		}
+	}
+
+	// If there aren't enough command-line arguments, then bail out
+	// with an error.
+	if(argc<7) {
+	       error_message();
+	       return VOROPP_CMD_LINE_ERROR;
+	}
+
+	// We have enough arguments. Now start searching for command-line
+	// options.
+	while(i<argc-7) {
+		if(strcmp(argv[i],"-c")==0) {
+			if(i>=argc-8) {error_message();wl.deallocate();return VOROPP_CMD_LINE_ERROR;}
+			if(custom_output==0) {
+				custom_output=++i;
+			} else {
+				fputs("voro++: multiple custom output strings detected\n",stderr);
+				wl.deallocate();
+				return VOROPP_CMD_LINE_ERROR;
+			}
+		} else if(strcmp(argv[i],"-g")==0) {
+			gnuplot_output=true;
+		} else if(strcmp(argv[i],"-h")==0||strcmp(argv[i],"--help")==0) {
+			help_message();wl.deallocate();return 0;
+		} else if(strcmp(argv[i],"-hc")==0) {
+			custom_output_message();wl.deallocate();return 0;
+		} else if(strcmp(argv[i],"-l")==0) {
+			if(i>=argc-8) {error_message();wl.deallocate();return VOROPP_CMD_LINE_ERROR;}
+			if(bm!=none) {
+				fputs("voro++: Conflicting options about grid setup (-l/-n)\n",stderr);
+				wl.deallocate();
+				return VOROPP_CMD_LINE_ERROR;
+			}
+			bm=length_scale;
+			i++;ls=atof(argv[i]);
+		} else if(strcmp(argv[i],"-m")==0) {
+			i++;init_mem=atoi(argv[i]);
+		} else if(strcmp(argv[i],"-n")==0) {
+			if(i>=argc-10) {error_message();wl.deallocate();return VOROPP_CMD_LINE_ERROR;}
+			if(bm!=none) {
+				fputs("voro++: Conflicting options about grid setup (-l/-n)\n",stderr);
+				wl.deallocate();
+				return VOROPP_CMD_LINE_ERROR;
+			}
+			bm=specified;
+			i++;
+			nx=atoi(argv[i++]);
+			ny=atoi(argv[i++]);
+			nz=atoi(argv[i]);
+			if(nx<=0||ny<=0||nz<=0) {
+				fputs("voro++: Computational grid specified with -n must be greater than one\n"
+				      "in each direction\n",stderr);
+				wl.deallocate();
+				return VOROPP_CMD_LINE_ERROR;
+			}
+		} else if(strcmp(argv[i],"-o")==0) {
+			ordered=true;
+		} else if(strcmp(argv[i],"-p")==0) {
+			xperiodic=yperiodic=zperiodic=true;
+		} else if(strcmp(argv[i],"-px")==0) {
+			xperiodic=true;
+		} else if(strcmp(argv[i],"-py")==0) {
+			yperiodic=true;
+		} else if(strcmp(argv[i],"-pz")==0) {
+			zperiodic=true;
+		} else if(strcmp(argv[i],"-r")==0) {
+			polydisperse=true;
+		} else if(strcmp(argv[i],"-v")==0) {
+			verbose=true;
+		} else if(strcmp(argv[i],"--version")==0) {
+			version_message();
+			wl.deallocate();
+			return 0;
+		} else if(strcmp(argv[i],"-wb")==0) {
+			if(i>=argc-13) {error_message();wl.deallocate();return VOROPP_CMD_LINE_ERROR;}
+			i++;
+			double w0=atof(argv[i++]),w1=atof(argv[i++]);
+			double w2=atof(argv[i++]),w3=atof(argv[i++]);
+			double w4=atof(argv[i++]),w5=atof(argv[i]);
+			wl.add_wall(new wall_plane(-1,0,0,-w0,j));j--;			
+			wl.add_wall(new wall_plane(1,0,0,w1,j));j--;			
+			wl.add_wall(new wall_plane(0,-1,0,-w2,j));j--;			
+			wl.add_wall(new wall_plane(0,1,0,w3,j));j--;			
+			wl.add_wall(new wall_plane(0,0,-1,-w4,j));j--;			
+			wl.add_wall(new wall_plane(0,0,1,w5,j));j--;			
+		} else if(strcmp(argv[i],"-ws")==0) {
+			if(i>=argc-11) {error_message();wl.deallocate();return VOROPP_CMD_LINE_ERROR;}
+			i++;
+			double w0=atof(argv[i++]),w1=atof(argv[i++]);
+			double w2=atof(argv[i++]),w3=atof(argv[i]);
+			wl.add_wall(new wall_sphere(w0,w1,w2,w3,j));
+			j--;
+		} else if(strcmp(argv[i],"-wp")==0) {
+			if(i>=argc-11) {error_message();wl.deallocate();return VOROPP_CMD_LINE_ERROR;}
+			i++;
+			double w0=atof(argv[i++]),w1=atof(argv[i++]);
+			double w2=atof(argv[i++]),w3=atof(argv[i]);
+			wl.add_wall(new wall_plane(w0,w1,w2,w3,j));
+			j--;
+		} else if(strcmp(argv[i],"-wc")==0) {
+			if(i>=argc-14) {error_message();wl.deallocate();return VOROPP_CMD_LINE_ERROR;}
+			i++;
+			double w0=atof(argv[i++]),w1=atof(argv[i++]);
+			double w2=atof(argv[i++]),w3=atof(argv[i++]);
+			double w4=atof(argv[i++]),w5=atof(argv[i++]);
+			double w6=atof(argv[i]);
+			wl.add_wall(new wall_cylinder(w0,w1,w2,w3,w4,w5,w6,j));
+			j--;
+		} else if(strcmp(argv[i],"-wo")==0) {
+			if(i>=argc-14) {error_message();wl.deallocate();return VOROPP_CMD_LINE_ERROR;}
+			i++;
+			double w0=atof(argv[i++]),w1=atof(argv[i++]);
+			double w2=atof(argv[i++]),w3=atof(argv[i++]);
+			double w4=atof(argv[i++]),w5=atof(argv[i++]);
+			double w6=atof(argv[i]);
+			wl.add_wall(new wall_cone(w0,w1,w2,w3,w4,w5,w6,j));
+			j--;
+		} else if(strcmp(argv[i],"-y")==0) {
+			povp_output=povv_output=true;
+		} else if(strcmp(argv[i],"-yp")==0) {
+			povp_output=true;
+		} else if(strcmp(argv[i],"-yv")==0) {
+			povv_output=true;
+		} else {
+			wl.deallocate();
+			error_message();
+			return VOROPP_CMD_LINE_ERROR;
+		}
+		i++;
+	}
+
+	// Check the memory guess is positive
+	if(init_mem<=0) {
+		fputs("voro++: The memory allocation must be positive\n",stderr);
+		wl.deallocate();
+		return VOROPP_CMD_LINE_ERROR;
+	}
+
+	// Read in the dimensions of the test box, and estimate the number of
+	// boxes to divide the region up into
+	double ax=atof(argv[i]),bx=atof(argv[i+1]);
+	double ay=atof(argv[i+2]),by=atof(argv[i+3]);
+	double az=atof(argv[i+4]),bz=atof(argv[i+5]);
+
+	// Check that for each coordinate, the minimum value is smaller
+	// than the maximum value
+	if(bx<ax) {
+		fputs("voro++: Minimum x coordinate exceeds maximum x coordinate\n",stderr);
+		wl.deallocate();
+		return VOROPP_CMD_LINE_ERROR;
+	}
+	if(by<ay) {
+		fputs("voro++: Minimum y coordinate exceeds maximum y coordinate\n",stderr);
+		wl.deallocate();
+		return VOROPP_CMD_LINE_ERROR;
+	}
+	if(bz<az) {
+		fputs("voro++: Minimum z coordinate exceeds maximum z coordinate\n",stderr);
+		wl.deallocate();
+		return VOROPP_CMD_LINE_ERROR;
+	}
+
+	if(bm==none) {
+		if(polydisperse) {
+			pconp=new pre_container_poly(ax,bx,ay,by,az,bz,xperiodic,yperiodic,zperiodic);
+			pconp->import(argv[i+6]);
+			pconp->guess_optimal(nx,ny,nz);
+		} else {
+			pcon=new pre_container(ax,bx,ay,by,az,bz,xperiodic,yperiodic,zperiodic);
+			pcon->import(argv[i+6]);
+			pcon->guess_optimal(nx,ny,nz);
+		}
+	} else {
+		double nxf,nyf,nzf;
+		if(bm==length_scale) {
+
+			// Check that the length scale is positive and
+			// reasonably large
+			if(ls<tolerance) {
+				fputs("voro++: ",stderr);
+				if(ls<0) {
+					fputs("The length scale must be positive\n",stderr);
+				} else {
+					fprintf(stderr,"The length scale is smaller than the safe limit of %g. Either\nincrease the particle length scale, or recompile with a different limit.\n",tolerance);
+				}
+				wl.deallocate();
+				return VOROPP_CMD_LINE_ERROR;
+			}
+			ls=0.6/ls;
+			nxf=(bx-ax)*ls+1;
+			nyf=(by-ay)*ls+1;
+			nzf=(bz-az)*ls+1;
+
+			nx=int(nxf);ny=int(nyf);nz=int(nzf);
+		} else {
+			nxf=nx;nyf=ny;nzf=nz;
+		}
+
+		// Compute the number regions based on the length scale
+		// provided. If the total number exceeds a cutoff then bail
+		// out, to prevent making a massive memory allocation. Do this
+		// test using floating point numbers, since huge integers could
+		// potentially wrap around to negative values.
+		if(nxf*nyf*nzf>max_regions) {
+			fprintf(stderr,"voro++: Number of computational blocks exceeds the maximum allowed of %d.\n"
+				       "Either increase the particle length scale, or recompile with an increased\nmaximum.",max_regions);
+			wl.deallocate();
+			return VOROPP_MEMORY_ERROR;
+		}
+	}
+
+	// Check that the output filename is a sensible length
+	int flen=strlen(argv[i+6]);
+	if(flen>4096) {
+		fputs("voro++: Filename too long\n",stderr);
+		wl.deallocate();
+		return VOROPP_CMD_LINE_ERROR;
+	}
+
+	// Open files for output
+	char *buffer=new char[flen+7];
+	sprintf(buffer,"%s.vol",argv[i+6]);
+	FILE *outfile=safe_fopen(buffer,"w"),*gnu_file,*povp_file,*povv_file;
+	if(gnuplot_output) {
+		sprintf(buffer,"%s.gnu",argv[i+6]);
+		gnu_file=safe_fopen(buffer,"w");
+	} else gnu_file=NULL;
+	if(povp_output) {
+		sprintf(buffer,"%s_p.pov",argv[i+6]);
+		povp_file=safe_fopen(buffer,"w");
+	} else povp_file=NULL;
+	if(povv_output) {
+		sprintf(buffer,"%s_v.pov",argv[i+6]);
+		povv_file=safe_fopen(buffer,"w");
+	} else povv_file=NULL;
+	delete [] buffer;
+
+	const char *c_str=(custom_output==0?(polydisperse?"%i %q %v %r":"%i %q %v"):argv[custom_output]);
+
+	// Now switch depending on whether polydispersity was enabled, and
+	// whether output ordering is requested
+	double vol=0;int tp=0,vcc=0;
+	if(polydisperse) {
+		if(ordered) {
+			particle_order vo;
+			container_poly con(ax,bx,ay,by,az,bz,nx,ny,nz,xperiodic,yperiodic,zperiodic,init_mem);
+			con.add_wall(wl);
+			if(bm==none) {
+				pconp->setup(vo,con);delete pconp;
+			} else con.import(vo,argv[i+6]);
+
+			c_loop_order vlo(con,vo);
+			cmd_line_output(vlo,con,c_str,outfile,gnu_file,povp_file,povv_file,verbose,vol,vcc,tp);
+		} else {
+			container_poly con(ax,bx,ay,by,az,bz,nx,ny,nz,xperiodic,yperiodic,zperiodic,init_mem);
+			con.add_wall(wl);
+
+			if(bm==none) {
+				pconp->setup(con);delete pconp;
+			} else con.import(argv[i+6]);
+
+			c_loop_all vla(con);
+			cmd_line_output(vla,con,c_str,outfile,gnu_file,povp_file,povv_file,verbose,vol,vcc,tp);
+		}
+	} else {
+		if(ordered) {
+			particle_order vo;
+			container con(ax,bx,ay,by,az,bz,nx,ny,nz,xperiodic,yperiodic,zperiodic,init_mem);
+			con.add_wall(wl);
+			if(bm==none) {
+				pcon->setup(vo,con);delete pcon;
+			} else con.import(vo,argv[i+6]);
+
+			c_loop_order vlo(con,vo);
+			cmd_line_output(vlo,con,c_str,outfile,gnu_file,povp_file,povv_file,verbose,vol,vcc,tp);
+		} else {
+			container con(ax,bx,ay,by,az,bz,nx,ny,nz,xperiodic,yperiodic,zperiodic,init_mem);
+			con.add_wall(wl);
+			if(bm==none) {
+				pcon->setup(con);delete pcon;
+			} else con.import(argv[i+6]);
+			c_loop_all vla(con);
+			cmd_line_output(vla,con,c_str,outfile,gnu_file,povp_file,povv_file,verbose,vol,vcc,tp);
+		}
+	}
+
+	// Print information if verbose output requested
+	if(verbose) {
+		printf("Container geometry        : [%g:%g] [%g:%g] [%g:%g]\n"
+		       "Computational grid size   : %d by %d by %d (%s)\n"
+		       "Filename                  : %s\n"
+		       "Output string             : %s%s\n",ax,bx,ay,by,az,bz,nx,ny,nz,
+		       bm==none?"estimated from file":(bm==length_scale?
+		       "estimated using length scale":"directly specified"),
+		       argv[i+6],c_str,custom_output==0?" (default)":"");
+		printf("Total imported particles  : %d (%.2g per grid block)\n"
+		       "Total V. cells computed   : %d\n"
+		       "Total container volume    : %g\n"
+		       "Total V. cell volume      : %g\n",tp,((double) tp)/(nx*ny*nz),
+		       vcc,(bx-ax)*(by-ay)*(bz-az),vol);
+	}
+			   
+	// Close output files
+	fclose(outfile);
+	if(gnu_file!=NULL) fclose(gnu_file);
+	if(povp_file!=NULL) fclose(povp_file);
+	if(povv_file!=NULL) fclose(povv_file);
+	return 0;
+}
diff -ru --new-file blender-2.76b.old/extern/voro++/src/common.cc blender-2.76b/extern/voro++/src/common.cc
--- blender-2.76b.old/extern/voro++/src/common.cc	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/common.cc	2016-01-27 19:02:29.712817468 +0300
@@ -0,0 +1,90 @@
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \file common.cc
+ * \brief Implementations of the small helper functions. */
+
+#include "common.hh"
+
+namespace voro {
+
+/** \brief Prints a vector of integers.
+ *
+ * Prints a vector of integers.
+ * \param[in] v the vector to print.
+ * \param[in] fp the file stream to print to. */
+void voro_print_vector(std::vector<int> &v,FILE *fp) {
+	int k=0,s=v.size();
+	while(k+4<s) {
+		fprintf(fp,"%d %d %d %d ",v[k],v[k+1],v[k+2],v[k+3]);
+		k+=4;
+	}
+	if(k+3<=s) {
+		if(k+4==s) fprintf(fp,"%d %d %d %d",v[k],v[k+1],v[k+2],v[k+3]);
+		else fprintf(fp,"%d %d %d",v[k],v[k+1],v[k+2]);
+	} else {
+		if(k+2==s) fprintf(fp,"%d %d",v[k],v[k+1]);
+		else fprintf(fp,"%d",v[k]);
+	}
+}
+
+/** \brief Prints a vector of doubles.
+ *
+ * Prints a vector of doubles.
+ * \param[in] v the vector to print.
+ * \param[in] fp the file stream to print to. */
+void voro_print_vector(std::vector<double> &v,FILE *fp) {
+	int k=0,s=v.size();
+	while(k+4<s) {
+		fprintf(fp,"%g %g %g %g ",v[k],v[k+1],v[k+2],v[k+3]);
+		k+=4;
+	}
+	if(k+3<=s) {
+		if(k+4==s) fprintf(fp,"%g %g %g %g",v[k],v[k+1],v[k+2],v[k+3]);
+		else fprintf(fp,"%g %g %g",v[k],v[k+1],v[k+2]);
+	} else {
+		if(k+2==s) fprintf(fp,"%g %g",v[k],v[k+1]);
+		else fprintf(fp,"%g",v[k]);
+	}
+}
+
+/** \brief Prints a vector a face vertex information.
+ *
+ * Prints a vector of face vertex information. A value is read, which
+ * corresponds to the number of vertices in the next face. The routine reads
+ * this number of values and prints them as a bracked list. This is repeated
+ * until the end of the vector is reached.
+ * \param[in] v the vector to interpret and print.
+ * \param[in] fp the file stream to print to. */
+void voro_print_face_vertices(std::vector<int> &v,FILE *fp) {
+	int j,k=0,l;
+	if(v.size()>0) {
+		l=v[k++];
+		if(l<=1) {
+			if(l==1) fprintf(fp,"(%d)",v[k++]);
+			else fputs("()",fp);
+		} else {
+			j=k+l;
+			fprintf(fp,"(%d",v[k++]);
+			while(k<j) fprintf(fp,",%d",v[k++]);
+			fputs(")",fp);
+		}
+		while((unsigned int) k<v.size()) {
+			l=v[k++];
+			if(l<=1) {
+				if(l==1) fprintf(fp," (%d)",v[k++]);
+				else fputs(" ()",fp);
+			} else {
+				j=k+l;
+				fprintf(fp," (%d",v[k++]);
+				while(k<j) fprintf(fp,",%d",v[k++]);
+				fputs(")",fp);
+			}
+		}
+	}
+}
+
+}
diff -ru --new-file blender-2.76b.old/extern/voro++/src/common.hh blender-2.76b/extern/voro++/src/common.hh
--- blender-2.76b.old/extern/voro++/src/common.hh	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/common.hh	2016-01-27 19:02:04.882002162 +0300
@@ -0,0 +1,67 @@
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \file common.hh
+ * \brief Header file for the small helper functions. */
+
+#ifndef VOROPP_COMMON_HH
+#define VOROPP_COMMON_HH
+
+#include <cstdio>
+#include <cstdlib>
+#include <vector>
+
+#include "config.hh"
+
+namespace voro {
+
+/** \brief Function for printing fatal error messages and exiting.
+ *
+ * Function for printing fatal error messages and exiting.
+ * \param[in] p a pointer to the message to print.
+ * \param[in] status the status code to return with. */
+inline void voro_fatal_error(const char *p,int status) {
+	fprintf(stderr,"voro++: %s\n",p);
+	exit(status);
+}
+
+/** \brief Prints a vector of positions.
+ *
+ * Prints a vector of positions as bracketed triplets.
+ * \param[in] v the vector to print.
+ * \param[in] fp the file stream to print to. */
+inline void voro_print_positions(std::vector<double> &v,FILE *fp=stdout) {
+	if(v.size()>0) {
+		fprintf(fp,"(%g,%g,%g)",v[0],v[1],v[2]);
+		for(int k=3;(unsigned int) k<v.size();k+=3) {
+			fprintf(fp," (%g,%g,%g)",v[k],v[k+1],v[k+2]);
+		}
+	}
+}
+
+/** \brief Opens a file and checks the operation was successful.
+ *
+ * Opens a file, and checks the return value to ensure that the operation
+ * was successful.
+ * \param[in] filename the file to open.
+ * \param[in] mode the cstdio fopen mode to use.
+ * \return The file handle. */
+inline FILE* safe_fopen(const char *filename,const char *mode) {
+	FILE *fp=fopen(filename,mode);
+	if(fp==NULL) {
+		fprintf(stderr,"voro++: Unable to open file '%s'\n",filename);
+		exit(VOROPP_FILE_ERROR);
+	}
+	return fp;
+}
+
+void voro_print_vector(std::vector<int> &v,FILE *fp=stdout);
+void voro_print_vector(std::vector<double> &v,FILE *fp=stdout);
+void voro_print_face_vertices(std::vector<int> &v,FILE *fp=stdout);
+
+}
+
+#endif
diff -ru --new-file blender-2.76b.old/extern/voro++/src/config.hh blender-2.76b/extern/voro++/src/config.hh
--- blender-2.76b.old/extern/voro++/src/config.hh	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/config.hh	2016-01-27 19:02:57.497610830 +0300
@@ -0,0 +1,127 @@
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \file config.hh
+ * \brief Master configuration file for setting various compile-time options. */
+
+#ifndef VOROPP_CONFIG_HH
+#define VOROPP_CONFIG_HH
+
+namespace voro {
+
+// These constants set the initial memory allocation for the Voronoi cell
+/** The initial memory allocation for the number of vertices. */
+const int init_vertices=256;
+/** The initial memory allocation for the maximum vertex order. */
+const int init_vertex_order=64;
+/** The initial memory allocation for the number of regular vertices of order
+ * 3. */
+const int init_3_vertices=256;
+/** The initial memory allocation for the number of vertices of higher order.
+ */
+const int init_n_vertices=8;
+/** The initial buffer size for marginal cases used by the suretest class. */
+const int init_marginal=64;
+/** The initial size for the delete stack. */
+const int init_delete_size=256;
+/** The initial size for the auxiliary delete stack. */
+const int init_delete2_size=256;
+/** The initial size for the wall pointer array. */
+const int init_wall_size=32;
+/** The default initial size for the ordering class. */
+const int init_ordering_size=4096;
+/** The initial size of the pre_container chunk index. */
+const int init_chunk_size=256;
+
+// If the initial memory is too small, the program dynamically allocates more.
+// However, if the limits below are reached, then the program bails out.
+/** The maximum memory allocation for the number of vertices. */
+const int max_vertices=16777216;
+/** The maximum memory allocation for the maximum vertex order. */
+const int max_vertex_order=2048;
+/** The maximum memory allocation for the any particular order of vertex. */
+const int max_n_vertices=16777216;
+/** The maximum buffer size for marginal cases used by the suretest class. */
+const int max_marginal=16777216;
+/** The maximum size for the delete stack. */
+const int max_delete_size=16777216;
+/** The maximum size for the auxiliary delete stack. */
+const int max_delete2_size=16777216;
+/** The maximum amount of particle memory allocated for a single region. */
+const int max_particle_memory=16777216;
+/** The maximum size for the wall pointer array. */
+const int max_wall_size=2048;
+/** The maximum size for the ordering class. */
+const int max_ordering_size=67108864;
+/** The maximum size for the pre_container chunk index. */
+const int max_chunk_size=65536;
+
+/** The chunk size in the pre_container classes. */
+const int pre_container_chunk_size=1024;
+
+#ifndef VOROPP_VERBOSE
+/** Voro++ can print a number of different status and debugging messages to
+ * notify the user of special behavior, and this macro sets the amount which
+ * are displayed. At level 0, no messages are printed. At level 1, messages
+ * about unusual cases during cell construction are printed, such as when the
+ * plane routine bails out due to floating point problems. At level 2, general
+ * messages about memory expansion are printed. At level 3, technical details
+ * about memory management are printed. */
+#define VOROPP_VERBOSE 0
+#endif
+
+/** If a point is within this distance of a cutting plane, then the code
+ * assumes that point exactly lies on the plane. */
+const double tolerance=1e-11;
+
+/** If a point is within this distance of a cutting plane, then the code stores
+ * whether this point is inside, outside, or exactly on the cutting plane in
+ * the marginal cases buffer, to prevent the test giving a different result on
+ * a subsequent evaluation due to floating point rounding errors. */
+const double tolerance2=2e-11;
+
+/** The square of the tolerance, used when deciding whether some squared
+ * quantities are large enough to be used. */
+const double tolerance_sq=tolerance*tolerance;
+
+/** A large number that is used in the computation. */
+const double large_number=1e30;
+
+/** A radius to use as a placeholder when no other information is available. */
+const double default_radius=0.5;
+
+/** The maximum number of shells of periodic images to test over. */
+const int max_unit_voro_shells=10;
+
+/** A guess for the optimal number of particles per block, used to set up the
+ * container grid. */
+const double optimal_particles=5.6;
+
+/** If this is set to 1, then the code reports any instances of particles being
+ * put outside of the container geometry. */
+#define VOROPP_REPORT_OUT_OF_BOUNDS 0
+
+/** Voro++ returns this status code if there is a file-related error, such as
+ * not being able to open file. */
+#define VOROPP_FILE_ERROR 1
+
+/** Voro++ returns this status code if there is a memory allocation error, if
+ * one of the safe memory limits is exceeded. */
+#define VOROPP_MEMORY_ERROR 2
+
+/** Voro++ returns this status code if there is any type of internal error, if
+ * it detects that representation of the Voronoi cell is inconsistent. This
+ * status code will generally indicate a bug, and the developer should be
+ * contacted. */
+#define VOROPP_INTERNAL_ERROR 3
+
+/** Voro++ returns this status code if it could not interpret the command line
+ * arguments passed to the command line utility. */
+#define VOROPP_CMD_LINE_ERROR 4
+
+}
+
+#endif
diff -ru --new-file blender-2.76b.old/extern/voro++/src/container.cc blender-2.76b/extern/voro++/src/container.cc
--- blender-2.76b.old/extern/voro++/src/container.cc	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/container.cc	2016-01-27 19:04:20.703992187 +0300
@@ -0,0 +1,549 @@
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \file container.cc
+ * \brief Function implementations for the container and related classes. */
+
+#include "container.hh"
+
+namespace voro {
+
+/** The class constructor sets up the geometry of container, initializing the
+ * minimum and maximum coordinates in each direction, and setting whether each
+ * direction is periodic or not. It divides the container into a rectangular
+ * grid of blocks, and allocates memory for each of these for storing particle
+ * positions and IDs.
+ * \param[in] (ax_,bx_) the minimum and maximum x coordinates.
+ * \param[in] (ay_,by_) the minimum and maximum y coordinates.
+ * \param[in] (az_,bz_) the minimum and maximum z coordinates.
+ * \param[in] (nx_,ny_,nz_) the number of grid blocks in each of the three
+ *			    coordinate directions.
+ * \param[in] (xperiodic_,yperiodic_,zperiodic_) flags setting whether the
+ *                                               container is periodic in each
+ *                                               coordinate direction.
+ * \param[in] init_mem the initial memory allocation for each block.
+ * \param[in] ps_ the number of floating point entries to store for each
+ *                particle. */
+container_base::container_base(double ax_,double bx_,double ay_,double by_,double az_,double bz_,
+		int nx_,int ny_,int nz_,bool xperiodic_,bool yperiodic_,bool zperiodic_,int init_mem,int ps_)
+	: voro_base(nx_,ny_,nz_,(bx_-ax_)/nx_,(by_-ay_)/ny_,(bz_-az_)/nz_),
+	ax(ax_), bx(bx_), ay(ay_), by(by_), az(az_), bz(bz_),
+	xperiodic(xperiodic_), yperiodic(yperiodic_), zperiodic(zperiodic_),
+	id(new int*[nxyz]), p(new double*[nxyz]), co(new int[nxyz]), mem(new int[nxyz]), ps(ps_) {
+	int l;
+	for(l=0;l<nxyz;l++) co[l]=0;
+	for(l=0;l<nxyz;l++) mem[l]=init_mem;
+	for(l=0;l<nxyz;l++) id[l]=new int[init_mem];
+	for(l=0;l<nxyz;l++) p[l]=new double[ps*init_mem];
+}
+
+/** The container destructor frees the dynamically allocated memory. */
+container_base::~container_base() {
+	int l;
+	for(l=0;l<nxyz;l++) delete [] p[l];
+	for(l=0;l<nxyz;l++) delete [] id[l];
+	delete [] id;
+	delete [] p;
+	delete [] co;
+	delete [] mem;
+}
+
+/** The class constructor sets up the geometry of container.
+ * \param[in] (ax_,bx_) the minimum and maximum x coordinates.
+ * \param[in] (ay_,by_) the minimum and maximum y coordinates.
+ * \param[in] (az_,bz_) the minimum and maximum z coordinates.
+ * \param[in] (nx_,ny_,nz_) the number of grid blocks in each of the three
+ *                       coordinate directions.
+ * \param[in] (xperiodic_,yperiodic_,zperiodic_) flags setting whether the
+ *                                               container is periodic in each
+ *                                               coordinate direction.
+ * \param[in] init_mem the initial memory allocation for each block. */
+container::container(double ax_,double bx_,double ay_,double by_,double az_,double bz_,
+	int nx_,int ny_,int nz_,bool xperiodic_,bool yperiodic_,bool zperiodic_,int init_mem)
+	: container_base(ax_,bx_,ay_,by_,az_,bz_,nx_,ny_,nz_,xperiodic_,yperiodic_,zperiodic_,init_mem,3),
+	vc(*this,xperiodic_?2*nx_+1:nx_,yperiodic_?2*ny_+1:ny_,zperiodic_?2*nz_+1:nz_) {}
+
+/** The class constructor sets up the geometry of container.
+ * \param[in] (ax_,bx_) the minimum and maximum x coordinates.
+ * \param[in] (ay_,by_) the minimum and maximum y coordinates.
+ * \param[in] (az_,bz_) the minimum and maximum z coordinates.
+ * \param[in] (nx_,ny_,nz_) the number of grid blocks in each of the three
+ *                       coordinate directions.
+ * \param[in] (xperiodic_,yperiodic_,zperiodic_) flags setting whether the
+ *                                               container is periodic in each
+ *                                               coordinate direction.
+ * \param[in] init_mem the initial memory allocation for each block. */
+container_poly::container_poly(double ax_,double bx_,double ay_,double by_,double az_,double bz_,
+	int nx_,int ny_,int nz_,bool xperiodic_,bool yperiodic_,bool zperiodic_,int init_mem)
+	: container_base(ax_,bx_,ay_,by_,az_,bz_,nx_,ny_,nz_,xperiodic_,yperiodic_,zperiodic_,init_mem,4),
+	vc(*this,xperiodic_?2*nx_+1:nx_,yperiodic_?2*ny_+1:ny_,zperiodic_?2*nz_+1:nz_) {ppr=p;}
+
+/** Put a particle into the correct region of the container.
+ * \param[in] n the numerical ID of the inserted particle.
+ * \param[in] (x,y,z) the position vector of the inserted particle. */
+void container::put(int n,double x,double y,double z) {
+	int ijk;
+	if(put_locate_block(ijk,x,y,z)) {
+		id[ijk][co[ijk]]=n;
+		double *pp=p[ijk]+3*co[ijk]++;
+		*(pp++)=x;*(pp++)=y;*pp=z;
+	}
+}
+
+/** Put a particle into the correct region of the container.
+ * \param[in] n the numerical ID of the inserted particle.
+ * \param[in] (x,y,z) the position vector of the inserted particle.
+ * \param[in] r the radius of the particle. */
+void container_poly::put(int n,double x,double y,double z,double r) {
+	int ijk;
+	if(put_locate_block(ijk,x,y,z)) {
+		id[ijk][co[ijk]]=n;
+		double *pp=p[ijk]+4*co[ijk]++;
+		*(pp++)=x;*(pp++)=y;*(pp++)=z;*pp=r;
+		if(max_radius<r) max_radius=r;
+	}
+}
+
+/** Put a particle into the correct region of the container, also recording
+ * into which region it was stored.
+ * \param[in] vo the ordering class in which to record the region.
+ * \param[in] n the numerical ID of the inserted particle.
+ * \param[in] (x,y,z) the position vector of the inserted particle. */
+void container::put(particle_order &vo,int n,double x,double y,double z) {
+	int ijk;
+	if(put_locate_block(ijk,x,y,z)) {
+		id[ijk][co[ijk]]=n;
+		vo.add(ijk,co[ijk]);
+		double *pp=p[ijk]+3*co[ijk]++;
+		*(pp++)=x;*(pp++)=y;*pp=z;
+	}
+}
+
+/** Put a particle into the correct region of the container, also recording
+ * into which region it was stored.
+ * \param[in] vo the ordering class in which to record the region.
+ * \param[in] n the numerical ID of the inserted particle.
+ * \param[in] (x,y,z) the position vector of the inserted particle.
+ * \param[in] r the radius of the particle. */
+void container_poly::put(particle_order &vo,int n,double x,double y,double z,double r) {
+	int ijk;
+	if(put_locate_block(ijk,x,y,z)) {
+		id[ijk][co[ijk]]=n;
+		vo.add(ijk,co[ijk]);
+		double *pp=p[ijk]+4*co[ijk]++;
+		*(pp++)=x;*(pp++)=y;*(pp++)=z;*pp=r;
+		if(max_radius<r) max_radius=r;
+	}
+}
+
+/** This routine takes a particle position vector, tries to remap it into the
+ * primary domain. If successful, it computes the region into which it can be
+ * stored and checks that there is enough memory within this region to store
+ * it.
+ * \param[out] ijk the region index.
+ * \param[in,out] (x,y,z) the particle position, remapped into the primary
+ *                        domain if necessary.
+ * \return True if the particle can be successfully placed into the container,
+ * false otherwise. */
+bool container_base::put_locate_block(int &ijk,double &x,double &y,double &z) {
+	if(put_remap(ijk,x,y,z)) {
+		if(co[ijk]==mem[ijk]) add_particle_memory(ijk);
+		return true;
+	}
+#if VOROPP_REPORT_OUT_OF_BOUNDS ==1
+	fprintf(stderr,"Out of bounds: (x,y,z)=(%g,%g,%g)\n",x,y,z);
+#endif
+	return false;
+}
+
+/** Takes a particle position vector and computes the region index into which
+ * it should be stored. If the container is periodic, then the routine also
+ * maps the particle position to ensure it is in the primary domain. If the
+ * container is not periodic, the routine bails out.
+ * \param[out] ijk the region index.
+ * \param[in,out] (x,y,z) the particle position, remapped into the primary
+ *                        domain if necessary.
+ * \return True if the particle can be successfully placed into the container,
+ * false otherwise. */
+inline bool container_base::put_remap(int &ijk,double &x,double &y,double &z) {
+	int l;
+
+	ijk=step_int((x-ax)*xsp);
+	if(xperiodic) {l=step_mod(ijk,nx);x+=boxx*(l-ijk);ijk=l;}
+	else if(ijk<0||ijk>=nx) return false;
+
+	int j=step_int((y-ay)*ysp);
+	if(yperiodic) {l=step_mod(j,ny);y+=boxy*(l-j);j=l;}
+	else if(j<0||j>=ny) return false;
+
+	int k=step_int((z-az)*zsp);
+	if(zperiodic) {l=step_mod(k,nz);z+=boxz*(l-k);k=l;}
+	else if(k<0||k>=nz) return false;
+
+	ijk+=nx*j+nxy*k;
+	return true;
+}
+
+/** Takes a position vector and attempts to remap it into the primary domain.
+ * \param[out] (ai,aj,ak) the periodic image displacement that the vector is in,
+ *                       with (0,0,0) corresponding to the primary domain.
+ * \param[out] (ci,cj,ck) the index of the block that the position vector is
+ *                        within, once it has been remapped.
+ * \param[in,out] (x,y,z) the position vector to consider, which is remapped
+ *                        into the primary domain during the routine.
+ * \param[out] ijk the block index that the vector is within.
+ * \return True if the particle is within the container or can be remapped into
+ * it, false if it lies outside of the container bounds. */
+inline bool container_base::remap(int &ai,int &aj,int &ak,int &ci,int &cj,int &ck,double &x,double &y,double &z,int &ijk) {
+	ci=step_int((x-ax)*xsp);
+	if(ci<0||ci>=nx) {
+		if(xperiodic) {ai=step_div(ci,nx);x-=ai*(bx-ax);ci-=ai*nx;}
+		else return false;
+	} else ai=0;
+
+	cj=step_int((y-ay)*ysp);
+	if(cj<0||cj>=ny) {
+		if(yperiodic) {aj=step_div(cj,ny);y-=aj*(by-ay);cj-=aj*ny;}
+		else return false;
+	} else aj=0;
+
+	ck=step_int((z-az)*zsp);
+	if(ck<0||ck>=nz) {
+		if(zperiodic) {ak=step_div(ck,nz);z-=ak*(bz-az);ck-=ak*nz;}
+		else return false;
+	} else ak=0;
+
+	ijk=ci+nx*cj+nxy*ck;
+	return true;
+}
+
+/** Takes a vector and finds the particle whose Voronoi cell contains that
+ * vector. This is equivalent to finding the particle which is nearest to the
+ * vector. Additional wall classes are not considered by this routine.
+ * \param[in] (x,y,z) the vector to test.
+ * \param[out] (rx,ry,rz) the position of the particle whose Voronoi cell
+ *                        contains the vector. If the container is periodic,
+ *                        this may point to a particle in a periodic image of
+ *                        the primary domain.
+ * \param[out] pid the ID of the particle.
+ * \return True if a particle was found. If the container has no particles,
+ * then the search will not find a Voronoi cell and false is returned. */
+bool container::find_voronoi_cell(double x,double y,double z,double &rx,double &ry,double &rz,int &pid) {
+	int ai,aj,ak,ci,cj,ck,ijk;
+	particle_record w;
+	double mrs;
+
+	// If the given vector lies outside the domain, but the container
+	// is periodic, then remap it back into the domain
+	if(!remap(ai,aj,ak,ci,cj,ck,x,y,z,ijk)) return false;
+	vc.find_voronoi_cell(x,y,z,ci,cj,ck,ijk,w,mrs);
+
+	if(w.ijk!=-1) {
+
+		// Assemble the position vector of the particle to be returned,
+		// applying a periodic remapping if necessary
+		if(xperiodic) {ci+=w.di;if(ci<0||ci>=nx) ai+=step_div(ci,nx);}
+		if(yperiodic) {cj+=w.dj;if(cj<0||cj>=ny) aj+=step_div(cj,ny);}
+		if(zperiodic) {ck+=w.dk;if(ck<0||ck>=nz) ak+=step_div(ck,nz);}
+		rx=p[w.ijk][3*w.l]+ai*(bx-ax);
+		ry=p[w.ijk][3*w.l+1]+aj*(by-ay);
+		rz=p[w.ijk][3*w.l+2]+ak*(bz-az);
+		pid=id[w.ijk][w.l];
+		return true;
+	}
+
+	// If no particle if found then just return false
+	return false;
+}
+
+/** Takes a vector and finds the particle whose Voronoi cell contains that
+ * vector. Additional wall classes are not considered by this routine.
+ * \param[in] (x,y,z) the vector to test.
+ * \param[out] (rx,ry,rz) the position of the particle whose Voronoi cell
+ *                        contains the vector. If the container is periodic,
+ *                        this may point to a particle in a periodic image of
+ *                        the primary domain.
+ * \param[out] pid the ID of the particle.
+ * \return True if a particle was found. If the container has no particles,
+ * then the search will not find a Voronoi cell and false is returned. */
+bool container_poly::find_voronoi_cell(double x,double y,double z,double &rx,double &ry,double &rz,int &pid) {
+	int ai,aj,ak,ci,cj,ck,ijk;
+	particle_record w;
+	double mrs;
+
+	// If the given vector lies outside the domain, but the container
+	// is periodic, then remap it back into the domain
+	if(!remap(ai,aj,ak,ci,cj,ck,x,y,z,ijk)) return false;
+	vc.find_voronoi_cell(x,y,z,ci,cj,ck,ijk,w,mrs);
+
+	if(w.ijk!=-1) {
+
+		// Assemble the position vector of the particle to be returned,
+		// applying a periodic remapping if necessary
+		if(xperiodic) {ci+=w.di;if(ci<0||ci>=nx) ai+=step_div(ci,nx);}
+		if(yperiodic) {cj+=w.dj;if(cj<0||cj>=ny) aj+=step_div(cj,ny);}
+		if(zperiodic) {ck+=w.dk;if(ck<0||ck>=nz) ak+=step_div(ck,nz);}
+		rx=p[w.ijk][4*w.l]+ai*(bx-ax);
+		ry=p[w.ijk][4*w.l+1]+aj*(by-ay);
+		rz=p[w.ijk][4*w.l+2]+ak*(bz-az);
+		pid=id[w.ijk][w.l];
+		return true;
+	}
+
+	// If no particle if found then just return false
+	return false;
+}
+
+/** Increase memory for a particular region.
+ * \param[in] i the index of the region to reallocate. */
+void container_base::add_particle_memory(int i) {
+	int l,nmem=mem[i]<<1;
+
+	// Carry out a check on the memory allocation size, and
+	// print a status message if requested
+	if(nmem>max_particle_memory)
+		voro_fatal_error("Absolute maximum memory allocation exceeded",VOROPP_MEMORY_ERROR);
+#if VOROPP_VERBOSE >=3
+	fprintf(stderr,"Particle memory in region %d scaled up to %d\n",i,nmem);
+#endif
+
+	// Allocate new memory and copy in the contents of the old arrays
+	int *idp=new int[nmem];
+	for(l=0;l<co[i];l++) idp[l]=id[i][l];
+	double *pp=new double[ps*nmem];
+	for(l=0;l<ps*co[i];l++) pp[l]=p[i][l];
+
+	// Update pointers and delete old arrays
+	mem[i]=nmem;
+	delete [] id[i];id[i]=idp;
+	delete [] p[i];p[i]=pp;
+}
+
+/** Import a list of particles from an open file stream into the container.
+ * Entries of four numbers (Particle ID, x position, y position, z position)
+ * are searched for. If the file cannot be successfully read, then the routine
+ * causes a fatal error.
+ * \param[in] fp the file handle to read from. */
+void container::import(FILE *fp) {
+	int i,j;
+	double x,y,z;
+	while((j=fscanf(fp,"%d %lg %lg %lg",&i,&x,&y,&z))==4) put(i,x,y,z);
+	if(j!=EOF) voro_fatal_error("File import error",VOROPP_FILE_ERROR);
+}
+
+/** Import a list of particles from an open file stream, also storing the order
+ * of that the particles are read. Entries of four numbers (Particle ID, x
+ * position, y position, z position) are searched for. If the file cannot be
+ * successfully read, then the routine causes a fatal error.
+ * \param[in,out] vo a reference to an ordering class to use.
+ * \param[in] fp the file handle to read from. */
+void container::import(particle_order &vo,FILE *fp) {
+	int i,j;
+	double x,y,z;
+	while((j=fscanf(fp,"%d %lg %lg %lg",&i,&x,&y,&z))==4) put(vo,i,x,y,z);
+	if(j!=EOF) voro_fatal_error("File import error",VOROPP_FILE_ERROR);
+}
+
+/** Import a list of particles from an open file stream into the container.
+ * Entries of five numbers (Particle ID, x position, y position, z position,
+ * radius) are searched for. If the file cannot be successfully read, then the
+ * routine causes a fatal error.
+ * \param[in] fp the file handle to read from. */
+void container_poly::import(FILE *fp) {
+	int i,j;
+	double x,y,z,r;
+	while((j=fscanf(fp,"%d %lg %lg %lg %lg",&i,&x,&y,&z,&r))==5) put(i,x,y,z,r);
+	if(j!=EOF) voro_fatal_error("File import error",VOROPP_FILE_ERROR);
+}
+
+/** Import a list of particles from an open file stream, also storing the order
+ * of that the particles are read. Entries of four numbers (Particle ID, x
+ * position, y position, z position, radius) are searched for. If the file
+ * cannot be successfully read, then the routine causes a fatal error.
+ * \param[in,out] vo a reference to an ordering class to use.
+ * \param[in] fp the file handle to read from. */
+void container_poly::import(particle_order &vo,FILE *fp) {
+	int i,j;
+	double x,y,z,r;
+	while((j=fscanf(fp,"%d %lg %lg %lg %lg",&i,&x,&y,&z,&r))==5) put(vo,i,x,y,z,r);
+	if(j!=EOF) voro_fatal_error("File import error",VOROPP_FILE_ERROR);
+}
+
+/** Outputs the a list of all the container regions along with the number of
+ * particles stored within each. */
+void container_base::region_count() {
+	int i,j,k,*cop=co;
+	for(k=0;k<nz;k++) for(j=0;j<ny;j++) for(i=0;i<nx;i++)
+		printf("Region (%d,%d,%d): %d particles\n",i,j,k,*(cop++));
+}
+
+/** Clears a container of particles. */
+void container::clear() {
+	for(int *cop=co;cop<co+nxyz;cop++) *cop=0;
+}
+
+/** Clears a container of particles, also clearing resetting the maximum radius
+ * to zero. */
+void container_poly::clear() {
+	for(int *cop=co;cop<co+nxyz;cop++) *cop=0;
+	max_radius=0;
+}
+
+/** Computes all the Voronoi cells and saves customized information about them.
+ * \param[in] format the custom output string to use.
+ * \param[in] fp a file handle to write to. */
+void container::print_custom(const char *format,FILE *fp) {
+	c_loop_all vl(*this);
+	print_custom(vl,format,fp);
+}
+
+/** Computes all the Voronoi cells and saves customized
+ * information about them.
+ * \param[in] format the custom output string to use.
+ * \param[in] fp a file handle to write to. */
+void container_poly::print_custom(const char *format,FILE *fp) {
+	c_loop_all vl(*this);
+	print_custom(vl,format,fp);
+}
+
+/** Computes all the Voronoi cells and saves customized information about them.
+ * \param[in] format the custom output string to use.
+ * \param[in] filename the name of the file to write to. */
+void container::print_custom(const char *format,const char *filename) {
+	FILE *fp=safe_fopen(filename,"w");
+	print_custom(format,fp);
+	fclose(fp);
+}
+
+/** Computes all the Voronoi cells and saves customized
+ * information about them
+ * \param[in] format the custom output string to use.
+ * \param[in] filename the name of the file to write to. */
+void container_poly::print_custom(const char *format,const char *filename) {
+	FILE *fp=safe_fopen(filename,"w");
+	print_custom(format,fp);
+	fclose(fp);
+}
+
+/** Computes all of the Voronoi cells in the container, but does nothing
+ * with the output. It is useful for measuring the pure computation time
+ * of the Voronoi algorithm, without any additional calculations such as
+ * volume evaluation or cell output. */
+void container::compute_all_cells() {
+	voronoicell c;
+	c_loop_all vl(*this);
+	if(vl.start()) do compute_cell(c,vl);
+	while(vl.inc());
+}
+
+/** Computes all of the Voronoi cells in the container, but does nothing
+ * with the output. It is useful for measuring the pure computation time
+ * of the Voronoi algorithm, without any additional calculations such as
+ * volume evaluation or cell output. */
+void container_poly::compute_all_cells() {
+	voronoicell c;
+	c_loop_all vl(*this);
+	if(vl.start()) do compute_cell(c,vl);while(vl.inc());
+}
+
+/** Calculates all of the Voronoi cells and sums their volumes. In most cases
+ * without walls, the sum of the Voronoi cell volumes should equal the volume
+ * of the container to numerical precision.
+ * \return The sum of all of the computed Voronoi volumes. */
+double container::sum_cell_volumes() {
+	voronoicell c;
+	double vol=0;
+	c_loop_all vl(*this);
+	if(vl.start()) do if(compute_cell(c,vl)) vol+=c.volume();while(vl.inc());
+	return vol;
+}
+
+/** Calculates all of the Voronoi cells and sums their volumes. In most cases
+ * without walls, the sum of the Voronoi cell volumes should equal the volume
+ * of the container to numerical precision.
+ * \return The sum of all of the computed Voronoi volumes. */
+double container_poly::sum_cell_volumes() {
+	voronoicell c;
+	double vol=0;
+	c_loop_all vl(*this);
+	if(vl.start()) do if(compute_cell(c,vl)) vol+=c.volume();while(vl.inc());
+	return vol;
+}
+
+/** This function tests to see if a given vector lies within the container
+ * bounds and any walls.
+ * \param[in] (x,y,z) the position vector to be tested.
+ * \return True if the point is inside the container, false if the point is
+ *         outside. */
+bool container_base::point_inside(double x,double y,double z) {
+	if(x<ax||x>bx||y<ay||y>by||z<az||z>bz) return false;
+	return point_inside_walls(x,y,z);
+}
+
+/** Draws an outline of the domain in gnuplot format.
+ * \param[in] fp the file handle to write to. */
+void container_base::draw_domain_gnuplot(FILE *fp) {
+	fprintf(fp,"%g %g %g\n%g %g %g\n%g %g %g\n%g %g %g\n",ax,ay,az,bx,ay,az,bx,by,az,ax,by,az);
+	fprintf(fp,"%g %g %g\n%g %g %g\n%g %g %g\n%g %g %g\n",ax,by,bz,bx,by,bz,bx,ay,bz,ax,ay,bz);
+	fprintf(fp,"%g %g %g\n\n%g %g %g\n%g %g %g\n\n",ax,by,bz,ax,ay,az,ax,ay,bz);
+	fprintf(fp,"%g %g %g\n%g %g %g\n\n%g %g %g\n%g %g %g\n\n",bx,ay,az,bx,ay,bz,bx,by,az,bx,by,bz);
+}
+
+/** Draws an outline of the domain in POV-Ray format.
+ * \param[in] fp the file handle to write to. */
+void container_base::draw_domain_pov(FILE *fp) {
+	fprintf(fp,"cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\n"
+		   "cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\n",ax,ay,az,bx,ay,az,ax,by,az,bx,by,az);
+	fprintf(fp,"cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\n"
+		   "cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\n",ax,by,bz,bx,by,bz,ax,ay,bz,bx,ay,bz);
+	fprintf(fp,"cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\n"
+		   "cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\n",ax,ay,az,ax,by,az,bx,ay,az,bx,by,az);
+	fprintf(fp,"cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\n"
+		   "cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\n",bx,ay,bz,bx,by,bz,ax,ay,bz,ax,by,bz);
+	fprintf(fp,"cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\n"
+		   "cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\n",ax,ay,az,ax,ay,bz,bx,ay,az,bx,ay,bz);
+	fprintf(fp,"cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\n"
+		   "cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\n",bx,by,az,bx,by,bz,ax,by,az,ax,by,bz);
+	fprintf(fp,"sphere{<%g,%g,%g>,rr}\nsphere{<%g,%g,%g>,rr}\n"
+		   "sphere{<%g,%g,%g>,rr}\nsphere{<%g,%g,%g>,rr}\n",ax,ay,az,bx,ay,az,ax,by,az,bx,by,az);
+	fprintf(fp,"sphere{<%g,%g,%g>,rr}\nsphere{<%g,%g,%g>,rr}\n"
+		   "sphere{<%g,%g,%g>,rr}\nsphere{<%g,%g,%g>,rr}\n",ax,ay,bz,bx,ay,bz,ax,by,bz,bx,by,bz);
+}
+
+
+/** The wall_list constructor sets up an array of pointers to wall classes. */
+wall_list::wall_list() : walls(new wall*[init_wall_size]), wep(walls), wel(walls+init_wall_size),
+	current_wall_size(init_wall_size) {}
+
+/** The wall_list destructor frees the array of pointers to the wall classes.
+ */
+wall_list::~wall_list() {
+	delete [] walls;
+}
+
+/** Adds all of the walls on another wall_list to this class.
+ * \param[in] wl a reference to the wall class. */
+void wall_list::add_wall(wall_list &wl) {
+	for(wall **wp=wl.walls;wp<wl.wep;wp++) add_wall(*wp);
+}
+
+/** Deallocates all of the wall classes pointed to by the wall_list. */
+void wall_list::deallocate() {
+	for(wall **wp=walls;wp<wep;wp++) delete *wp;
+}
+
+/** Increases the memory allocation for the walls array. */
+void wall_list::increase_wall_memory() {
+	current_wall_size<<=1;
+	if(current_wall_size>max_wall_size)
+		voro_fatal_error("Wall memory allocation exceeded absolute maximum",VOROPP_MEMORY_ERROR);
+	wall **nwalls=new wall*[current_wall_size],**nwp=nwalls,**wp=walls;
+	while(wp<wep) *(nwp++)=*(wp++);
+	delete [] walls;
+	walls=nwalls;wel=walls+current_wall_size;wep=nwp;
+}
+
+}
diff -ru --new-file blender-2.76b.old/extern/voro++/src/container.hh blender-2.76b/extern/voro++/src/container.hh
--- blender-2.76b.old/extern/voro++/src/container.hh	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/container.hh	2016-01-27 19:03:36.496320841 +0300
@@ -0,0 +1,729 @@
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \file container.hh
+ * \brief Header file for the container_base and related classes. */
+
+#ifndef VOROPP_CONTAINER_HH
+#define VOROPP_CONTAINER_HH
+
+#include <cstdio>
+#include <vector>
+
+#include "config.hh"
+#include "common.hh"
+#include "v_base.hh"
+#include "cell.hh"
+#include "c_loops.hh"
+#include "v_compute.hh"
+#include "rad_option.hh"
+
+namespace voro {
+
+/** \brief Pure virtual class from which wall objects are derived.
+ *
+ * This is a pure virtual class for a generic wall object. A wall object
+ * can be specified by deriving a new class from this and specifying the
+ * functions.*/
+class wall {
+	public:
+		virtual ~wall() {}
+		/** A pure virtual function for testing whether a point is
+		 * inside the wall object. */
+		virtual bool point_inside(double x,double y,double z) = 0;
+		/** A pure virtual function for cutting a cell without
+		 * neighbor-tracking with a wall. */
+		virtual bool cut_cell(voronoicell &c,double x,double y,double z) = 0;
+		/** A pure virtual function for cutting a cell with
+		 * neighbor-tracking enabled with a wall. */
+		virtual bool cut_cell(voronoicell_neighbor &c,double x,double y,double z) = 0;
+};
+
+/** \brief A class for storing a list of pointers to walls.
+ *
+ * This class stores a list of pointers to wall classes. It contains several
+ * simple routines that make use of the wall classes (such as telling whether a
+ * given position is inside all of the walls or not). It can be used by itself,
+ * but also forms part of container_base, for associating walls with this
+ * class. */
+class wall_list {
+	public:
+		/** An array holding pointers to wall objects. */
+		wall **walls;
+		/** A pointer to the next free position to add a wall pointer.
+		 */
+		wall **wep;
+		wall_list();
+		~wall_list();
+		/** Adds a wall to the list.
+		 * \param[in] w the wall to add. */
+		inline void add_wall(wall *w) {
+			if(wep==wel) increase_wall_memory();
+			*(wep++)=w;
+		}
+		/** Adds a wall to the list.
+		 * \param[in] w a reference to the wall to add. */
+		inline void add_wall(wall &w) {add_wall(&w);}
+		void add_wall(wall_list &wl);
+		/** Determines whether a given position is inside all of the
+		 * walls on the list.
+		 * \param[in] (x,y,z) the position to test.
+		 * \return True if it is inside, false if it is outside. */
+		inline bool point_inside_walls(double x,double y,double z) {
+			for(wall **wp=walls;wp<wep;wp++) if(!((*wp)->point_inside(x,y,z))) return false;
+			return true;
+		}
+		/** Cuts a Voronoi cell by all of the walls currently on
+		 * the list.
+		 * \param[in] c a reference to the Voronoi cell class.
+		 * \param[in] (x,y,z) the position of the cell.
+		 * \return True if the cell still exists, false if the cell is
+		 * deleted. */
+		template<class c_class>
+		bool apply_walls(c_class &c,double x,double y,double z) {
+			for(wall **wp=walls;wp<wep;wp++) if(!((*wp)->cut_cell(c,x,y,z))) return false;
+			return true;
+		}
+		void deallocate();
+	protected:
+		void increase_wall_memory();
+		/** A pointer to the limit of the walls array, used to
+		 * determine when array is full. */
+		wall **wel;
+		/** The current amount of memory allocated for walls. */
+		int current_wall_size;
+};
+
+/** \brief Class for representing a particle system in a three-dimensional
+ * rectangular box.
+ *
+ * This class represents a system of particles in a three-dimensional
+ * rectangular box. Any combination of non-periodic and periodic coordinates
+ * can be used in the three coordinate directions. The class is not intended
+ * for direct use, but instead forms the base of the container and
+ * container_poly classes that add specialized routines for computing the
+ * regular and radical Voronoi tessellations respectively. It contains routines
+ * that are commonly between these two classes, such as those for drawing the
+ * domain, and placing particles within the internal data structure.
+ *
+ * The class is derived from the wall_list class, which encapsulates routines
+ * for associating walls with the container, and the voro_base class, which
+ * encapsulates routines about the underlying computational grid. */
+class container_base : public voro_base, public wall_list {
+	public:
+		/** The minimum x coordinate of the container. */
+		const double ax;
+		/** The maximum x coordinate of the container. */
+		const double bx;
+		/** The minimum y coordinate of the container. */
+		const double ay;
+		/** The maximum y coordinate of the container. */
+		const double by;
+		/** The minimum z coordinate of the container. */
+		const double az;
+		/** The maximum z coordinate of the container. */
+		const double bz;
+		/** A boolean value that determines if the x coordinate in
+		 * periodic or not. */
+		const bool xperiodic;
+		/** A boolean value that determines if the y coordinate in
+		 * periodic or not. */
+		const bool yperiodic;
+		/** A boolean value that determines if the z coordinate in
+		 * periodic or not. */
+		const bool zperiodic;
+		/** This array holds the numerical IDs of each particle in each
+		 * computational box. */
+		int **id;
+		/** A two dimensional array holding particle positions. For the
+		 * derived container_poly class, this also holds particle
+		 * radii. */
+		double **p;
+		/** This array holds the number of particles within each
+		 * computational box of the container. */
+		int *co;
+		/** This array holds the maximum amount of particle memory for
+		 * each computational box of the container. If the number of
+		 * particles in a particular box ever approaches this limit,
+		 * more is allocated using the add_particle_memory() function.
+		 */
+		int *mem;
+		/** The amount of memory in the array structure for each
+		 * particle. This is set to 3 when the basic class is
+		 * initialized, so that the array holds (x,y,z) positions. If
+		 * the container class is initialized as part of the derived
+		 * class container_poly, then this is set to 4, to also hold
+		 * the particle radii. */
+		const int ps;
+		container_base(double ax_,double bx_,double ay_,double by_,double az_,double bz_,
+				int nx_,int ny_,int nz_,bool xperiodic_,bool yperiodic_,bool zperiodic_,
+				int init_mem,int ps_);
+		~container_base();
+		bool point_inside(double x,double y,double z);
+		void region_count();
+		/** Initializes the Voronoi cell prior to a compute_cell
+		 * operation for a specific particle being carried out by a
+		 * voro_compute class. The cell is initialized to fill the
+		 * entire container. For non-periodic coordinates, this is set
+		 * by the position of the walls. For periodic coordinates, the
+		 * space is equally divided in either direction from the
+		 * particle's initial position. Plane cuts made by any walls
+		 * that have been added are then applied to the cell.
+		 * \param[in,out] c a reference to a voronoicell object.
+		 * \param[in] ijk the block that the particle is within.
+		 * \param[in] q the index of the particle within its block.
+		 * \param[in] (ci,cj,ck) the coordinates of the block in the
+		 * 			 container coordinate system.
+		 * \param[out] (i,j,k) the coordinates of the test block
+		 * 		       relative to the voro_compute
+		 * 		       coordinate system.
+		 * \param[out] (x,y,z) the position of the particle.
+		 * \param[out] disp a block displacement used internally by the
+		 *		    compute_cell routine.
+		 * \return False if the plane cuts applied by walls completely
+		 * removed the cell, true otherwise. */
+		template<class v_cell>
+		inline bool initialize_voronoicell(v_cell &c,int ijk,int q,int ci,int cj,int ck,
+				int &i,int &j,int &k,double &x,double &y,double &z,int &disp) {
+			double x1,x2,y1,y2,z1,z2,*pp=p[ijk]+ps*q;
+			x=*(pp++);y=*(pp++);z=*pp;
+			if(xperiodic) {x1=-(x2=0.5*(bx-ax));i=nx;} else {x1=ax-x;x2=bx-x;i=ci;}
+			if(yperiodic) {y1=-(y2=0.5*(by-ay));j=ny;} else {y1=ay-y;y2=by-y;j=cj;}
+			if(zperiodic) {z1=-(z2=0.5*(bz-az));k=nz;} else {z1=az-z;z2=bz-z;k=ck;}
+			c.init(x1,x2,y1,y2,z1,z2);
+			if(!apply_walls(c,x,y,z)) return false;
+			disp=ijk-i-nx*(j+ny*k);
+			return true;
+		}
+		/** Initializes parameters for a find_voronoi_cell call within
+		 * the voro_compute template.
+		 * \param[in] (ci,cj,ck) the coordinates of the test block in
+		 * 			 the container coordinate system.
+		 * \param[in] ijk the index of the test block
+		 * \param[out] (i,j,k) the coordinates of the test block
+		 * 		       relative to the voro_compute
+		 * 		       coordinate system.
+		 * \param[out] disp a block displacement used internally by the
+		 *		    find_voronoi_cell routine. */
+		inline void initialize_search(int ci,int cj,int ck,int ijk,int &i,int &j,int &k,int &disp) {
+			i=xperiodic?nx:ci;
+			j=yperiodic?ny:cj;
+			k=zperiodic?nz:ck;
+			disp=ijk-i-nx*(j+ny*k);
+		}
+		/** Returns the position of a particle currently being computed
+		 * relative to the computational block that it is within. It is
+		 * used to select the optimal worklist entry to use.
+		 * \param[in] (x,y,z) the position of the particle.
+		 * \param[in] (ci,cj,ck) the block that the particle is within.
+		 * \param[out] (fx,fy,fz) the position relative to the block.
+		 */
+		inline void frac_pos(double x,double y,double z,double ci,double cj,double ck,
+				double &fx,double &fy,double &fz) {
+			fx=x-ax-boxx*ci;
+			fy=y-ay-boxy*cj;
+			fz=z-az-boxz*ck;
+		}
+		/** Calculates the index of block in the container structure
+		 * corresponding to given coordinates.
+		 * \param[in] (ci,cj,ck) the coordinates of the original block
+		 * 			 in the current computation, relative
+		 * 			 to the container coordinate system.
+		 * \param[in] (ei,ej,ek) the displacement of the current block
+		 * 			 from the original block.
+		 * \param[in,out] (qx,qy,qz) the periodic displacement that
+		 * 			     must be added to the particles
+		 * 			     within the computed block.
+		 * \param[in] disp a block displacement used internally by the
+		 * 		    find_voronoi_cell and compute_cell routines.
+		 * \return The block index. */
+		inline int region_index(int ci,int cj,int ck,int ei,int ej,int ek,double &qx,double &qy,double &qz,int &disp) {
+			if(xperiodic) {if(ci+ei<nx) {ei+=nx;qx=-(bx-ax);} else if(ci+ei>=(nx<<1)) {ei-=nx;qx=bx-ax;} else qx=0;}
+			if(yperiodic) {if(cj+ej<ny) {ej+=ny;qy=-(by-ay);} else if(cj+ej>=(ny<<1)) {ej-=ny;qy=by-ay;} else qy=0;}
+			if(zperiodic) {if(ck+ek<nz) {ek+=nz;qz=-(bz-az);} else if(ck+ek>=(nz<<1)) {ek-=nz;qz=bz-az;} else qz=0;}
+			return disp+ei+nx*(ej+ny*ek);
+		}
+		void draw_domain_gnuplot(FILE *fp=stdout);
+		/** Draws an outline of the domain in Gnuplot format.
+		 * \param[in] filename the filename to write to. */
+		inline void draw_domain_gnuplot(const char* filename) {
+			FILE *fp=safe_fopen(filename,"w");
+			draw_domain_gnuplot(fp);
+			fclose(fp);
+		}
+		void draw_domain_pov(FILE *fp=stdout);
+		/** Draws an outline of the domain in Gnuplot format.
+		 * \param[in] filename the filename to write to. */
+		inline void draw_domain_pov(const char* filename) {
+			FILE *fp=safe_fopen(filename,"w");
+			draw_domain_pov(fp);
+			fclose(fp);
+		}
+		/** Sums up the total number of stored particles.
+		 * \return The number of particles. */
+		inline int total_particles() {
+			int tp=*co;
+			for(int *cop=co+1;cop<co+nxyz;cop++) tp+=*cop;
+			return tp;
+		}
+	protected:
+		void add_particle_memory(int i);
+		bool put_locate_block(int &ijk,double &x,double &y,double &z);
+		inline bool put_remap(int &ijk,double &x,double &y,double &z);
+		inline bool remap(int &ai,int &aj,int &ak,int &ci,int &cj,int &ck,double &x,double &y,double &z,int &ijk);
+};
+
+/** \brief Extension of the container_base class for computing regular Voronoi
+ * tessellations.
+ *
+ * This class is an extension of the container_base class that has routines
+ * specifically for computing the regular Voronoi tessellation with no
+ * dependence on particle radii. */
+class container : public container_base, public radius_mono {
+	public:
+		container(double ax_,double bx_,double ay_,double by_,double az_,double bz_,
+				int nx_,int ny_,int nz_,bool xperiodic_,bool yperiodic_,bool zperiodic_,int init_mem);
+		void clear();
+		void put(int n,double x,double y,double z);
+		void put(particle_order &vo,int n,double x,double y,double z);
+		void import(FILE *fp=stdin);
+		void import(particle_order &vo,FILE *fp=stdin);
+		/** Imports a list of particles from an open file stream into
+		 * the container. Entries of four numbers (Particle ID, x
+		 * position, y position, z position) are searched for. If the
+		 * file cannot be successfully read, then the routine causes a
+		 * fatal error.
+		 * \param[in] filename the name of the file to open and read
+		 *                     from. */
+		inline void import(const char* filename) {
+			FILE *fp=safe_fopen(filename,"r");
+			import(fp);
+			fclose(fp);
+		}
+		/** Imports a list of particles from an open file stream into
+		 * the container. Entries of four numbers (Particle ID, x
+		 * position, y position, z position) are searched for. In
+		 * addition, the order in which particles are read is saved
+		 * into an ordering class. If the file cannot be successfully
+		 * read, then the routine causes a fatal error.
+		 * \param[in,out] vo the ordering class to use.
+		 * \param[in] filename the name of the file to open and read
+		 *                     from. */
+		inline void import(particle_order &vo,const char* filename) {
+			FILE *fp=safe_fopen(filename,"r");
+			import(vo,fp);
+			fclose(fp);
+		}
+		void compute_all_cells();
+		double sum_cell_volumes();
+		/** Dumps particle IDs and positions to a file.
+		 * \param[in] vl the loop class to use.
+		 * \param[in] fp a file handle to write to. */
+		template<class c_loop>
+		void draw_particles(c_loop &vl,FILE *fp) {
+			double *pp;
+			if(vl.start()) do {
+				pp=p[vl.ijk]+3*vl.q;
+				fprintf(fp,"%d %g %g %g\n",id[vl.ijk][vl.q],*pp,pp[1],pp[2]);
+			} while(vl.inc());
+		}
+		/** Dumps all of the particle IDs and positions to a file.
+		 * \param[in] fp a file handle to write to. */
+		inline void draw_particles(FILE *fp=stdout) {
+			c_loop_all vl(*this);
+			draw_particles(vl,fp);
+		}
+		/** Dumps all of the particle IDs and positions to a file.
+		 * \param[in] filename the name of the file to write to. */
+		inline void draw_particles(const char *filename) {
+			FILE *fp=safe_fopen(filename,"w");
+			draw_particles(fp);
+			fclose(fp);
+		}
+		/** Dumps particle positions in POV-Ray format.
+		 * \param[in] vl the loop class to use.
+		 * \param[in] fp a file handle to write to. */
+		template<class c_loop>
+		void draw_particles_pov(c_loop &vl,FILE *fp) {
+			double *pp;
+			if(vl.start()) do {
+				pp=p[vl.ijk]+3*vl.q;
+				fprintf(fp,"// id %d\nsphere{<%g,%g,%g>,s}\n",
+						id[vl.ijk][vl.q],*pp,pp[1],pp[2]);
+			} while(vl.inc());
+		}
+		/** Dumps all particle positions in POV-Ray format.
+		 * \param[in] fp a file handle to write to. */
+		inline void draw_particles_pov(FILE *fp=stdout) {
+			c_loop_all vl(*this);
+			draw_particles_pov(vl,fp);
+		}
+		/** Dumps all particle positions in POV-Ray format.
+		 * \param[in] filename the name of the file to write to. */
+		inline void draw_particles_pov(const char *filename) {
+			FILE *fp=safe_fopen(filename,"w");
+			draw_particles_pov(fp);
+			fclose(fp);
+		}
+		/** Computes Voronoi cells and saves the output in gnuplot
+		 * format.
+		 * \param[in] vl the loop class to use.
+		 * \param[in] fp a file handle to write to. */
+		template<class c_loop>
+		void draw_cells_gnuplot(c_loop &vl,FILE *fp) {
+			voronoicell c;double *pp;
+			if(vl.start()) do if(compute_cell(c,vl)) {
+				pp=p[vl.ijk]+ps*vl.q;
+				c.draw_gnuplot(*pp,pp[1],pp[2],fp);
+			} while(vl.inc());
+		}
+		/** Computes all Voronoi cells and saves the output in gnuplot
+		 * format.
+		 * \param[in] fp a file handle to write to. */
+		inline void draw_cells_gnuplot(FILE *fp=stdout) {
+			c_loop_all vl(*this);
+			draw_cells_gnuplot(vl,fp);
+		}
+		/** Computes all Voronoi cells and saves the output in gnuplot
+		 * format.
+		 * \param[in] filename the name of the file to write to. */
+		inline void draw_cells_gnuplot(const char *filename) {
+			FILE *fp=safe_fopen(filename,"w");
+			draw_cells_gnuplot(fp);
+			fclose(fp);
+		}
+		/** Computes Voronoi cells and saves the output in POV-Ray
+		 * format.
+		 * \param[in] vl the loop class to use.
+		 * \param[in] fp a file handle to write to. */
+		template<class c_loop>
+		void draw_cells_pov(c_loop &vl,FILE *fp) {
+			voronoicell c;double *pp;
+			if(vl.start()) do if(compute_cell(c,vl)) {
+				fprintf(fp,"// cell %d\n",id[vl.ijk][vl.q]);
+				pp=p[vl.ijk]+ps*vl.q;
+				c.draw_pov(*pp,pp[1],pp[2],fp);
+			} while(vl.inc());
+		}
+		/** Computes all Voronoi cells and saves the output in POV-Ray
+		 * format.
+		 * \param[in] fp a file handle to write to. */
+		inline void draw_cells_pov(FILE *fp=stdout) {
+			c_loop_all vl(*this);
+			draw_cells_pov(vl,fp);
+		}
+		/** Computes all Voronoi cells and saves the output in POV-Ray
+		 * format.
+		 * \param[in] filename the name of the file to write to. */
+		inline void draw_cells_pov(const char *filename) {
+			FILE *fp=safe_fopen(filename,"w");
+			draw_cells_pov(fp);
+			fclose(fp);
+		}
+		/** Computes the Voronoi cells and saves customized information
+		 * about them.
+		 * \param[in] vl the loop class to use.
+		 * \param[in] format the custom output string to use.
+		 * \param[in] fp a file handle to write to. */
+		template<class c_loop>
+		void print_custom(c_loop &vl,const char *format,FILE *fp) {
+			int ijk,q;double *pp;
+			if(contains_neighbor(format)) {
+				voronoicell_neighbor c;
+				if(vl.start()) do if(compute_cell(c,vl)) {
+					ijk=vl.ijk;q=vl.q;pp=p[ijk]+ps*q;
+					c.output_custom(format,id[ijk][q],*pp,pp[1],pp[2],default_radius,fp);
+				} while(vl.inc());
+			} else {
+				voronoicell c;
+				if(vl.start()) do if(compute_cell(c,vl)) {
+					ijk=vl.ijk;q=vl.q;pp=p[ijk]+ps*q;
+					c.output_custom(format,id[ijk][q],*pp,pp[1],pp[2],default_radius,fp);
+				} while(vl.inc());
+			}
+		}
+		void print_custom(const char *format,FILE *fp=stdout);
+		void print_custom(const char *format,const char *filename);
+		bool find_voronoi_cell(double x,double y,double z,double &rx,double &ry,double &rz,int &pid);
+		/** Computes the Voronoi cell for a particle currently being
+		 * referenced by a loop class.
+		 * \param[out] c a Voronoi cell class in which to store the
+		 * 		 computed cell.
+		 * \param[in] vl the loop class to use.
+		 * \return True if the cell was computed. If the cell cannot be
+		 * computed, if it is removed entirely by a wall or boundary
+		 * condition, then the routine returns false. */
+		template<class v_cell,class c_loop>
+		inline bool compute_cell(v_cell &c,c_loop &vl) {
+			return vc.compute_cell(c,vl.ijk,vl.q,vl.i,vl.j,vl.k);
+		}
+		/** Computes the Voronoi cell for given particle.
+		 * \param[out] c a Voronoi cell class in which to store the
+		 * 		 computed cell.
+		 * \param[in] ijk the block that the particle is within.
+		 * \param[in] q the index of the particle within the block.
+		 * \return True if the cell was computed. If the cell cannot be
+		 * computed, if it is removed entirely by a wall or boundary
+		 * condition, then the routine returns false. */
+		template<class v_cell>
+		inline bool compute_cell(v_cell &c,int ijk,int q) {
+			int k=ijk/nxy,ijkt=ijk-nxy*k,j=ijkt/nx,i=ijkt-j*nx;
+			return vc.compute_cell(c,ijk,q,i,j,k);
+		}
+		/** Computes the Voronoi cell for a ghost particle at a given
+		 * location.
+		 * \param[out] c a Voronoi cell class in which to store the
+		 * 		 computed cell.
+		 * \param[in] (x,y,z) the location of the ghost particle.
+		 * \return True if the cell was computed. If the cell cannot be
+		 * computed, if it is removed entirely by a wall or boundary
+		 * condition, then the routine returns false. */
+		template<class v_cell>
+		inline bool compute_ghost_cell(v_cell &c,double x,double y,double z) {
+			int ijk;
+			if(put_locate_block(ijk,x,y,z)) {
+				double *pp=p[ijk]+3*co[ijk]++;
+				*(pp++)=x;*(pp++)=y;*pp=z;
+				bool q=compute_cell(c,ijk,co[ijk]-1);
+				co[ijk]--;
+				return q;
+			}
+			return false;
+		}
+	private:
+		voro_compute<container> vc;
+		friend class voro_compute<container>;
+};
+
+/** \brief Extension of the container_base class for computing radical Voronoi
+ * tessellations.
+ *
+ * This class is an extension of container_base class that has routines
+ * specifically for computing the radical Voronoi tessellation that depends on
+ * the particle radii. */
+class container_poly : public container_base, public radius_poly {
+	public:
+		container_poly(double ax_,double bx_,double ay_,double by_,double az_,double bz_,
+				int nx_,int ny_,int nz_,bool xperiodic_,bool yperiodic_,bool zperiodic_,int init_mem);
+		void clear();
+		void put(int n,double x,double y,double z,double r);
+		void put(particle_order &vo,int n,double x,double y,double z,double r);
+		void import(FILE *fp=stdin);
+		void import(particle_order &vo,FILE *fp=stdin);
+		/** Imports a list of particles from an open file stream into
+		 * the container_poly class. Entries of five numbers (Particle
+		 * ID, x position, y position, z position, radius) are searched
+		 * for. If the file cannot be successfully read, then the
+		 * routine causes a fatal error.
+		 * \param[in] filename the name of the file to open and read
+		 *                     from. */
+		inline void import(const char* filename) {
+			FILE *fp=safe_fopen(filename,"r");
+			import(fp);
+			fclose(fp);
+		}
+		/** Imports a list of particles from an open file stream into
+		 * the container_poly class. Entries of five numbers (Particle
+		 * ID, x position, y position, z position, radius) are searched
+		 * for. In addition, the order in which particles are read is
+		 * saved into an ordering class. If the file cannot be
+		 * successfully read, then the routine causes a fatal error.
+		 * \param[in,out] vo the ordering class to use.
+		 * \param[in] filename the name of the file to open and read
+		 *                     from. */
+		inline void import(particle_order &vo,const char* filename) {
+			FILE *fp=safe_fopen(filename,"r");
+			import(vo,fp);
+			fclose(fp);
+		}
+		void compute_all_cells();
+		double sum_cell_volumes();
+		/** Dumps particle IDs, positions and radii to a file.
+		 * \param[in] vl the loop class to use.
+		 * \param[in] fp a file handle to write to. */
+		template<class c_loop>
+		void draw_particles(c_loop &vl,FILE *fp) {
+			double *pp;
+			if(vl.start()) do {
+				pp=p[vl.ijk]+4*vl.q;
+				fprintf(fp,"%d %g %g %g %g\n",id[vl.ijk][vl.q],*pp,pp[1],pp[2],pp[3]);
+			} while(vl.inc());
+		}
+		/** Dumps all of the particle IDs, positions and radii to a
+		 * file.
+		 * \param[in] fp a file handle to write to. */
+		inline void draw_particles(FILE *fp=stdout) {
+			c_loop_all vl(*this);
+			draw_particles(vl,fp);
+		}
+		/** Dumps all of the particle IDs, positions and radii to a
+		 * file.
+		 * \param[in] filename the name of the file to write to. */
+		inline void draw_particles(const char *filename) {
+			FILE *fp=safe_fopen(filename,"w");
+			draw_particles(fp);
+			fclose(fp);
+		}
+		/** Dumps particle positions in POV-Ray format.
+		 * \param[in] vl the loop class to use.
+		 * \param[in] fp a file handle to write to. */
+		template<class c_loop>
+		void draw_particles_pov(c_loop &vl,FILE *fp) {
+			double *pp;
+			if(vl.start()) do {
+				pp=p[vl.ijk]+4*vl.q;
+				fprintf(fp,"// id %d\nsphere{<%g,%g,%g>,%g}\n",
+						id[vl.ijk][vl.q],*pp,pp[1],pp[2],pp[3]);
+			} while(vl.inc());
+		}
+		/** Dumps all the particle positions in POV-Ray format.
+		 * \param[in] fp a file handle to write to. */
+		inline void draw_particles_pov(FILE *fp=stdout) {
+			c_loop_all vl(*this);
+			draw_particles_pov(vl,fp);
+		}
+		/** Dumps all the particle positions in POV-Ray format.
+		 * \param[in] filename the name of the file to write to. */
+		inline void draw_particles_pov(const char *filename) {
+			FILE *fp=safe_fopen(filename,"w");
+			draw_particles_pov(fp);
+			fclose(fp);
+		}
+		/** Computes Voronoi cells and saves the output in gnuplot
+		 * format.
+		 * \param[in] vl the loop class to use.
+		 * \param[in] fp a file handle to write to. */
+		template<class c_loop>
+		void draw_cells_gnuplot(c_loop &vl,FILE *fp) {
+			voronoicell c;double *pp;
+			if(vl.start()) do if(compute_cell(c,vl)) {
+				pp=p[vl.ijk]+ps*vl.q;
+				c.draw_gnuplot(*pp,pp[1],pp[2],fp);
+			} while(vl.inc());
+		}
+		/** Compute all Voronoi cells and saves the output in gnuplot
+		 * format.
+		 * \param[in] fp a file handle to write to. */
+		inline void draw_cells_gnuplot(FILE *fp=stdout) {
+			c_loop_all vl(*this);
+			draw_cells_gnuplot(vl,fp);
+		}
+		/** Compute all Voronoi cells and saves the output in gnuplot
+		 * format.
+		 * \param[in] filename the name of the file to write to. */
+		inline void draw_cells_gnuplot(const char *filename) {
+			FILE *fp=safe_fopen(filename,"w");
+			draw_cells_gnuplot(fp);
+			fclose(fp);
+		}
+		/** Computes Voronoi cells and saves the output in POV-Ray
+		 * format.
+		 * \param[in] vl the loop class to use.
+		 * \param[in] fp a file handle to write to. */
+		template<class c_loop>
+		void draw_cells_pov(c_loop &vl,FILE *fp) {
+			voronoicell c;double *pp;
+			if(vl.start()) do if(compute_cell(c,vl)) {
+				fprintf(fp,"// cell %d\n",id[vl.ijk][vl.q]);
+				pp=p[vl.ijk]+ps*vl.q;
+				c.draw_pov(*pp,pp[1],pp[2],fp);
+			} while(vl.inc());
+		}
+		/** Computes all Voronoi cells and saves the output in POV-Ray
+		 * format.
+		 * \param[in] fp a file handle to write to. */
+		inline void draw_cells_pov(FILE *fp=stdout) {
+			c_loop_all vl(*this);
+			draw_cells_pov(vl,fp);
+		}
+		/** Computes all Voronoi cells and saves the output in POV-Ray
+		 * format.
+		 * \param[in] filename the name of the file to write to. */
+		inline void draw_cells_pov(const char *filename) {
+			FILE *fp=safe_fopen(filename,"w");
+			draw_cells_pov(fp);
+			fclose(fp);
+		}
+		/** Computes the Voronoi cells and saves customized information
+		 * about them.
+		 * \param[in] vl the loop class to use.
+		 * \param[in] format the custom output string to use.
+		 * \param[in] fp a file handle to write to. */
+		template<class c_loop>
+		void print_custom(c_loop &vl,const char *format,FILE *fp) {
+			int ijk,q;double *pp;
+			if(contains_neighbor(format)) {
+				voronoicell_neighbor c;
+				if(vl.start()) do if(compute_cell(c,vl)) {
+					ijk=vl.ijk;q=vl.q;pp=p[ijk]+ps*q;
+					c.output_custom(format,id[ijk][q],*pp,pp[1],pp[2],pp[3],fp);
+				} while(vl.inc());
+			} else {
+				voronoicell c;
+				if(vl.start()) do if(compute_cell(c,vl)) {
+					ijk=vl.ijk;q=vl.q;pp=p[ijk]+ps*q;
+					c.output_custom(format,id[ijk][q],*pp,pp[1],pp[2],pp[3],fp);
+				} while(vl.inc());
+			}
+		}
+		/** Computes the Voronoi cell for a particle currently being
+		 * referenced by a loop class.
+		 * \param[out] c a Voronoi cell class in which to store the
+		 * 		 computed cell.
+		 * \param[in] vl the loop class to use.
+		 * \return True if the cell was computed. If the cell cannot be
+		 * computed, if it is removed entirely by a wall or boundary
+		 * condition, then the routine returns false. */
+		template<class v_cell,class c_loop>
+		inline bool compute_cell(v_cell &c,c_loop &vl) {
+			return vc.compute_cell(c,vl.ijk,vl.q,vl.i,vl.j,vl.k);
+		}
+		/** Computes the Voronoi cell for given particle.
+		 * \param[out] c a Voronoi cell class in which to store the
+		 * 		 computed cell.
+		 * \param[in] ijk the block that the particle is within.
+		 * \param[in] q the index of the particle within the block.
+		 * \return True if the cell was computed. If the cell cannot be
+		 * computed, if it is removed entirely by a wall or boundary
+		 * condition, then the routine returns false. */
+		template<class v_cell>
+		inline bool compute_cell(v_cell &c,int ijk,int q) {
+			int k=ijk/nxy,ijkt=ijk-nxy*k,j=ijkt/nx,i=ijkt-j*nx;
+			return vc.compute_cell(c,ijk,q,i,j,k);
+		}
+		/** Computes the Voronoi cell for a ghost particle at a given
+		 * location.
+		 * \param[out] c a Voronoi cell class in which to store the
+		 * 		 computed cell.
+		 * \param[in] (x,y,z) the location of the ghost particle.
+		 * \param[in] r the radius of the ghost particle.
+		 * \return True if the cell was computed. If the cell cannot be
+		 * computed, if it is removed entirely by a wall or boundary
+		 * condition, then the routine returns false. */
+		template<class v_cell>
+		inline bool compute_ghost_cell(v_cell &c,double x,double y,double z,double r) {
+			int ijk;
+			if(put_locate_block(ijk,x,y,z)) {
+				double *pp=p[ijk]+4*co[ijk]++,tm=max_radius;
+				*(pp++)=x;*(pp++)=y;*(pp++)=z;*pp=r;
+				if(r>max_radius) max_radius=r;
+				bool q=compute_cell(c,ijk,co[ijk]-1);
+				co[ijk]--;max_radius=tm;
+				return q;
+			}
+			return false;
+		}
+		void print_custom(const char *format,FILE *fp=stdout);
+		void print_custom(const char *format,const char *filename);
+		bool find_voronoi_cell(double x,double y,double z,double &rx,double &ry,double &rz,int &pid);
+	private:
+		voro_compute<container_poly> vc;
+		friend class voro_compute<container_poly>;
+};
+
+}
+
+#endif
diff -ru --new-file blender-2.76b.old/extern/voro++/src/container_prd.cc blender-2.76b/extern/voro++/src/container_prd.cc
--- blender-2.76b.old/extern/voro++/src/container_prd.cc	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/container_prd.cc	2016-01-27 19:05:44.183371770 +0300
@@ -0,0 +1,768 @@
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \file container_prd.cc
+ * \brief Function implementations for the container_periodic_base and
+ * related classes. */
+
+#include "container_prd.hh"
+
+namespace voro {
+
+/** The class constructor sets up the geometry of container, initializing the
+ * minimum and maximum coordinates in each direction, and setting whether each
+ * direction is periodic or not. It divides the container into a rectangular
+ * grid of blocks, and allocates memory for each of these for storing particle
+ * positions and IDs.
+ * \param[in] (bx_) The x coordinate of the first unit vector.
+ * \param[in] (bxy_,by_) The x and y coordinates of the second unit vector.
+ * \param[in] (bxz_,byz_,bz_) The x, y, and z coordinates of the third unit
+ *                            vector.
+ * \param[in] (nx_,ny_,nz_) the number of grid blocks in each of the three
+ *                       coordinate directions.
+ * \param[in] init_mem_ the initial memory allocation for each block.
+ * \param[in] ps_ the number of floating point entries to store for each
+ *                particle. */
+container_periodic_base::container_periodic_base(double bx_,double bxy_,double by_,
+		double bxz_,double byz_,double bz_,int nx_,int ny_,int nz_,int init_mem_,int ps_)
+	: unitcell(bx_,bxy_,by_,bxz_,byz_,bz_), voro_base(nx_,ny_,nz_,bx_/nx_,by_/ny_,bz_/nz_),
+	ey(int(max_uv_y*ysp+1)), ez(int(max_uv_z*zsp+1)), wy(ny+ey), wz(nz+ez),
+	oy(ny+2*ey), oz(nz+2*ez), oxyz(nx*oy*oz), id(new int*[oxyz]), p(new double*[oxyz]),
+	co(new int[oxyz]), mem(new int[oxyz]), img(new char[oxyz]), init_mem(init_mem_), ps(ps_) {
+	int i,j,k,l;
+
+	// Clear the global arrays
+	int *pp=co;while(pp<co+oxyz) *(pp++)=0;
+	pp=mem;while(pp<mem+oxyz) *(pp++)=0;
+	char *cp=img;while(cp<img+oxyz) *(cp++)=0;
+
+	// Set up memory for the blocks in the primary domain
+	for(k=ez;k<wz;k++) for(j=ey;j<wy;j++) for(i=0;i<nx;i++) {
+		l=i+nx*(j+oy*k);
+		mem[l]=init_mem;
+		id[l]=new int[init_mem];
+		p[l]=new double[ps*init_mem];
+	}
+}
+
+/** The container destructor frees the dynamically allocated memory. */
+container_periodic_base::~container_periodic_base() {
+	for(int l=oxyz-1;l>=0;l--) if(mem[l]>0) {
+		delete [] p[l];
+		delete [] id[l];
+	}
+	delete [] img;
+	delete [] mem;
+	delete [] co;
+	delete [] id;
+	delete [] p;
+}
+
+/** The class constructor sets up the geometry of container.
+ * \param[in] (bx_) The x coordinate of the first unit vector.
+ * \param[in] (bxy_,by_) The x and y coordinates of the second unit vector.
+ * \param[in] (bxz_,byz_,bz_) The x, y, and z coordinates of the third unit
+ *                            vector.
+ * \param[in] (nx_,ny_,nz_) the number of grid blocks in each of the three
+ *			    coordinate directions.
+ * \param[in] init_mem_ the initial memory allocation for each block. */
+container_periodic::container_periodic(double bx_,double bxy_,double by_,double bxz_,double byz_,double bz_,
+	int nx_,int ny_,int nz_,int init_mem_)
+	: container_periodic_base(bx_,bxy_,by_,bxz_,byz_,bz_,nx_,ny_,nz_,init_mem_,3),
+	vc(*this,2*nx_+1,2*ey+1,2*ez+1) {}
+
+/** The class constructor sets up the geometry of container.
+ * \param[in] (bx_) The x coordinate of the first unit vector.
+ * \param[in] (bxy_,by_) The x and y coordinates of the second unit vector.
+ * \param[in] (bxz_,byz_,bz_) The x, y, and z coordinates of the third unit
+ *                            vector.
+ * \param[in] (nx_,ny_,nz_) the number of grid blocks in each of the three
+ *			    coordinate directions.
+ * \param[in] init_mem_ the initial memory allocation for each block. */
+container_periodic_poly::container_periodic_poly(double bx_,double bxy_,double by_,double bxz_,double byz_,double bz_,
+	int nx_,int ny_,int nz_,int init_mem_)
+	: container_periodic_base(bx_,bxy_,by_,bxz_,byz_,bz_,nx_,ny_,nz_,init_mem_,4),
+	vc(*this,2*nx_+1,2*ey+1,2*ez+1) {ppr=p;}
+
+/** Put a particle into the correct region of the container.
+ * \param[in] n the numerical ID of the inserted particle.
+ * \param[in] (x,y,z) the position vector of the inserted particle. */
+void container_periodic::put(int n,double x,double y,double z) {
+	int ijk;
+	put_locate_block(ijk,x,y,z);
+	id[ijk][co[ijk]]=n;
+	double *pp=p[ijk]+3*co[ijk]++;
+	*(pp++)=x;*(pp++)=y;*pp=z;
+}
+
+/** Put a particle into the correct region of the container.
+ * \param[in] n the numerical ID of the inserted particle.
+ * \param[in] (x,y,z) the position vector of the inserted particle.
+ * \param[in] r the radius of the particle. */
+void container_periodic_poly::put(int n,double x,double y,double z,double r) {
+	int ijk;
+	put_locate_block(ijk,x,y,z);
+	id[ijk][co[ijk]]=n;
+	double *pp=p[ijk]+4*co[ijk]++;
+	*(pp++)=x;*(pp++)=y;*(pp++)=z;*pp=r;
+	if(max_radius<r) max_radius=r;
+}
+
+/** Put a particle into the correct region of the container.
+ * \param[in] n the numerical ID of the inserted particle.
+ * \param[in] (x,y,z) the position vector of the inserted particle.
+ * \param[out] (ai,aj,ak) the periodic image displacement that the particle is
+ * 			  in, with (0,0,0) corresponding to the primary domain.
+ */
+void container_periodic::put(int n,double x,double y,double z,int &ai,int &aj,int &ak) {
+	int ijk;
+	put_locate_block(ijk,x,y,z,ai,aj,ak);
+	id[ijk][co[ijk]]=n;
+	double *pp=p[ijk]+3*co[ijk]++;
+	*(pp++)=x;*(pp++)=y;*pp=z;
+}
+
+/** Put a particle into the correct region of the container.
+ * \param[in] n the numerical ID of the inserted particle.
+ * \param[in] (x,y,z) the position vector of the inserted particle.
+ * \param[in] r the radius of the particle.
+ * \param[out] (ai,aj,ak) the periodic image displacement that the particle is
+ * 			  in, with (0,0,0) corresponding to the primary domain.
+ */
+void container_periodic_poly::put(int n,double x,double y,double z,double r,int &ai,int &aj,int &ak) {
+	int ijk;
+	put_locate_block(ijk,x,y,z,ai,aj,ak);
+	id[ijk][co[ijk]]=n;
+	double *pp=p[ijk]+4*co[ijk]++;
+	*(pp++)=x;*(pp++)=y;*(pp++)=z;*pp=r;
+	if(max_radius<r) max_radius=r;
+}
+
+/** Put a particle into the correct region of the container, also recording
+ * into which region it was stored.
+ * \param[in] vo the ordering class in which to record the region.
+ * \param[in] n the numerical ID of the inserted particle.
+ * \param[in] (x,y,z) the position vector of the inserted particle. */
+void container_periodic::put(particle_order &vo,int n,double x,double y,double z) {
+	int ijk;
+	put_locate_block(ijk,x,y,z);
+	id[ijk][co[ijk]]=n;
+	vo.add(ijk,co[ijk]);
+	double *pp=p[ijk]+3*co[ijk]++;
+	*(pp++)=x;*(pp++)=y;*pp=z;
+}
+
+/** Put a particle into the correct region of the container, also recording
+ * into which region it was stored.
+ * \param[in] vo the ordering class in which to record the region.
+ * \param[in] n the numerical ID of the inserted particle.
+ * \param[in] (x,y,z) the position vector of the inserted particle.
+ * \param[in] r the radius of the particle. */
+void container_periodic_poly::put(particle_order &vo,int n,double x,double y,double z,double r) {
+	int ijk;
+	put_locate_block(ijk,x,y,z);
+	id[ijk][co[ijk]]=n;
+	vo.add(ijk,co[ijk]);
+	double *pp=p[ijk]+4*co[ijk]++;
+	*(pp++)=x;*(pp++)=y;*(pp++)=z;*pp=r;
+	if(max_radius<r) max_radius=r;
+}
+
+/** Takes a particle position vector and computes the region index into which
+ * it should be stored. If the container is periodic, then the routine also
+ * maps the particle position to ensure it is in the primary domain. If the
+ * container is not periodic, the routine bails out.
+ * \param[out] ijk the region index.
+ * \param[in,out] (x,y,z) the particle position, remapped into the primary
+ *                        domain if necessary.
+ * \return True if the particle can be successfully placed into the container,
+ * false otherwise. */
+void container_periodic_base::put_locate_block(int &ijk,double &x,double &y,double &z) {
+
+	// Remap particle in the z direction if necessary
+	int k=step_int(z*zsp);
+	if(k<0||k>=nz) {
+		int ak=step_div(k,nz);
+		z-=ak*bz;y-=ak*byz;x-=ak*bxz;k-=ak*nz;
+	}
+
+	// Remap particle in the y direction if necessary
+	int j=step_int(y*ysp);
+	if(j<0||j>=ny) {
+		int aj=step_div(j,ny);
+		y-=aj*by;x-=aj*bxy;j-=aj*ny;
+	}
+
+	// Remap particle in the x direction if necessary
+	ijk=step_int(x*xsp);
+	if(ijk<0||ijk>=nx) {
+		int ai=step_div(ijk,nx);
+		x-=ai*bx;ijk-=ai*nx;
+	}
+
+	// Compute the block index and check memory allocation
+	j+=ey;k+=ez;
+	ijk+=nx*(j+oy*k);
+	if(co[ijk]==mem[ijk]) add_particle_memory(ijk);
+}
+
+/** Takes a particle position vector and computes the region index into which
+ * it should be stored. If the container is periodic, then the routine also
+ * maps the particle position to ensure it is in the primary domain. If the
+ * container is not periodic, the routine bails out.
+ * \param[out] ijk the region index.
+ * \param[in,out] (x,y,z) the particle position, remapped into the primary
+ *                        domain if necessary.
+ * \param[out] (ai,aj,ak) the periodic image displacement that the particle is
+ *                        in, with (0,0,0) corresponding to the primary domain.
+ * \return True if the particle can be successfully placed into the container,
+ * false otherwise. */
+void container_periodic_base::put_locate_block(int &ijk,double &x,double &y,double &z,int &ai,int &aj,int &ak) {
+
+	// Remap particle in the z direction if necessary
+	int k=step_int(z*zsp);
+	if(k<0||k>=nz) {
+		ak=step_div(k,nz);
+		z-=ak*bz;y-=ak*byz;x-=ak*bxz;k-=ak*nz;
+	} else ak=0;
+
+	// Remap particle in the y direction if necessary
+	int j=step_int(y*ysp);
+	if(j<0||j>=ny) {
+		aj=step_div(j,ny);
+		y-=aj*by;x-=aj*bxy;j-=aj*ny;
+	} else aj=0;
+
+	// Remap particle in the x direction if necessary
+	ijk=step_int(x*xsp);
+	if(ijk<0||ijk>=nx) {
+		ai=step_div(ijk,nx);
+		x-=ai*bx;ijk-=ai*nx;
+	} else ai=0;
+
+	// Compute the block index and check memory allocation
+	j+=ey;k+=ez;
+	ijk+=nx*(j+oy*k);
+	if(co[ijk]==mem[ijk]) add_particle_memory(ijk);
+}
+
+/** Takes a position vector and remaps it into the primary domain.
+ * \param[out] (ai,aj,ak) the periodic image displacement that the vector is in,
+ *                        with (0,0,0) corresponding to the primary domain.
+ * \param[out] (ci,cj,ck) the index of the block that the position vector is
+ *                        within, once it has been remapped.
+ * \param[in,out] (x,y,z) the position vector to consider, which is remapped
+ *                        into the primary domain during the routine.
+ * \param[out] ijk the block index that the vector is within. */
+inline void container_periodic_base::remap(int &ai,int &aj,int &ak,int &ci,int &cj,int &ck,double &x,double &y,double &z,int &ijk) {
+
+	// Remap particle in the z direction if necessary
+	ck=step_int(z*zsp);
+	if(ck<0||ck>=nz) {
+		ak=step_div(ck,nz);
+		z-=ak*bz;y-=ak*byz;x-=ak*bxz;ck-=ak*nz;
+	} else ak=0;
+
+	// Remap particle in the y direction if necessary
+	cj=step_int(y*ysp);
+	if(cj<0||cj>=ny) {
+		aj=step_div(cj,ny);
+		y-=aj*by;x-=aj*bxy;cj-=aj*ny;
+	} else aj=0;
+
+	// Remap particle in the x direction if necessary
+	ci=step_int(x*xsp);
+	if(ci<0||ci>=nx) {
+		ai=step_div(ci,nx);
+		x-=ai*bx;ci-=ai*nx;
+	} else ai=0;
+
+	cj+=ey;ck+=ez;
+	ijk=ci+nx*(cj+oy*ck);
+}
+
+/** Takes a vector and finds the particle whose Voronoi cell contains that
+ * vector. This is equivalent to finding the particle which is nearest to the
+ * vector.
+ * \param[in] (x,y,z) the vector to test.
+ * \param[out] (rx,ry,rz) the position of the particle whose Voronoi cell
+ *                        contains the vector. This may point to a particle in
+ *                        a periodic image of the primary domain.
+ * \param[out] pid the ID of the particle.
+ * \return True if a particle was found. If the container has no particles,
+ * then the search will not find a Voronoi cell and false is returned. */
+bool container_periodic::find_voronoi_cell(double x,double y,double z,double &rx,double &ry,double &rz,int &pid) {
+	int ai,aj,ak,ci,cj,ck,ijk;
+	particle_record w;
+	double mrs;
+
+	// Remap the vector into the primary domain and then search for the
+	// Voronoi cell that it is within
+	remap(ai,aj,ak,ci,cj,ck,x,y,z,ijk);
+	vc.find_voronoi_cell(x,y,z,ci,cj,ck,ijk,w,mrs);
+
+	if(w.ijk!=-1) {
+
+		// Assemble the position vector of the particle to be returned,
+		// applying a periodic remapping if necessary
+		ci+=w.di;if(ci<0||ci>=nx) ai+=step_div(ci,nx);
+		rx=p[w.ijk][3*w.l]+ak*bxz+aj*bxy+ai*bx;
+		ry=p[w.ijk][3*w.l+1]+ak*byz+aj*by;
+		rz=p[w.ijk][3*w.l+2]+ak*bz;
+		pid=id[w.ijk][w.l];
+		return true;
+	}
+	return false;
+}
+
+/** Takes a vector and finds the particle whose Voronoi cell contains that
+ * vector. Additional wall classes are not considered by this routine.
+ * \param[in] (x,y,z) the vector to test.
+ * \param[out] (rx,ry,rz) the position of the particle whose Voronoi cell
+ *                        contains the vector. If the container is periodic,
+ *                        this may point to a particle in a periodic image of
+ *                        the primary domain.
+ * \param[out] pid the ID of the particle.
+ * \return True if a particle was found. If the container has no particles,
+ * then the search will not find a Voronoi cell and false is returned. */
+bool container_periodic_poly::find_voronoi_cell(double x,double y,double z,double &rx,double &ry,double &rz,int &pid) {
+	int ai,aj,ak,ci,cj,ck,ijk;
+	particle_record w;
+	double mrs;
+
+	// Remap the vector into the primary domain and then search for the
+	// Voronoi cell that it is within
+	remap(ai,aj,ak,ci,cj,ck,x,y,z,ijk);
+	vc.find_voronoi_cell(x,y,z,ci,cj,ck,ijk,w,mrs);
+
+	if(w.ijk!=-1) {
+
+		// Assemble the position vector of the particle to be returned,
+		// applying a periodic remapping if necessary
+		ci+=w.di;if(ci<0||ci>=nx) ai+=step_div(ci,nx);
+		rx=p[w.ijk][4*w.l]+ak*bxz+aj*bxy+ai*bx;
+		ry=p[w.ijk][4*w.l+1]+ak*byz+aj*by;
+		rz=p[w.ijk][4*w.l+2]+ak*bz;
+		pid=id[w.ijk][w.l];
+		return true;
+	}
+	return false;
+}
+
+/** Increase memory for a particular region.
+ * \param[in] i the index of the region to reallocate. */
+void container_periodic_base::add_particle_memory(int i) {
+
+	// Handle the case when no memory has been allocated for this block
+	if(mem[i]==0) {
+		mem[i]=init_mem;
+		id[i]=new int[init_mem];
+		p[i]=new double[ps*init_mem];
+		return;
+	}
+
+	// Otherwise, double the memory allocation for this block. Carry out a
+	// check on the memory allocation size, and print a status message if
+	// requested.
+	int l,nmem(mem[i]<<1);
+	if(nmem>max_particle_memory)
+		voro_fatal_error("Absolute maximum memory allocation exceeded",VOROPP_MEMORY_ERROR);
+#if VOROPP_VERBOSE >=3
+	fprintf(stderr,"Particle memory in region %d scaled up to %d\n",i,nmem);
+#endif
+
+	// Allocate new memory and copy in the contents of the old arrays
+	int *idp=new int[nmem];
+	for(l=0;l<co[i];l++) idp[l]=id[i][l];
+	double *pp=new double[ps*nmem];
+	for(l=0;l<ps*co[i];l++) pp[l]=p[i][l];
+
+	// Update pointers and delete old arrays
+	mem[i]=nmem;
+	delete [] id[i];id[i]=idp;
+	delete [] p[i];p[i]=pp;
+}
+
+/** Import a list of particles from an open file stream into the container.
+ * Entries of four numbers (Particle ID, x position, y position, z position)
+ * are searched for. If the file cannot be successfully read, then the routine
+ * causes a fatal error.
+ * \param[in] fp the file handle to read from. */
+void container_periodic::import(FILE *fp) {
+	int i,j;
+	double x,y,z;
+	while((j=fscanf(fp,"%d %lg %lg %lg",&i,&x,&y,&z))==4) put(i,x,y,z);
+	if(j!=EOF) voro_fatal_error("File import error",VOROPP_FILE_ERROR);
+}
+
+/** Import a list of particles from an open file stream, also storing the order
+ * of that the particles are read. Entries of four numbers (Particle ID, x
+ * position, y position, z position) are searched for. If the file cannot be
+ * successfully read, then the routine causes a fatal error.
+ * \param[in,out] vo a reference to an ordering class to use.
+ * \param[in] fp the file handle to read from. */
+void container_periodic::import(particle_order &vo,FILE *fp) {
+	int i,j;
+	double x,y,z;
+	while((j=fscanf(fp,"%d %lg %lg %lg",&i,&x,&y,&z))==4) put(vo,i,x,y,z);
+	if(j!=EOF) voro_fatal_error("File import error",VOROPP_FILE_ERROR);
+}
+
+/** Import a list of particles from an open file stream into the container.
+ * Entries of five numbers (Particle ID, x position, y position, z position,
+ * radius) are searched for. If the file cannot be successfully read, then the
+ * routine causes a fatal error.
+ * \param[in] fp the file handle to read from. */
+void container_periodic_poly::import(FILE *fp) {
+	int i,j;
+	double x,y,z,r;
+	while((j=fscanf(fp,"%d %lg %lg %lg %lg",&i,&x,&y,&z,&r))==5) put(i,x,y,z,r);
+	if(j!=EOF) voro_fatal_error("File import error",VOROPP_FILE_ERROR);
+}
+
+/** Import a list of particles from an open file stream, also storing the order
+ * of that the particles are read. Entries of four numbers (Particle ID, x
+ * position, y position, z position, radius) are searched for. If the file
+ * cannot be successfully read, then the routine causes a fatal error.
+ * \param[in,out] vo a reference to an ordering class to use.
+ * \param[in] fp the file handle to read from. */
+void container_periodic_poly::import(particle_order &vo,FILE *fp) {
+	int i,j;
+	double x,y,z,r;
+	while((j=fscanf(fp,"%d %lg %lg %lg %lg",&i,&x,&y,&z,&r))==5) put(vo,i,x,y,z,r);
+	if(j!=EOF) voro_fatal_error("File import error",VOROPP_FILE_ERROR);
+}
+
+/** Outputs the a list of all the container regions along with the number of
+ * particles stored within each. */
+void container_periodic_base::region_count() {
+	int i,j,k,*cop=co;
+	for(k=0;k<nz;k++) for(j=0;j<ny;j++) for(i=0;i<nx;i++)
+		printf("Region (%d,%d,%d): %d particles\n",i,j,k,*(cop++));
+}
+
+/** Clears a container of particles. */
+void container_periodic::clear() {
+	for(int *cop=co;cop<co+nxyz;cop++) *cop=0;
+}
+
+/** Clears a container of particles, also clearing resetting the maximum radius
+ * to zero. */
+void container_periodic_poly::clear() {
+	for(int *cop=co;cop<co+nxyz;cop++) *cop=0;
+	max_radius=0;
+}
+
+/** Computes all the Voronoi cells and saves customized information about them.
+ * \param[in] format the custom output string to use.
+ * \param[in] fp a file handle to write to. */
+void container_periodic::print_custom(const char *format,FILE *fp) {
+	c_loop_all_periodic vl(*this);
+	print_custom(vl,format,fp);
+}
+
+/** Computes all the Voronoi cells and saves customized
+ * information about them.
+ * \param[in] format the custom output string to use.
+ * \param[in] fp a file handle to write to. */
+void container_periodic_poly::print_custom(const char *format,FILE *fp) {
+	c_loop_all_periodic vl(*this);
+	print_custom(vl,format,fp);
+}
+
+/** Computes all the Voronoi cells and saves customized information about them.
+ * \param[in] format the custom output string to use.
+ * \param[in] filename the name of the file to write to. */
+void container_periodic::print_custom(const char *format,const char *filename) {
+	FILE *fp=safe_fopen(filename,"w");
+	print_custom(format,fp);
+	fclose(fp);
+}
+
+/** Computes all the Voronoi cells and saves customized
+ * information about them
+ * \param[in] format the custom output string to use.
+ * \param[in] filename the name of the file to write to. */
+void container_periodic_poly::print_custom(const char *format,const char *filename) {
+	FILE *fp=safe_fopen(filename,"w");
+	print_custom(format,fp);
+	fclose(fp);
+}
+
+/** Computes all of the Voronoi cells in the container, but does nothing
+ * with the output. It is useful for measuring the pure computation time
+ * of the Voronoi algorithm, without any additional calculations such as
+ * volume evaluation or cell output. */
+void container_periodic::compute_all_cells() {
+	voronoicell c;
+	c_loop_all_periodic vl(*this);
+	if(vl.start()) do compute_cell(c,vl);
+	while(vl.inc());
+}
+
+/** Computes all of the Voronoi cells in the container, but does nothing
+ * with the output. It is useful for measuring the pure computation time
+ * of the Voronoi algorithm, without any additional calculations such as
+ * volume evaluation or cell output. */
+void container_periodic_poly::compute_all_cells() {
+	voronoicell c;
+	c_loop_all_periodic vl(*this);
+	if(vl.start()) do compute_cell(c,vl);while(vl.inc());
+}
+
+/** Calculates all of the Voronoi cells and sums their volumes. In most cases
+ * without walls, the sum of the Voronoi cell volumes should equal the volume
+ * of the container to numerical precision.
+ * \return The sum of all of the computed Voronoi volumes. */
+double container_periodic::sum_cell_volumes() {
+	voronoicell c;
+	double vol=0;
+	c_loop_all_periodic vl(*this);
+	if(vl.start()) do if(compute_cell(c,vl)) vol+=c.volume();while(vl.inc());
+	return vol;
+}
+
+/** Calculates all of the Voronoi cells and sums their volumes. In most cases
+ * without walls, the sum of the Voronoi cell volumes should equal the volume
+ * of the container to numerical precision.
+ * \return The sum of all of the computed Voronoi volumes. */
+double container_periodic_poly::sum_cell_volumes() {
+	voronoicell c;
+	double vol=0;
+	c_loop_all_periodic vl(*this);
+	if(vl.start()) do if(compute_cell(c,vl)) vol+=c.volume();while(vl.inc());
+	return vol;
+}
+
+/** This routine creates all periodic images of the particles. It is meant for
+ * diagnostic purposes only, since usually periodic images are dynamically
+ * created in when they are referenced. */
+void container_periodic_base::create_all_images() {
+	int i,j,k;
+	for(k=0;k<oz;k++) for(j=0;j<oy;j++) for(i=0;i<nx;i++) create_periodic_image(i,j,k);
+}
+
+/** Checks that the particles within each block lie within that block's bounds.
+ * This is useful for diagnosing problems with periodic image computation. */
+void container_periodic_base::check_compartmentalized() {
+	int c,l,i,j,k;
+	double mix,miy,miz,max,may,maz,*pp;
+	for(k=l=0;k<oz;k++) for(j=0;j<oy;j++) for(i=0;i<nx;i++,l++) if(mem[l]>0) {
+
+		// Compute the block's bounds, adding in a small tolerance
+		mix=i*boxx-tolerance;max=mix+boxx+tolerance;
+		miy=(j-ey)*boxy-tolerance;may=miy+boxy+tolerance;
+		miz=(k-ez)*boxz-tolerance;maz=miz+boxz+tolerance;
+
+		// Print entries for any particles that lie outside the block's
+		// bounds
+		for(pp=p[l],c=0;c<co[l];c++,pp+=ps) if(*pp<mix||*pp>max||pp[1]<miy||pp[1]>may||pp[2]<miz||pp[2]>maz)
+			printf("%d %d %d %d %f %f %f %f %f %f %f %f %f\n",
+			       id[l][c],i,j,k,*pp,pp[1],pp[2],mix,max,miy,may,miz,maz);
+	}
+}
+
+/** Creates particles within an image block that is aligned with the primary
+ * domain in the z axis. In this case, the image block may be comprised of
+ * particles from two primary blocks. The routine considers these two primary
+ * blocks, and adds the needed particles to the image. The remaining particles
+ * from the primary blocks are also filled into the neighboring images.
+ * \param[in] (di,dj,dk) the index of the block to consider. The z index must
+ *			 satisfy ez<=dk<wz. */
+void container_periodic_base::create_side_image(int di,int dj,int dk) {
+	int l,dijk=di+nx*(dj+oy*dk),odijk,ima=step_div(dj-ey,ny);
+	int qua=di+step_int(-ima*bxy*xsp),quadiv=step_div(qua,nx);
+	int fi=qua-quadiv*nx,fijk=fi+nx*(dj-ima*ny+oy*dk);
+	double dis=ima*bxy+quadiv*bx,switchx=di*boxx-ima*bxy-quadiv*bx,adis;
+
+	// Left image computation
+	if((img[dijk]&1)==0) {
+		if(di>0) {
+			odijk=dijk-1;adis=dis;
+		} else {
+			odijk=dijk+nx-1;adis=dis+bx;
+		}
+		img[odijk]|=2;
+		for(l=0;l<co[fijk];l++) {
+			if(p[fijk][ps*l]>switchx) put_image(dijk,fijk,l,dis,by*ima,0);
+			else put_image(odijk,fijk,l,adis,by*ima,0);
+		}
+	}
+
+	// Right image computation
+	if((img[dijk]&2)==0) {
+		if(fi==nx-1) {
+			fijk+=1-nx;switchx+=(1-nx)*boxx;dis+=bx;
+		} else {
+			fijk++;switchx+=boxx;
+		}
+		if(di==nx-1) {
+			odijk=dijk-nx+1;adis=dis-bx;
+		} else {
+			odijk=dijk+1;adis=dis;
+		}
+		img[odijk]|=1;
+		for(l=0;l<co[fijk];l++) {
+			if(p[fijk][ps*l]<switchx) put_image(dijk,fijk,l,dis,by*ima,0);
+			else put_image(odijk,fijk,l,adis,by*ima,0);
+		}
+	}
+
+	// All contributions to the block now added, so set both two bits of
+	// the image information
+	img[dijk]=3;
+}
+
+/** Creates particles within an image block that is not aligned with the
+ * primary domain in the z axis. In this case, the image block may be comprised
+ * of particles from four primary blocks. The routine considers these four
+ * primary blocks, and adds the needed particles to the image. The remaining
+ * particles from the primary blocks are also filled into the neighboring
+ * images.
+ * \param[in] (di,dj,dk) the index of the block to consider. The z index must
+ *			 satisfy dk<ez or dk>=wz. */
+void container_periodic_base::create_vertical_image(int di,int dj,int dk) {
+	int l,dijk=di+nx*(dj+oy*dk),dijkl,dijkr,ima=step_div(dk-ez,nz);
+	int qj=dj+step_int(-ima*byz*ysp),qjdiv=step_div(qj-ey,ny);
+	int qi=di+step_int((-ima*bxz-qjdiv*bxy)*xsp),qidiv=step_div(qi,nx);
+	int fi=qi-qidiv*nx,fj=qj-qjdiv*ny,fijk=fi+nx*(fj+oy*(dk-ima*nz)),fijk2;
+	double disy=ima*byz+qjdiv*by,switchy=(dj-ey)*boxy-ima*byz-qjdiv*by;
+	double disx=ima*bxz+qjdiv*bxy+qidiv*bx,switchx=di*boxx-ima*bxz-qjdiv*bxy-qidiv*bx;
+	double switchx2,disxl,disxr,disx2,disxr2;
+
+	if(di==0) {dijkl=dijk+nx-1;disxl=disx+bx;}
+	else {dijkl=dijk-1;disxl=disx;}
+
+	if(di==nx-1) {dijkr=dijk-nx+1;disxr=disx-bx;}
+	else {dijkr=dijk+1;disxr=disx;}
+
+	// Down-left image computation
+	bool y_exist=dj!=0;
+	if((img[dijk]&1)==0) {
+		img[dijkl]|=2;
+		if(y_exist) {
+			img[dijkl-nx]|=8;
+			img[dijk-nx]|=4;
+		}
+		for(l=0;l<co[fijk];l++) {
+			if(p[fijk][ps*l+1]>switchy) {
+				if(p[fijk][ps*l]>switchx) put_image(dijk,fijk,l,disx,disy,bz*ima);
+				else put_image(dijkl,fijk,l,disxl,disy,bz*ima);
+			} else {
+				if(!y_exist) continue;
+				if(p[fijk][ps*l]>switchx) put_image(dijk-nx,fijk,l,disx,disy,bz*ima);
+				else put_image(dijkl-nx,fijk,l,disxl,disy,bz*ima);
+			}
+		}
+	}
+
+	// Down-right image computation
+	if((img[dijk]&2)==0) {
+		if(fi==nx-1) {
+			fijk2=fijk+1-nx;switchx2=switchx+(1-nx)*boxx;disx2=disx+bx;disxr2=disxr+bx;
+		} else {
+			fijk2=fijk+1;switchx2=switchx+boxx;disx2=disx;disxr2=disxr;
+		}
+		img[dijkr]|=1;
+		if(y_exist) {
+			img[dijkr-nx]|=4;
+			img[dijk-nx]|=8;
+		}
+		for(l=0;l<co[fijk2];l++) {
+			if(p[fijk2][ps*l+1]>switchy) {
+				if(p[fijk2][ps*l]>switchx2) put_image(dijkr,fijk2,l,disxr2,disy,bz*ima);
+				else put_image(dijk,fijk2,l,disx2,disy,bz*ima);
+			} else {
+				if(!y_exist) continue;
+				if(p[fijk2][ps*l]>switchx2) put_image(dijkr-nx,fijk2,l,disxr2,disy,bz*ima);
+				else put_image(dijk-nx,fijk2,l,disx2,disy,bz*ima);
+			}
+		}
+	}
+
+	// Recomputation of some intermediate quantities for boundary cases
+	if(fj==wy-1) {
+		fijk+=nx*(1-ny)-fi;
+		switchy+=(1-ny)*boxy;
+		disy+=by;
+		qi=di+step_int(-(ima*bxz+(qjdiv+1)*bxy)*xsp);
+		int dqidiv=step_div(qi,nx)-qidiv;qidiv+=dqidiv;
+		fi=qi-qidiv*nx;
+		fijk+=fi;
+		disx+=bxy+bx*dqidiv;
+		disxl+=bxy+bx*dqidiv;
+		disxr+=bxy+bx*dqidiv;
+		switchx-=bxy+bx*dqidiv;
+	} else {
+		fijk+=nx;switchy+=boxy;
+	}
+
+	// Up-left image computation
+	y_exist=dj!=oy-1;
+	if((img[dijk]&4)==0) {
+		img[dijkl]|=8;
+		if(y_exist) {
+			img[dijkl+nx]|=2;
+			img[dijk+nx]|=1;
+		}
+		for(l=0;l<co[fijk];l++) {
+			if(p[fijk][ps*l+1]>switchy) {
+				if(!y_exist) continue;
+				if(p[fijk][ps*l]>switchx) put_image(dijk+nx,fijk,l,disx,disy,bz*ima);
+				else put_image(dijkl+nx,fijk,l,disxl,disy,bz*ima);
+			} else {
+				if(p[fijk][ps*l]>switchx) put_image(dijk,fijk,l,disx,disy,bz*ima);
+				else put_image(dijkl,fijk,l,disxl,disy,bz*ima);
+			}
+		}
+	}
+
+	// Up-right image computation
+	if((img[dijk]&8)==0) {
+		if(fi==nx-1) {
+			fijk2=fijk+1-nx;switchx2=switchx+(1-nx)*boxx;disx2=disx+bx;disxr2=disxr+bx;
+		} else {
+			fijk2=fijk+1;switchx2=switchx+boxx;disx2=disx;disxr2=disxr;
+		}
+		img[dijkr]|=4;
+		if(y_exist) {
+			img[dijkr+nx]|=1;
+			img[dijk+nx]|=2;
+		}
+		for(l=0;l<co[fijk2];l++) {
+			if(p[fijk2][ps*l+1]>switchy) {
+				if(!y_exist) continue;
+				if(p[fijk2][ps*l]>switchx2) put_image(dijkr+nx,fijk2,l,disxr2,disy,bz*ima);
+				else put_image(dijk+nx,fijk2,l,disx2,disy,bz*ima);
+			} else {
+				if(p[fijk2][ps*l]>switchx2) put_image(dijkr,fijk2,l,disxr2,disy,bz*ima);
+				else put_image(dijk,fijk2,l,disx2,disy,bz*ima);
+			}
+		}
+	}
+
+	// All contributions to the block now added, so set all four bits of
+	// the image information
+	img[dijk]=15;
+}
+
+/** Copies a particle position from the primary domain into an image block.
+ * \param[in] reg the block index within the primary domain that the particle
+ *                is within.
+ * \param[in] fijk the index of the image block.
+ * \param[in] l the index of the particle entry within the primary block.
+ * \param[in] (dx,dy,dz) the displacement vector to add to the particle. */
+void container_periodic_base::put_image(int reg,int fijk,int l,double dx,double dy,double dz) {
+	if(co[reg]==mem[reg]) add_particle_memory(reg);
+	double *p1=p[reg]+ps*co[reg],*p2=p[fijk]+ps*l;
+	*(p1++)=*(p2++)+dx;
+	*(p1++)=*(p2++)+dy;
+	*p1=*p2+dz;
+	if(ps==4) *(++p1)=*(++p2);
+	id[reg][co[reg]++]=id[fijk][l];
+}
+
+}
diff -ru --new-file blender-2.76b.old/extern/voro++/src/container_prd.hh blender-2.76b/extern/voro++/src/container_prd.hh
--- blender-2.76b.old/extern/voro++/src/container_prd.hh	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/container_prd.hh	2016-01-27 19:04:59.119706651 +0300
@@ -0,0 +1,654 @@
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \file container_prd.hh
+ * \brief Header file for the container_periodic_base and related classes. */
+
+#ifndef VOROPP_CONTAINER_PRD_HH
+#define VOROPP_CONTAINER_PRD_HH
+
+#include <cstdio>
+#include <vector>
+
+#include "config.hh"
+#include "common.hh"
+#include "v_base.hh"
+#include "cell.hh"
+#include "c_loops.hh"
+#include "v_compute.hh"
+#include "unitcell.hh"
+#include "rad_option.hh"
+
+namespace voro {
+
+/** \brief Class for representing a particle system in a 3D periodic
+ * non-orthogonal periodic domain.
+ *
+ * This class represents a particle system in a three-dimensional
+ * non-orthogonal periodic domain. The domain is defined by three periodicity
+ * vectors (bx,0,0), (bxy,by,0), and (bxz,byz,bz) that represent a
+ * parallelepiped. Internally, the class stores particles in the box 0<x<bx,
+ * 0<y<by, 0<z<bz, and constructs periodic images of particles that displaced
+ * by the three periodicity vectors when they are necessary for the
+ * computation. The internal memory structure for this class is significantly
+ * different from the container_base class in order to handle the dynamic
+ * construction of these periodic images.
+ *
+ * The class is derived from the unitcell class, which encapsulates information
+ * about the domain geometry, and the voro_base class, which encapsulates
+ * information about the underlying computational grid. */
+class container_periodic_base : public unitcell, public voro_base {
+	public:
+		/** The lower y index (inclusive) of the primary domain within
+		 * the block structure. */
+		int ey;
+		/** The lower z index (inclusive) of the primary domain within
+		 * the block structure. */
+		int ez;
+		/** The upper y index (exclusive) of the primary domain within
+		 * the block structure. */
+		int wy;
+		/** The upper z index (exclusive) of the primary domain within
+		 * the block structure. */
+		int wz;
+		/** The total size of the block structure (including images) in
+		 * the y direction. */
+		int oy;
+		/** The total size of the block structure (including images) in
+		 * the z direction. */
+		int oz;
+		/** The total number of blocks. */
+		int oxyz;
+		/** This array holds the numerical IDs of each particle in each
+		 * computational box. */
+		int **id;
+		/** A two dimensional array holding particle positions. For the
+		 * derived container_poly class, this also holds particle
+		 * radii. */
+		double **p;
+		/** This array holds the number of particles within each
+		 * computational box of the container. */
+		int *co;
+		/** This array holds the maximum amount of particle memory for
+		 * each computational box of the container. If the number of
+		 * particles in a particular box ever approaches this limit,
+		 * more is allocated using the add_particle_memory() function.
+		 */
+		int *mem;
+		/** An array holding information about periodic image
+		 * construction at a given location. */
+		char *img;
+		/** The initial amount of memory to allocate for particles
+		 * for each block. */
+		const int init_mem;
+		/** The amount of memory in the array structure for each
+		 * particle. This is set to 3 when the basic class is
+		 * initialized, so that the array holds (x,y,z) positions. If
+		 * the container class is initialized as part of the derived
+		 * class container_poly, then this is set to 4, to also hold
+		 * the particle radii. */
+		const int ps;
+		container_periodic_base(double bx_,double bxy_,double by_,double bxz_,double byz_,double bz_,
+				int nx_,int ny_,int nz_,int init_mem_,int ps);
+		~container_periodic_base();
+		/** Prints all particles in the container, including those that
+		 * have been constructed in image blocks. */
+		inline void print_all_particles() {
+			int ijk,q;
+			for(ijk=0;ijk<oxyz;ijk++) for(q=0;q<co[ijk];q++)
+				printf("%d %g %g %g\n",id[ijk][q],p[ijk][ps*q],p[ijk][ps*q+1],p[ijk][ps*q+2]);
+		}
+		void region_count();
+		/** Initializes the Voronoi cell prior to a compute_cell
+		 * operation for a specific particle being carried out by a
+		 * voro_compute class. The cell is initialized to be the
+		 * pre-computed unit Voronoi cell based on planes formed by
+		 * periodic images of the particle.
+		 * \param[in,out] c a reference to a voronoicell object.
+		 * \param[in] ijk the block that the particle is within.
+		 * \param[in] q the index of the particle within its block.
+		 * \param[in] (ci,cj,ck) the coordinates of the block in the
+		 * 			 container coordinate system.
+		 * \param[out] (i,j,k) the coordinates of the test block
+		 * 		       relative to the voro_compute
+		 * 		       coordinate system.
+		 * \param[out] (x,y,z) the position of the particle.
+		 * \param[out] disp a block displacement used internally by the
+		 *		    compute_cell routine.
+		 * \return False if the plane cuts applied by walls completely
+		 * removed the cell, true otherwise. */
+		template<class v_cell>
+		inline bool initialize_voronoicell(v_cell &c,int ijk,int q,int ci,int cj,int ck,int &i,int &j,int &k,double &x,double &y,double &z,int &disp) {
+			c=unit_voro;
+			double *pp=p[ijk]+ps*q;
+			x=*(pp++);y=*(pp++);z=*pp;
+			i=nx;j=ey;k=ez;
+			return true;
+		}
+		/** Initializes parameters for a find_voronoi_cell call within
+		 * the voro_compute template.
+		 * \param[in] (ci,cj,ck) the coordinates of the test block in
+		 * 			 the container coordinate system.
+		 * \param[in] ijk the index of the test block
+		 * \param[out] (i,j,k) the coordinates of the test block
+		 * 		       relative to the voro_compute
+		 * 		       coordinate system.
+		 * \param[out] disp a block displacement used internally by the
+		 *		    find_voronoi_cell routine (but not needed
+		 *		    in this instance.) */
+		inline void initialize_search(int ci,int cj,int ck,int ijk,int &i,int &j,int &k,int &disp) {
+			i=nx;j=ey;k=ez;
+		}
+		/** Returns the position of a particle currently being computed
+		 * relative to the computational block that it is within. It is
+		 * used to select the optimal worklist entry to use.
+		 * \param[in] (x,y,z) the position of the particle.
+		 * \param[in] (ci,cj,ck) the block that the particle is within.
+		 * \param[out] (fx,fy,fz) the position relative to the block.
+		 */
+		inline void frac_pos(double x,double y,double z,double ci,double cj,double ck,double &fx,double &fy,double &fz) {
+			fx=x-boxx*ci;
+			fy=y-boxy*(cj-ey);
+			fz=z-boxz*(ck-ez);
+		}
+		/** Calculates the index of block in the container structure
+		 * corresponding to given coordinates.
+		 * \param[in] (ci,cj,ck) the coordinates of the original block
+		 * 			 in the current computation, relative
+		 * 			 to the container coordinate system.
+		 * \param[in] (ei,ej,ek) the displacement of the current block
+		 * 			 from the original block.
+		 * \param[in,out] (qx,qy,qz) the periodic displacement that
+		 * 			     must be added to the particles
+		 * 			     within the computed block.
+		 * \param[in] disp a block displacement used internally by the
+		 * 		    find_voronoi_cell and compute_cell routines
+		 * 		    (but not needed in this instance.)
+		 * \return The block index. */
+		inline int region_index(int ci,int cj,int ck,int ei,int ej,int ek,double &qx,double &qy,double &qz,int &disp) {
+			int qi=ci+(ei-nx),qj=cj+(ej-ey),qk=ck+(ek-ez);
+			int iv(step_div(qi,nx));if(iv!=0) {qx=iv*bx;qi-=nx*iv;} else qx=0;
+			create_periodic_image(qi,qj,qk);
+			return qi+nx*(qj+oy*qk);
+		}
+		void create_all_images();
+		void check_compartmentalized();
+	protected:
+		void add_particle_memory(int i);
+		void put_locate_block(int &ijk,double &x,double &y,double &z);
+		void put_locate_block(int &ijk,double &x,double &y,double &z,int &ai,int &aj,int &ak);
+		/** Creates particles within an image block by copying them
+		 * from the primary domain and shifting them. If the given
+		 * block is aligned with the primary domain in the z-direction,
+		 * the routine calls the simpler create_side_image routine
+		 * where the image block may comprise of particles from up to
+		 * two primary blocks. Otherwise is calls the more complex
+		 * create_vertical_image where the image block may comprise of
+		 * particles from up to four primary blocks.
+		 * \param[in] (di,dj,dk) the coordinates of the image block to
+		 *                       create. */
+		inline void create_periodic_image(int di,int dj,int dk) {
+			if(di<0||di>=nx||dj<0||dj>=oy||dk<0||dk>=oz)
+				voro_fatal_error("Constructing periodic image for nonexistent point",VOROPP_INTERNAL_ERROR);
+			if(dk>=ez&&dk<wz) {
+				if(dj<ey||dj>=wy) create_side_image(di,dj,dk);
+			} else create_vertical_image(di,dj,dk);
+		}
+		void create_side_image(int di,int dj,int dk);
+		void create_vertical_image(int di,int dj,int dk);
+		void put_image(int reg,int fijk,int l,double dx,double dy,double dz);
+		inline void remap(int &ai,int &aj,int &ak,int &ci,int &cj,int &ck,double &x,double &y,double &z,int &ijk);
+};
+
+/** \brief Extension of the container_periodic_base class for computing regular
+ * Voronoi tessellations.
+ *
+ * This class is an extension of the container_periodic_base that has routines
+ * specifically for computing the regular Voronoi tessellation with no
+ * dependence on particle radii. */
+class container_periodic : public container_periodic_base, public radius_mono {
+	public:
+		container_periodic(double bx_,double bxy_,double by_,double bxz_,double byz_,double bz_,
+				int nx_,int ny_,int nz_,int init_mem_);
+		void clear();
+		void put(int n,double x,double y,double z);
+		void put(int n,double x,double y,double z,int &ai,int &aj,int &ak);
+		void put(particle_order &vo,int n,double x,double y,double z);
+		void import(FILE *fp=stdin);
+		void import(particle_order &vo,FILE *fp=stdin);
+		/** Imports a list of particles from an open file stream into
+		 * the container. Entries of four numbers (Particle ID, x
+		 * position, y position, z position) are searched for. If the
+		 * file cannot be successfully read, then the routine causes a
+		 * fatal error.
+		 * \param[in] filename the name of the file to open and read
+		 *                     from. */
+		inline void import(const char* filename) {
+			FILE *fp=safe_fopen(filename,"r");
+			import(fp);
+			fclose(fp);
+		}
+		/** Imports a list of particles from an open file stream into
+		 * the container. Entries of four numbers (Particle ID, x
+		 * position, y position, z position) are searched for. In
+		 * addition, the order in which particles are read is saved
+		 * into an ordering class. If the file cannot be successfully
+		 * read, then the routine causes a fatal error.
+		 * \param[in,out] vo the ordering class to use.
+		 * \param[in] filename the name of the file to open and read
+		 *                     from. */
+		inline void import(particle_order &vo,const char* filename) {
+			FILE *fp=safe_fopen(filename,"r");
+			import(vo,fp);
+			fclose(fp);
+		}
+		void compute_all_cells();
+		double sum_cell_volumes();
+		/** Dumps particle IDs and positions to a file.
+		 * \param[in] vl the loop class to use.
+		 * \param[in] fp a file handle to write to. */
+		template<class c_loop>
+		void draw_particles(c_loop &vl,FILE *fp) {
+			double *pp;
+			if(vl.start()) do {
+				pp=p[vl.ijk]+3*vl.q;
+				fprintf(fp,"%d %g %g %g\n",id[vl.ijk][vl.q],*pp,pp[1],pp[2]);
+			} while(vl.inc());
+		}
+		/** Dumps all of the particle IDs and positions to a file.
+		 * \param[in] fp a file handle to write to. */
+		inline void draw_particles(FILE *fp=stdout) {
+			c_loop_all_periodic vl(*this);
+			draw_particles(vl,fp);
+		}
+		/** Dumps all of the particle IDs and positions to a file.
+		 * \param[in] filename the name of the file to write to. */
+		inline void draw_particles(const char *filename) {
+			FILE *fp=safe_fopen(filename,"w");
+			draw_particles(fp);
+			fclose(fp);
+		}
+		/** Dumps particle positions in POV-Ray format.
+		 * \param[in] vl the loop class to use.
+		 * \param[in] fp a file handle to write to. */
+		template<class c_loop>
+		void draw_particles_pov(c_loop &vl,FILE *fp) {
+			double *pp;
+			if(vl.start()) do {
+				pp=p[vl.ijk]+3*vl.q;
+				fprintf(fp,"// id %d\nsphere{<%g,%g,%g>,s}\n",
+						id[vl.ijk][vl.q],*pp,pp[1],pp[2]);
+			} while(vl.inc());
+		}
+		/** Dumps all particle positions in POV-Ray format.
+		 * \param[in] fp a file handle to write to. */
+		inline void draw_particles_pov(FILE *fp=stdout) {
+			c_loop_all_periodic vl(*this);
+			draw_particles_pov(vl,fp);
+		}
+		/** Dumps all particle positions in POV-Ray format.
+		 * \param[in] filename the name of the file to write to. */
+		inline void draw_particles_pov(const char *filename) {
+			FILE *fp=safe_fopen(filename,"w");
+			draw_particles_pov(fp);
+			fclose(fp);
+		}
+		/** Computes Voronoi cells and saves the output in gnuplot
+		 * format.
+		 * \param[in] vl the loop class to use.
+		 * \param[in] fp a file handle to write to. */
+		template<class c_loop>
+		void draw_cells_gnuplot(c_loop &vl,FILE *fp) {
+			voronoicell c;double *pp;
+			if(vl.start()) do if(compute_cell(c,vl)) {
+				pp=p[vl.ijk]+ps*vl.q;
+				c.draw_gnuplot(*pp,pp[1],pp[2],fp);
+			} while(vl.inc());
+		}
+		/** Computes all Voronoi cells and saves the output in gnuplot
+		 * format.
+		 * \param[in] fp a file handle to write to. */
+		inline void draw_cells_gnuplot(FILE *fp=stdout) {
+			c_loop_all_periodic vl(*this);
+			draw_cells_gnuplot(vl,fp);
+		}
+		/** Compute all Voronoi cells and saves the output in gnuplot
+		 * format.
+		 * \param[in] filename the name of the file to write to. */
+		inline void draw_cells_gnuplot(const char *filename) {
+			FILE *fp=safe_fopen(filename,"w");
+			draw_cells_gnuplot(fp);
+			fclose(fp);
+		}
+		/** Computes Voronoi cells and saves the output in POV-Ray
+		 * format.
+		 * \param[in] vl the loop class to use.
+		 * \param[in] fp a file handle to write to. */
+		template<class c_loop>
+		void draw_cells_pov(c_loop &vl,FILE *fp) {
+			voronoicell c;double *pp;
+			if(vl.start()) do if(compute_cell(c,vl)) {
+				fprintf(fp,"// cell %d\n",id[vl.ijk][vl.q]);
+				pp=p[vl.ijk]+ps*vl.q;
+				c.draw_pov(*pp,pp[1],pp[2],fp);
+			} while(vl.inc());
+		}
+		/** Computes all Voronoi cells and saves the output in POV-Ray
+		 * format.
+		 * \param[in] fp a file handle to write to. */
+		inline void draw_cells_pov(FILE *fp=stdout) {
+			c_loop_all_periodic vl(*this);
+			draw_cells_pov(vl,fp);
+		}
+		/** Computes all Voronoi cells and saves the output in POV-Ray
+		 * format.
+		 * \param[in] filename the name of the file to write to. */
+		inline void draw_cells_pov(const char *filename) {
+			FILE *fp=safe_fopen(filename,"w");
+			draw_cells_pov(fp);
+			fclose(fp);
+		}
+		/** Computes the Voronoi cells and saves customized information
+		 * about them.
+		 * \param[in] vl the loop class to use.
+		 * \param[in] format the custom output string to use.
+		 * \param[in] fp a file handle to write to. */
+		template<class c_loop>
+		void print_custom(c_loop &vl,const char *format,FILE *fp) {
+			int ijk,q;double *pp;
+			if(contains_neighbor(format)) {
+				voronoicell_neighbor c;
+				if(vl.start()) do if(compute_cell(c,vl)) {
+					ijk=vl.ijk;q=vl.q;pp=p[ijk]+ps*q;
+					c.output_custom(format,id[ijk][q],*pp,pp[1],pp[2],default_radius,fp);
+				} while(vl.inc());
+			} else {
+				voronoicell c;
+				if(vl.start()) do if(compute_cell(c,vl)) {
+					ijk=vl.ijk;q=vl.q;pp=p[ijk]+ps*q;
+					c.output_custom(format,id[ijk][q],*pp,pp[1],pp[2],default_radius,fp);
+				} while(vl.inc());
+			}
+		}
+		void print_custom(const char *format,FILE *fp=stdout);
+		void print_custom(const char *format,const char *filename);
+		bool find_voronoi_cell(double x,double y,double z,double &rx,double &ry,double &rz,int &pid);
+		/** Computes the Voronoi cell for a particle currently being
+		 * referenced by a loop class.
+		 * \param[out] c a Voronoi cell class in which to store the
+		 * 		 computed cell.
+		 * \param[in] vl the loop class to use.
+		 * \return True if the cell was computed. If the cell cannot be
+		 * computed because it was removed entirely for some reason,
+		 * then the routine returns false. */
+		template<class v_cell,class c_loop>
+		inline bool compute_cell(v_cell &c,c_loop &vl) {
+			return vc.compute_cell(c,vl.ijk,vl.q,vl.i,vl.j,vl.k);
+		}
+		/** Computes the Voronoi cell for given particle.
+		 * \param[out] c a Voronoi cell class in which to store the
+		 * 		 computed cell.
+		 * \param[in] ijk the block that the particle is within.
+		 * \param[in] q the index of the particle within the block.
+		 * \return True if the cell was computed. If the cell cannot be
+		 * computed because it was removed entirely for some reason,
+		 * then the routine returns false. */
+		template<class v_cell>
+		inline bool compute_cell(v_cell &c,int ijk,int q) {
+			int k(ijk/(nx*oy)),ijkt(ijk-(nx*oy)*k),j(ijkt/nx),i(ijkt-j*nx);
+			return vc.compute_cell(c,ijk,q,i,j,k);
+		}
+		/** Computes the Voronoi cell for a ghost particle at a given
+		 * location.
+		 * \param[out] c a Voronoi cell class in which to store the
+		 * 		 computed cell.
+		 * \param[in] (x,y,z) the location of the ghost particle.
+		 * \return True if the cell was computed. If the cell cannot be
+		 * computed, if it is removed entirely by a wall or boundary
+		 * condition, then the routine returns false. */
+		template<class v_cell>
+		inline bool compute_ghost_cell(v_cell &c,double x,double y,double z) {
+			int ijk;
+			put_locate_block(ijk,x,y,z);
+			double *pp=p[ijk]+3*co[ijk]++;
+			*(pp++)=x;*(pp++)=y;*(pp++)=z;
+			bool q=compute_cell(c,ijk,co[ijk]-1);
+			co[ijk]--;
+			return q;
+		}		
+	private:
+		voro_compute<container_periodic> vc;
+		friend class voro_compute<container_periodic>;
+};
+
+/** \brief Extension of the container_periodic_base class for computing radical
+ * Voronoi tessellations.
+ *
+ * This class is an extension of container_periodic_base that has routines
+ * specifically for computing the radical Voronoi tessellation that depends
+ * on the particle radii. */
+class container_periodic_poly : public container_periodic_base, public radius_poly {
+	public:
+		container_periodic_poly(double bx_,double bxy_,double by_,double bxz_,double byz_,double bz_,
+				int nx_,int ny_,int nz_,int init_mem_);
+		void clear();
+		void put(int n,double x,double y,double z,double r);
+		void put(int n,double x,double y,double z,double r,int &ai,int &aj,int &ak);
+		void put(particle_order &vo,int n,double x,double y,double z,double r);
+		void import(FILE *fp=stdin);
+		void import(particle_order &vo,FILE *fp=stdin);
+		/** Imports a list of particles from an open file stream into
+		 * the container_poly class. Entries of five numbers (Particle
+		 * ID, x position, y position, z position, radius) are searched
+		 * for. If the file cannot be successfully read, then the
+		 * routine causes a fatal error.
+		 * \param[in] filename the name of the file to open and read
+		 *                     from. */
+		inline void import(const char* filename) {
+			FILE *fp=safe_fopen(filename,"r");
+			import(fp);
+			fclose(fp);
+		}
+		/** Imports a list of particles from an open file stream into
+		 * the container_poly class. Entries of five numbers (Particle
+		 * ID, x position, y position, z position, radius) are searched
+		 * for. In addition, the order in which particles are read is
+		 * saved into an ordering class. If the file cannot be
+		 * successfully read, then the routine causes a fatal error.
+		 * \param[in,out] vo the ordering class to use.
+		 * \param[in] filename the name of the file to open and read
+		 *                     from. */
+		inline void import(particle_order &vo,const char* filename) {
+			FILE *fp=safe_fopen(filename,"r");
+			import(vo,fp);
+			fclose(fp);
+		}
+		void compute_all_cells();
+		double sum_cell_volumes();
+		/** Dumps particle IDs, positions and radii to a file.
+		 * \param[in] vl the loop class to use.
+		 * \param[in] fp a file handle to write to. */
+		template<class c_loop>
+		void draw_particles(c_loop &vl,FILE *fp) {
+			double *pp;
+			if(vl.start()) do {
+				pp=p[vl.ijk]+4*vl.q;
+				fprintf(fp,"%d %g %g %g %g\n",id[vl.ijk][vl.q],*pp,pp[1],pp[2],pp[3]);
+			} while(vl.inc());
+		}
+		/** Dumps all of the particle IDs, positions and radii to a
+		 * file.
+		 * \param[in] fp a file handle to write to. */
+		inline void draw_particles(FILE *fp=stdout) {
+			c_loop_all_periodic vl(*this);
+			draw_particles(vl,fp);
+		}
+		/** Dumps all of the particle IDs, positions and radii to a
+		 * file.
+		 * \param[in] filename the name of the file to write to. */
+		inline void draw_particles(const char *filename) {
+			FILE *fp=safe_fopen(filename,"w");
+			draw_particles(fp);
+			fclose(fp);
+		}
+		/** Dumps particle positions in POV-Ray format.
+		 * \param[in] vl the loop class to use.
+		 * \param[in] fp a file handle to write to. */
+		template<class c_loop>
+		void draw_particles_pov(c_loop &vl,FILE *fp) {
+			double *pp;
+			if(vl.start()) do {
+				pp=p[vl.ijk]+4*vl.q;
+				fprintf(fp,"// id %d\nsphere{<%g,%g,%g>,%g}\n",
+						id[vl.ijk][vl.q],*pp,pp[1],pp[2],pp[3]);
+			} while(vl.inc());
+		}
+		/** Dumps all the particle positions in POV-Ray format.
+		 * \param[in] fp a file handle to write to. */
+		inline void draw_particles_pov(FILE *fp=stdout) {
+			c_loop_all_periodic vl(*this);
+			draw_particles_pov(vl,fp);
+		}
+		/** Dumps all the particle positions in POV-Ray format.
+		 * \param[in] filename the name of the file to write to. */
+		inline void draw_particles_pov(const char *filename) {
+			FILE *fp(safe_fopen(filename,"w"));
+			draw_particles_pov(fp);
+			fclose(fp);
+		}
+		/** Computes Voronoi cells and saves the output in gnuplot
+		 * format.
+		 * \param[in] vl the loop class to use.
+		 * \param[in] fp a file handle to write to. */
+		template<class c_loop>
+		void draw_cells_gnuplot(c_loop &vl,FILE *fp) {
+			voronoicell c;double *pp;
+			if(vl.start()) do if(compute_cell(c,vl)) {
+				pp=p[vl.ijk]+ps*vl.q;
+				c.draw_gnuplot(*pp,pp[1],pp[2],fp);
+			} while(vl.inc());
+		}
+		/** Compute all Voronoi cells and saves the output in gnuplot
+		 * format.
+		 * \param[in] fp a file handle to write to. */
+		inline void draw_cells_gnuplot(FILE *fp=stdout) {
+			c_loop_all_periodic vl(*this);
+			draw_cells_gnuplot(vl,fp);
+		}
+		/** Compute all Voronoi cells and saves the output in gnuplot
+		 * format.
+		 * \param[in] filename the name of the file to write to. */
+		inline void draw_cells_gnuplot(const char *filename) {
+			FILE *fp(safe_fopen(filename,"w"));
+			draw_cells_gnuplot(fp);
+			fclose(fp);
+		}
+		/** Computes Voronoi cells and saves the output in POV-Ray
+		 * format.
+		 * \param[in] vl the loop class to use.
+		 * \param[in] fp a file handle to write to. */
+		template<class c_loop>
+		void draw_cells_pov(c_loop &vl,FILE *fp) {
+			voronoicell c;double *pp;
+			if(vl.start()) do if(compute_cell(c,vl)) {
+				fprintf(fp,"// cell %d\n",id[vl.ijk][vl.q]);
+				pp=p[vl.ijk]+ps*vl.q;
+				c.draw_pov(*pp,pp[1],pp[2],fp);
+			} while(vl.inc());
+		}
+		/** Computes all Voronoi cells and saves the output in POV-Ray
+		 * format.
+		 * \param[in] fp a file handle to write to. */
+		inline void draw_cells_pov(FILE *fp=stdout) {
+			c_loop_all_periodic vl(*this);
+			draw_cells_pov(vl,fp);
+		}
+		/** Computes all Voronoi cells and saves the output in POV-Ray
+		 * format.
+		 * \param[in] filename the name of the file to write to. */
+		inline void draw_cells_pov(const char *filename) {
+			FILE *fp(safe_fopen(filename,"w"));
+			draw_cells_pov(fp);
+			fclose(fp);
+		}
+		/** Computes the Voronoi cells and saves customized information
+		 * about them.
+		 * \param[in] vl the loop class to use.
+		 * \param[in] format the custom output string to use.
+		 * \param[in] fp a file handle to write to. */
+		template<class c_loop>
+		void print_custom(c_loop &vl,const char *format,FILE *fp) {
+			int ijk,q;double *pp;
+			if(contains_neighbor(format)) {
+				voronoicell_neighbor c;
+				if(vl.start()) do if(compute_cell(c,vl)) {
+					ijk=vl.ijk;q=vl.q;pp=p[ijk]+ps*q;
+					c.output_custom(format,id[ijk][q],*pp,pp[1],pp[2],pp[3],fp);
+				} while(vl.inc());
+			} else {
+				voronoicell c;
+				if(vl.start()) do if(compute_cell(c,vl)) {
+					ijk=vl.ijk;q=vl.q;pp=p[ijk]+ps*q;
+					c.output_custom(format,id[ijk][q],*pp,pp[1],pp[2],pp[3],fp);
+				} while(vl.inc());
+			}
+		}
+		/** Computes the Voronoi cell for a particle currently being
+		 * referenced by a loop class.
+		 * \param[out] c a Voronoi cell class in which to store the
+		 * 		 computed cell.
+		 * \param[in] vl the loop class to use.
+		 * \return True if the cell was computed. If the cell cannot be
+		 * computed because it was removed entirely for some reason,
+		 * then the routine returns false. */
+		template<class v_cell,class c_loop>
+		inline bool compute_cell(v_cell &c,c_loop &vl) {
+			return vc.compute_cell(c,vl.ijk,vl.q,vl.i,vl.j,vl.k);
+		}
+		/** Computes the Voronoi cell for given particle.
+		 * \param[out] c a Voronoi cell class in which to store the
+		 * 		 computed cell.
+		 * \param[in] ijk the block that the particle is within.
+		 * \param[in] q the index of the particle within the block.
+		 * \return True if the cell was computed. If the cell cannot be
+		 * computed because it was removed entirely for some reason,
+		 * then the routine returns false. */
+		template<class v_cell>
+		inline bool compute_cell(v_cell &c,int ijk,int q) {
+			int k(ijk/(nx*oy)),ijkt(ijk-(nx*oy)*k),j(ijkt/nx),i(ijkt-j*nx);
+			return vc.compute_cell(c,ijk,q,i,j,k);
+		}
+		/** Computes the Voronoi cell for a ghost particle at a given
+		 * location.
+		 * \param[out] c a Voronoi cell class in which to store the
+		 * 		 computed cell.
+		 * \param[in] (x,y,z) the location of the ghost particle.
+		 * \param[in] r the radius of the ghost particle.
+		 * \return True if the cell was computed. If the cell cannot be
+		 * computed, if it is removed entirely by a wall or boundary
+		 * condition, then the routine returns false. */
+		template<class v_cell>
+		inline bool compute_ghost_cell(v_cell &c,double x,double y,double z,double r) {
+			int ijk;
+			put_locate_block(ijk,x,y,z);
+			double *pp=p[ijk]+4*co[ijk]++,tm=max_radius;
+			*(pp++)=x;*(pp++)=y;*(pp++)=z;*pp=r;
+			if(r>max_radius) max_radius=r;
+			bool q=compute_cell(c,ijk,co[ijk]-1);
+			co[ijk]--;max_radius=tm;
+			return q;
+		}
+		void print_custom(const char *format,FILE *fp=stdout);
+		void print_custom(const char *format,const char *filename);
+		bool find_voronoi_cell(double x,double y,double z,double &rx,double &ry,double &rz,int &pid);
+	private:
+		voro_compute<container_periodic_poly> vc;
+		friend class voro_compute<container_periodic_poly>;
+};
+
+}
+
+#endif
diff -ru --new-file blender-2.76b.old/extern/voro++/src/LICENSE blender-2.76b/extern/voro++/src/LICENSE
--- blender-2.76b.old/extern/voro++/src/LICENSE	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/LICENSE	2016-01-27 18:54:39.992315402 +0300
@@ -0,0 +1,39 @@
+Voro++ Copyright (c) 2008, The Regents of the University of California, through
+Lawrence Berkeley National Laboratory (subject to receipt of any required
+approvals from the U.S. Dept. of Energy). All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are met: 
+
+(1) Redistributions of source code must retain the above copyright notice, this
+list of conditions and the following disclaimer. 
+
+(2) Redistributions in binary form must reproduce the above copyright notice,
+this list of conditions and the following disclaimer in the documentation
+and/or other materials provided with the distribution. 
+
+(3) Neither the name of the University of California, Lawrence Berkeley
+National Laboratory, U.S. Dept. of Energy nor the names of its contributors may
+be used to endorse or promote products derived from this software without
+specific prior written permission. 
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
+ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
+ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
+
+You are under no obligation whatsoever to provide any bug fixes, patches, or
+upgrades to the features, functionality or performance of the source code
+("Enhancements") to anyone; however, if you choose to make your Enhancements
+available either publicly, or directly to Lawrence Berkeley National
+Laboratory, without imposing a separate written license agreement for such
+Enhancements, then you hereby grant the following license: a  non-exclusive,
+royalty-free perpetual license to install, use, modify, prepare derivative
+works, incorporate into other computer software, distribute, and sublicense
+such enhancements or derivative works thereof, in binary and source code form.
diff -ru --new-file blender-2.76b.old/extern/voro++/src/Makefile blender-2.76b/extern/voro++/src/Makefile
--- blender-2.76b.old/extern/voro++/src/Makefile	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/Makefile	2016-01-27 18:55:19.655019694 +0300
@@ -0,0 +1,39 @@
+# Voro++ makefile
+#
+# Author : Chris H. Rycroft (LBL / UC Berkeley)
+# Email  : chr@alum.mit.edu
+# Date   : August 30th 2011
+
+# Load the common configuration file
+include ../config.mk
+
+# List of the common source files
+objs=cell.o common.o container.o unitcell.o v_compute.o c_loops.o \
+     v_base.o wall.o pre_container.o container_prd.o
+src=$(patsubst %.o,%.cc,$(objs))
+
+# Makefile rules
+all: libvoro++.a voro++
+
+depend:
+	$(CXX) -MM $(src) >Makefile.dep
+
+include Makefile.dep
+
+libvoro++.a: $(objs)
+	rm -f libvoro++.a
+	ar rs libvoro++.a $^
+
+voro++: libvoro++.a cmd_line.cc
+	$(CXX) $(CFLAGS) -L. -o voro++ cmd_line.cc -lvoro++
+
+%.o: %.cc
+	$(CXX) $(CFLAGS) -c $<
+
+help: Doxyfile $(SOURCE)
+	doxygen Doxyfile
+
+clean:
+	rm -f $(objs) voro++ libvoro++.a
+
+.PHONY: all help execs depend
diff -ru --new-file blender-2.76b.old/extern/voro++/src/Makefile.dep blender-2.76b/extern/voro++/src/Makefile.dep
--- blender-2.76b.old/extern/voro++/src/Makefile.dep	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/Makefile.dep	2016-01-27 18:55:41.270858563 +0300
@@ -0,0 +1,18 @@
+cell.o: cell.cc config.hh common.hh cell.hh
+common.o: common.cc common.hh config.hh
+container.o: container.cc container.hh config.hh common.hh v_base.hh \
+  worklist.hh cell.hh c_loops.hh v_compute.hh rad_option.hh
+unitcell.o: unitcell.cc unitcell.hh config.hh cell.hh common.hh
+v_compute.o: v_compute.cc worklist.hh v_compute.hh config.hh cell.hh \
+  common.hh rad_option.hh container.hh v_base.hh c_loops.hh \
+  container_prd.hh unitcell.hh
+c_loops.o: c_loops.cc c_loops.hh config.hh
+v_base.o: v_base.cc v_base.hh worklist.hh config.hh v_base_wl.cc
+wall.o: wall.cc wall.hh cell.hh config.hh common.hh container.hh \
+  v_base.hh worklist.hh c_loops.hh v_compute.hh rad_option.hh
+pre_container.o: pre_container.cc config.hh pre_container.hh c_loops.hh \
+  container.hh common.hh v_base.hh worklist.hh cell.hh v_compute.hh \
+  rad_option.hh
+container_prd.o: container_prd.cc container_prd.hh config.hh common.hh \
+  v_base.hh worklist.hh cell.hh c_loops.hh v_compute.hh unitcell.hh \
+  rad_option.hh
diff -ru --new-file blender-2.76b.old/extern/voro++/src/pre_container.cc blender-2.76b/extern/voro++/src/pre_container.cc
--- blender-2.76b.old/extern/voro++/src/pre_container.cc	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/pre_container.cc	2016-01-27 19:06:35.901987524 +0300
@@ -0,0 +1,236 @@
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \file pre_container.cc
+ * \brief Function implementations for the pre_container and related classes.
+ */
+
+#include <cmath>
+
+#include "config.hh"
+#include "pre_container.hh"
+
+namespace voro {
+
+/** The class constructor sets up the geometry of container, initializing the
+ * minimum and maximum coordinates in each direction. It allocates an initial
+ * chunk into which to store particle information.
+ * \param[in] (ax_,bx_) the minimum and maximum x coordinates.
+ * \param[in] (ay_,by_) the minimum and maximum y coordinates.
+ * \param[in] (az_,bz_) the minimum and maximum z coordinates.
+ * \param[in] (xperiodic_,yperiodic_,zperiodic_ ) flags setting whether the
+ *                                                container is periodic in each
+ *                                                coordinate direction.
+ * \param[in] ps_ the number of floating point entries to store for each
+ *                particle. */
+pre_container_base::pre_container_base(double ax_,double bx_,double ay_,double by_,double az_,double bz_,
+	bool xperiodic_,bool yperiodic_,bool zperiodic_,int ps_) :
+	ax(ax_), bx(bx_), ay(ay_), by(by_), az(az_), bz(bz_),
+	xperiodic(xperiodic_), yperiodic(yperiodic_), zperiodic(zperiodic_), ps(ps_),
+	index_sz(init_chunk_size), pre_id(new int*[index_sz]), end_id(pre_id),
+	pre_p(new double*[index_sz]), end_p(pre_p) {
+		ch_id=*end_id=new int[pre_container_chunk_size];
+		l_id=end_id+index_sz;e_id=ch_id+pre_container_chunk_size;
+		ch_p=*end_p=new double[ps*pre_container_chunk_size];
+}
+
+/** The destructor frees the dynamically allocated memory. */
+pre_container_base::~pre_container_base() {
+	delete [] *end_p;
+	delete [] *end_id;
+	while (end_id!=pre_id) {
+		end_p--;
+		delete [] *end_p;
+		end_id--;
+		delete [] *end_id;
+	}
+	delete [] pre_p;
+	delete [] pre_id;
+}
+
+/** Makes a guess at the optimal grid of blocks to use, computing in
+ * a way that
+ * \param[out] (nx,ny,nz) the number of blocks to use. */
+void pre_container_base::guess_optimal(int &nx,int &ny,int &nz) {
+	double dx=bx-ax,dy=by-ay,dz=bz-az;
+	double ilscale=pow(total_particles()/(optimal_particles*dx*dy*dz),1/3.0);
+	nx=int(dx*ilscale+1);
+	ny=int(dy*ilscale+1);
+	nz=int(dz*ilscale+1);
+}
+
+/** Stores a particle ID and position, allocating a new memory chunk if
+ * necessary. For coordinate directions in which the container is not periodic,
+ * the routine checks to make sure that the particle is within the container
+ * bounds. If the particle is out of bounds, it is not stored.
+ * \param[in] n the numerical ID of the inserted particle.
+ * \param[in] (x,y,z) the position vector of the inserted particle. */
+void pre_container::put(int n,double x,double y,double z) {
+	if((xperiodic||(x>=ax&&x<=bx))&&(yperiodic||(y>=ay&&y<=by))&&(zperiodic||(z>=az&&z<=bz))) {
+		if(ch_id==e_id) new_chunk();
+		*(ch_id++)=n;
+		*(ch_p++)=x;*(ch_p++)=y;*(ch_p++)=z;
+	}
+#if VOROPP_REPORT_OUT_OF_BOUNDS ==1
+	else fprintf(stderr,"Out of bounds: (x,y,z)=(%g,%g,%g)\n",x,y,z);
+#endif
+}
+
+/** Stores a particle ID and position, allocating a new memory chunk if necessary.
+ * \param[in] n the numerical ID of the inserted particle.
+ * \param[in] (x,y,z) the position vector of the inserted particle.
+ * \param[in] r the radius of the particle. */
+void pre_container_poly::put(int n,double x,double y,double z,double r) {
+	if((xperiodic||(x>=ax&&x<=bx))&&(yperiodic||(y>=ay&&y<=by))&&(zperiodic||(z>=az&&z<=bz))) {
+		if(ch_id==e_id) new_chunk();
+		*(ch_id++)=n;
+		*(ch_p++)=x;*(ch_p++)=y;*(ch_p++)=z;*(ch_p++)=r;
+	}
+#if VOROPP_REPORT_OUT_OF_BOUNDS ==1
+	else fprintf(stderr,"Out of bounds: (x,y,z)=(%g,%g,%g)\n",x,y,z);
+#endif
+}
+
+/** Transfers the particles stored within the class to a container class.
+ * \param[in] con the container class to transfer to. */
+void pre_container::setup(container &con) {
+	int **c_id=pre_id,*idp,*ide,n;
+	double **c_p=pre_p,*pp,x,y,z;
+	while(c_id<end_id) {
+		idp=*(c_id++);ide=idp+pre_container_chunk_size;
+		pp=*(c_p++);
+		while(idp<ide) {
+			n=*(idp++);x=*(pp++);y=*(pp++);z=*(pp++);
+			con.put(n,x,y,z);
+		}
+	}
+	idp=*c_id;
+	pp=*c_p;
+	while(idp<ch_id) {
+		n=*(idp++);x=*(pp++);y=*(pp++);z=*(pp++);
+		con.put(n,x,y,z);
+	}
+}
+
+/** Transfers the particles stored within the class to a container_poly class.
+ * \param[in] con the container_poly class to transfer to. */
+void pre_container_poly::setup(container_poly &con) {
+	int **c_id=pre_id,*idp,*ide,n;
+	double **c_p=pre_p,*pp,x,y,z,r;
+	while(c_id<end_id) {
+		idp=*(c_id++);ide=idp+pre_container_chunk_size;
+		pp=*(c_p++);
+		while(idp<ide) {
+			n=*(idp++);x=*(pp++);y=*(pp++);z=*(pp++);r=*(pp++);
+			con.put(n,x,y,z,r);
+		}
+	}
+	idp=*c_id;
+	pp=*c_p;
+	while(idp<ch_id) {
+		n=*(idp++);x=*(pp++);y=*(pp++);z=*(pp++);r=*(pp++);
+		con.put(n,x,y,z,r);
+	}
+}
+
+/** Transfers the particles stored within the class to a container class, also
+ * recording the order in which particles were stored.
+ * \param[in] vo the ordering class to use.
+ * \param[in] con the container class to transfer to. */
+void pre_container::setup(particle_order &vo,container &con) {
+	int **c_id=pre_id,*idp,*ide,n;
+	double **c_p=pre_p,*pp,x,y,z;
+	while(c_id<end_id) {
+		idp=*(c_id++);ide=idp+pre_container_chunk_size;
+		pp=*(c_p++);
+		while(idp<ide) {
+			n=*(idp++);x=*(pp++);y=*(pp++);z=*(pp++);
+			con.put(vo,n,x,y,z);
+		}
+	}
+	idp=*c_id;
+	pp=*c_p;
+	while(idp<ch_id) {
+		n=*(idp++);x=*(pp++);y=*(pp++);z=*(pp++);
+		con.put(vo,n,x,y,z);
+	}
+}
+
+/** Transfers the particles stored within the class to a container_poly class,
+ * also recording the order in which particles were stored.
+ * \param[in] vo the ordering class to use.
+ * \param[in] con the container_poly class to transfer to. */
+void pre_container_poly::setup(particle_order &vo,container_poly &con) {
+	int **c_id=pre_id,*idp,*ide,n;
+	double **c_p=pre_p,*pp,x,y,z,r;
+	while(c_id<end_id) {
+		idp=*(c_id++);ide=idp+pre_container_chunk_size;
+		pp=*(c_p++);
+		while(idp<ide) {
+			n=*(idp++);x=*(pp++);y=*(pp++);z=*(pp++);r=*(pp++);
+			con.put(vo,n,x,y,z,r);
+		}
+	}
+	idp=*c_id;
+	pp=*c_p;
+	while(idp<ch_id) {
+		n=*(idp++);x=*(pp++);y=*(pp++);z=*(pp++);r=*(pp++);
+		con.put(vo,n,x,y,z,r);
+	}
+}
+
+/** Import a list of particles from an open file stream into the container.
+ * Entries of four numbers (Particle ID, x position, y position, z position)
+ * are searched for. If the file cannot be successfully read, then the routine
+ * causes a fatal error.
+ * \param[in] fp the file handle to read from. */
+void pre_container::import(FILE *fp) {
+	int i,j;
+	double x,y,z;
+	while((j=fscanf(fp,"%d %lg %lg %lg",&i,&x,&y,&z))==4) put(i,x,y,z);
+	if(j!=EOF) voro_fatal_error("File import error",VOROPP_FILE_ERROR);
+}
+
+/** Import a list of particles from an open file stream, also storing the order
+ * of that the particles are read. Entries of four numbers (Particle ID, x
+ * position, y position, z position) are searched for. If the file cannot be
+ * successfully read, then the routine causes a fatal error.
+ * \param[in] fp the file handle to read from. */
+void pre_container_poly::import(FILE *fp) {
+	int i,j;
+	double x,y,z,r;
+	while((j=fscanf(fp,"%d %lg %lg %lg %lg",&i,&x,&y,&z,&r))==5) put(i,x,y,z,r);
+	if(j!=EOF) voro_fatal_error("File import error",VOROPP_FILE_ERROR);
+}
+
+/** Allocates a new chunk of memory for storing particles. */
+void pre_container_base::new_chunk() {
+	end_id++;end_p++;
+	if(end_id==l_id) extend_chunk_index();
+	ch_id=*end_id=new int[pre_container_chunk_size];
+	e_id=ch_id+pre_container_chunk_size;
+	ch_p=*end_p=new double[ps*pre_container_chunk_size];
+}
+
+/** Extends the index of chunks. */
+void pre_container_base::extend_chunk_index() {
+	index_sz<<=1;
+	if(index_sz>max_chunk_size)
+		voro_fatal_error("Absolute memory limit on chunk index reached",VOROPP_MEMORY_ERROR);
+#if VOROPP_VERBOSE >=2
+	fprintf(stderr,"Pre-container chunk index scaled up to %d\n",index_sz);
+#endif
+	int **n_id=new int*[index_sz],**p_id=n_id,**c_id=pre_id;
+	double **n_p=new double*[index_sz],**p_p=n_p,**c_p=pre_p;
+	while(c_id<end_id) {
+		*(p_id++)=*(c_id++);
+		*(p_p++)=*(c_p++);
+	}
+	delete [] pre_id;pre_id=n_id;end_id=p_id;l_id=pre_id+index_sz;
+	delete [] pre_p;pre_p=n_p;end_p=p_p;
+}
+
+}
diff -ru --new-file blender-2.76b.old/extern/voro++/src/pre_container.hh blender-2.76b/extern/voro++/src/pre_container.hh
--- blender-2.76b.old/extern/voro++/src/pre_container.hh	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/pre_container.hh	2016-01-27 19:06:07.334199758 +0300
@@ -0,0 +1,162 @@
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \file pre_container.hh
+ * \brief Header file for the pre_container and related classes. */
+
+#ifndef VOROPP_PRE_CONTAINER_HH
+#define VOROPP_PRE_CONTAINER_HH
+
+#include <cstdio>
+
+#include "c_loops.hh"
+#include "container.hh"
+
+namespace voro {
+
+/** \brief A class for storing an arbitrary number of particles, prior to setting
+ * up a container geometry.
+ *
+ * The pre_container_base class can dynamically import and store an arbitrary
+ * number of particles. Once the particles have been read in, an appropriate
+ * container class can be set up with the optimal grid size, and the particles
+ * can be transferred.
+ *
+ * The pre_container_base class is not intended for direct use, but forms the
+ * base of the pre_container and pre_container_poly classes, that add routines
+ * depending on whether particle radii need to be tracked or not. */
+class pre_container_base {
+	public:
+		/** The minimum x coordinate of the container. */
+		const double ax;
+		/** The maximum x coordinate of the container. */
+		const double bx;
+		/** The minimum y coordinate of the container. */
+		const double ay;
+		/** The maximum y coordinate of the container. */
+		const double by;
+		/** The minimum z coordinate of the container. */
+		const double az;
+		/** The maximum z coordinate of the container. */
+		const double bz;
+		/** A boolean value that determines if the x coordinate in
+		 * periodic or not. */
+		const bool xperiodic;
+		/** A boolean value that determines if the y coordinate in
+		 * periodic or not. */
+		const bool yperiodic;
+		/** A boolean value that determines if the z coordinate in
+		 * periodic or not. */
+		const bool zperiodic;
+		void guess_optimal(int &nx,int &ny,int &nz);
+		pre_container_base(double ax_,double bx_,double ay_,double by_,double az_,double bz_,bool xperiodic_,bool yperiodic_,bool zperiodic_,int ps_);
+		~pre_container_base();
+		/** Calculates and returns the total number of particles stored
+		 * within the class.
+		 * \return The number of particles. */
+		inline int total_particles() {
+			return (end_id-pre_id)*pre_container_chunk_size+(ch_id-*end_id);
+		}
+	protected:
+		/** The number of doubles associated with a single particle
+		 * (three for the standard container, four when radius
+		 * information is stored). */
+		const int ps;
+		void new_chunk();
+		void extend_chunk_index();
+		/** The size of the chunk index. */
+		int index_sz;
+		/** A pointer to the chunk index to store the integer particle
+		 * IDs. */
+		int **pre_id;
+		/** A pointer to the last allocated integer ID chunk. */
+		int **end_id;
+		/** A pointer to the end of the integer ID chunk index, used to
+		 * determine when the chunk index is full. */
+		int **l_id;
+		/** A pointer to the next available slot on the current
+		 * particle ID chunk. */
+		int *ch_id;
+		/** A pointer to the end of the current integer chunk. */
+		int *e_id;
+		/** A pointer to the chunk index to store the floating point
+		 * information associated with particles. */
+		double **pre_p;
+		/** A pointer to the last allocated chunk of floating point
+		 * information. */
+		double **end_p;
+		/** A pointer to the next available slot on the current
+		 * floating point chunk. */
+		double *ch_p;
+};
+
+/** \brief A class for storing an arbitrary number of particles without radius
+ * information, prior to setting up a container geometry.
+ *
+ * The pre_container class is an extension of the pre_container_base class for
+ * cases when no particle radius information is available. */
+class pre_container : public pre_container_base {
+	public:
+		/** The class constructor sets up the geometry of container,
+		 * initializing the minimum and maximum coordinates in each
+		 * direction.
+		 * \param[in] (ax_,bx_) the minimum and maximum x coordinates.
+		 * \param[in] (ay_,by_) the minimum and maximum y coordinates.
+		 * \param[in] (az_,bz_) the minimum and maximum z coordinates.
+		 * \param[in] (xperiodic_,yperiodic_,zperiodic_ ) flags setting whether the
+		 *                                                container is periodic in
+		 *                                                each coordinate direction. */
+		pre_container(double ax_,double bx_,double ay_,double by_,double az_,double bz_,
+				bool xperiodic_,bool yperiodic_,bool zperiodic_)
+			: pre_container_base(ax_,bx_,ay_,by_,az_,bz_,xperiodic_,yperiodic_,zperiodic_,3) {};
+		void put(int n,double x,double y,double z);
+		void import(FILE *fp=stdin);
+		/** Imports particles from a file.
+		 * \param[in] filename the name of the file to read from. */
+		inline void import(const char* filename) {
+			FILE *fp=safe_fopen(filename,"r");
+			import(fp);
+			fclose(fp);
+		}
+		void setup(container &con);
+		void setup(particle_order &vo,container &con);
+};
+
+/** \brief A class for storing an arbitrary number of particles with radius
+ * information, prior to setting up a container geometry.
+ *
+ * The pre_container_poly class is an extension of the pre_container_base class
+ * for cases when particle radius information is available. */
+class pre_container_poly : public pre_container_base {
+	public:
+		/** The class constructor sets up the geometry of container,
+		 * initializing the minimum and maximum coordinates in each
+		 * direction.
+		 * \param[in] (ax_,bx_) the minimum and maximum x coordinates.
+		 * \param[in] (ay_,by_) the minimum and maximum y coordinates.
+		 * \param[in] (az_,bz_) the minimum and maximum z coordinates.
+		 * \param[in] (xperiodic_,yperiodic_,zperiodic_ ) flags setting whether the
+		 *                                                container is periodic in
+		 *                                                each coordinate direction. */
+		pre_container_poly(double ax_,double bx_,double ay_,double by_,double az_,double bz_,
+				bool xperiodic_,bool yperiodic_,bool zperiodic_)
+			: pre_container_base(ax_,bx_,ay_,by_,az_,bz_,xperiodic_,yperiodic_,zperiodic_,4) {};
+		void put(int n,double x,double y,double z,double r);
+		void import(FILE *fp=stdin);
+		/** Imports particles from a file.
+		 * \param[in] filename the name of the file to read from. */
+		inline void import(const char* filename) {
+			FILE *fp=safe_fopen(filename,"r");
+			import(fp);
+			fclose(fp);
+		}
+		void setup(container_poly &con);
+		void setup(particle_order &vo,container_poly &con);
+};
+
+}
+
+#endif
diff -ru --new-file blender-2.76b.old/extern/voro++/src/rad_option.hh blender-2.76b/extern/voro++/src/rad_option.hh
--- blender-2.76b.old/extern/voro++/src/rad_option.hh	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/rad_option.hh	2016-01-27 19:07:00.621803901 +0300
@@ -0,0 +1,158 @@
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \file rad_option.hh
+ * \brief Header file for the classes encapsulating functionality for the
+ * regular and radical Voronoi tessellations. */
+
+#ifndef VOROPP_RAD_OPTION_HH
+#define VOROPP_RAD_OPTION_HH
+
+#include <cmath>
+
+namespace voro {
+
+/** \brief Class containing all of the routines that are specific to computing 
+ * the regular Voronoi tessellation.
+ *
+ * The container and container_periodic classes are derived from this class,
+ * and during the Voronoi cell computation, these routines are used to create
+ * the regular Voronoi tessellation. */
+class radius_mono {
+	protected:
+		/** This is called prior to computing a Voronoi cell for a
+		 * given particle to initialize any required constants.
+		 * \param[in] ijk the block that the particle is within.
+		 * \param[in] s the index of the particle within the block. */
+		inline void r_init(int ijk,int s) {}
+		/** Sets a required constant to be used when carrying out a
+		 * plane bounds check. */
+		inline void r_prime(double rv) {}
+		/** Carries out a radius bounds check.
+		 * \param[in] crs the radius squared to be tested.
+		 * \param[in] mrs the current maximum distance to a Voronoi
+		 *                vertex multiplied by two.
+		 * \return True if particles at this radius could not possibly
+		 * cut the cell, false otherwise. */
+		inline bool r_ctest(double crs,double mrs) {return crs>mrs;}
+		/** Scales a plane displacement during a plane bounds check.
+		 * \param[in] lrs the plane displacement.
+		 * \return The scaled value. */
+		inline double r_cutoff(double lrs) {return lrs;}
+		/** Adds the maximum radius squared to a given value.
+		 * \param[in] rs the value to consider.
+		 * \return The value with the radius squared added. */
+		inline double r_max_add(double rs) {return rs;}
+		/** Subtracts the radius squared of a particle from a given 
+		 * value.
+		 * \param[in] rs the value to consider.
+		 * \param[in] ijk the block that the particle is within.
+		 * \param[in] q the index of the particle within the block. 
+		 * \return The value with the radius squared subtracted. */
+		inline double r_current_sub(double rs,int ijk,int q) {return rs;}
+		/** Scales a plane displacement prior to use in the plane cutting
+		 * algorithm.
+		 * \param[in] rs the initial plane displacement.
+		 * \param[in] ijk the block that the particle is within.
+		 * \param[in] q the index of the particle within the block.
+		 * \return The scaled plane displacement. */ 
+		inline double r_scale(double rs,int ijk,int q) {return rs;}
+		/** Scales a plane displacement prior to use in the plane
+		 * cutting algorithm, and also checks if it could possibly cut
+		 * the cell.
+		 * \param[in,out] rs the plane displacement to be scaled.
+		 * \param[in] mrs the current maximum distance to a Voronoi
+		 *                vertex multiplied by two.
+		 * \param[in] ijk the block that the particle is within.
+		 * \param[in] q the index of the particle within the block.
+		 * \return True if the cell could possibly cut the cell, false
+		 * otherwise. */		
+		inline bool r_scale_check(double &rs,double mrs,int ijk,int q) {return rs<mrs;}
+};
+
+/**  \brief Class containing all of the routines that are specific to computing 
+ * the radical Voronoi tessellation.
+ *
+ * The container_poly and container_periodic_poly classes are derived from this
+ * class, and during the Voronoi cell computation, these routines are used to
+ * create the radical Voronoi tessellation. */
+class radius_poly {
+	public:
+		/** A two-dimensional array holding particle positions and radii. */			
+		double **ppr;
+		/** The current maximum radius of any particle, used to
+		 * determine when to cut off the radical Voronoi computation.
+		 * */
+		double max_radius;
+		/** The class constructor sets the maximum particle radius to
+		 * be zero. */
+		radius_poly() : max_radius(0) {}
+	protected:
+		/** This is called prior to computing a Voronoi cell for a
+		 * given particle to initialize any required constants.
+		 * \param[in] ijk the block that the particle is within.
+		 * \param[in] s the index of the particle within the block. */
+		inline void r_init(int ijk,int s) {
+			r_rad=ppr[ijk][4*s+3]*ppr[ijk][4*s+3];
+			r_mul=r_rad-max_radius*max_radius;
+		}
+		/** Sets a required constant to be used when carrying out a
+		 * plane bounds check. */
+		inline void r_prime(double rv) {r_val=1+r_mul/rv;}
+		/** Carries out a radius bounds check.
+		 * \param[in] crs the radius squared to be tested.
+		 * \param[in] mrs the current maximum distance to a Voronoi
+		 *                vertex multiplied by two.
+		 * \return True if particles at this radius could not possibly
+		 * cut the cell, false otherwise. */		
+		inline bool r_ctest(double crs,double mrs) {return crs+r_mul>sqrt(mrs*crs);}
+		/** Scales a plane displacement during a plane bounds check.
+		 * \param[in] lrs the plane displacement.
+		 * \return The scaled value. */		
+		inline double r_cutoff(double lrs) {return lrs*r_val;}
+		/** Adds the maximum radius squared to a given value.
+		 * \param[in] rs the value to consider.
+		 * \return The value with the radius squared added. */		
+		inline double r_max_add(double rs) {return rs+max_radius*max_radius;}
+		/** Subtracts the radius squared of a particle from a given 
+		 * value.
+		 * \param[in] rs the value to consider.
+		 * \param[in] ijk the block that the particle is within.
+		 * \param[in] q the index of the particle within the block. 
+		 * \return The value with the radius squared subtracted. */
+		inline double r_current_sub(double rs,int ijk,int q) {
+			return rs-ppr[ijk][4*q+3]*ppr[ijk][4*q+3];
+		}
+		/** Scales a plane displacement prior to use in the plane cutting
+		 * algorithm.
+		 * \param[in] rs the initial plane displacement.
+		 * \param[in] ijk the block that the particle is within.
+		 * \param[in] q the index of the particle within the block.
+		 * \return The scaled plane displacement. */ 
+		inline double r_scale(double rs,int ijk,int q) {
+			return rs+r_rad-ppr[ijk][4*q+3]*ppr[ijk][4*q+3];
+		}
+		/** Scales a plane displacement prior to use in the plane
+		 * cutting algorithm, and also checks if it could possibly cut
+		 * the cell.
+		 * \param[in,out] rs the plane displacement to be scaled.
+		 * \param[in] mrs the current maximum distance to a Voronoi
+		 *                vertex multiplied by two.
+		 * \param[in] ijk the block that the particle is within.
+		 * \param[in] q the index of the particle within the block.
+		 * \return True if the cell could possibly cut the cell, false
+		 * otherwise. */
+		inline bool r_scale_check(double &rs,double mrs,int ijk,int q) {
+			double trs=rs;
+			rs+=r_rad-ppr[ijk][4*q+3]*ppr[ijk][4*q+3];
+			return rs<sqrt(mrs*trs);
+		}
+	private:
+		double r_rad,r_mul,r_val;
+};
+
+}
+#endif
diff -ru --new-file blender-2.76b.old/extern/voro++/src/README blender-2.76b/extern/voro++/src/README
--- blender-2.76b.old/extern/voro++/src/README	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/README	2016-01-27 18:55:59.527722487 +0300
@@ -0,0 +1,21 @@
+Voro++ library source files
+===========================
+This directory contains the source code for the library. For full details of
+each file, see the files section of the online reference manual at
+http://math.lbl.gov/voro++/doc/refman/
+
+Several other files are present:
+
+Makefile - the GNU Makefile controlling the compilation.
+
+Makefile.dep - a file containing all the dependencies of the source files,
+automatically generated by the GNU compiler.
+
+cmd_line.cc - source file for creating the command-line utility that makes use
+of the library.
+
+Doxyfile - configuration file for Doxygen, used to automatically generate
+documentation based on the source code comments.
+
+worklist_gen.pl - perl script for automatically generating the worklist.hh and
+v_base_wl.cc files.
diff -ru --new-file blender-2.76b.old/extern/voro++/src/unitcell.cc blender-2.76b/extern/voro++/src/unitcell.cc
--- blender-2.76b.old/extern/voro++/src/unitcell.cc	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/unitcell.cc	2016-01-27 19:07:45.485468932 +0300
@@ -0,0 +1,231 @@
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \file unitcell.cc
+ * \brief Function implementations for the unitcell class. */
+
+#include <cmath>
+#include <queue>
+
+#include "unitcell.hh"
+#include "cell.hh"
+
+namespace voro {
+
+/** Initializes the unit cell class for a particular non-orthogonal periodic
+ * geometry, corresponding to a parallelepiped with sides given by three
+ * vectors. The class constructs the unit Voronoi cell corresponding to this
+ * geometry.
+ * \param[in] (bx_) The x coordinate of the first unit vector.
+ * \param[in] (bxy_,by_) The x and y coordinates of the second unit vector.
+ * \param[in] (bxz_,byz_,bz_) The x, y, and z coordinates of the third unit
+ *                            vector. */
+unitcell::unitcell(double bx_,double bxy_,double by_,double bxz_,double byz_,double bz_)
+	: bx(bx_), bxy(bxy_), by(by_), bxz(bxz_), byz(byz_), bz(bz_) {
+	int i,j,l=1;
+
+	// Initialize the Voronoi cell to be a very large rectangular box
+	const double ucx=max_unit_voro_shells*bx,ucy=max_unit_voro_shells*by,ucz=max_unit_voro_shells*bz;
+	unit_voro.init(-ucx,ucx,-ucy,ucy,-ucz,ucz);
+
+	// Repeatedly cut the cell by shells of periodic image particles
+	while(l<2*max_unit_voro_shells) {
+
+		// Check to see if any of the planes from the current shell
+		// will cut the cell
+		if(unit_voro_intersect(l)) {
+
+			// If they do, apply the plane cuts from the current
+			// shell
+			unit_voro_apply(l,0,0);
+			for(i=1;i<l;i++) {
+				unit_voro_apply(l,i,0);
+				unit_voro_apply(-l,i,0);
+			}
+			for(i=-l;i<=l;i++) unit_voro_apply(i,l,0);
+			for(i=1;i<l;i++) for(j=-l+1;j<=l;j++) {
+				unit_voro_apply(l,j,i);
+				unit_voro_apply(-j,l,i);
+				unit_voro_apply(-l,-j,i);
+				unit_voro_apply(j,-l,i);
+			}
+			for(i=-l;i<=l;i++) for(j=-l;j<=l;j++) unit_voro_apply(i,j,l);
+		} else {
+
+			// Calculate a bound on the maximum y and z coordinates
+			// that could possibly cut the cell. This is based upon
+			// a geometric result that particles with z>l can't cut
+			// a cell lying within the paraboloid
+			// z<=(l*l-x*x-y*y)/(2*l). It is always a tighter bound
+			// than the one based on computing the maximum radius
+			// of a Voronoi cell vertex.
+			max_uv_y=max_uv_z=0;
+			double y,z,q,*pts=unit_voro.pts,*pp=pts;
+			while(pp<pts+3*unit_voro.p) {
+				q=*(pp++);y=*(pp++);z=*(pp++);q=sqrt(q*q+y*y+z*z);
+				if(y+q>max_uv_y) max_uv_y=y+q;
+				if(z+q>max_uv_z) max_uv_z=z+q;
+			}
+			max_uv_z*=0.5;
+			max_uv_y*=0.5;
+			return;
+		}
+		l++;
+	}
+
+	// If the routine makes it here, then the unit cell still hasn't been
+	// completely bounded by the plane cuts. Give the memory error code,
+	// because this is mainly a case of hitting a safe limit, than any
+	// inherent problem.
+	voro_fatal_error("Periodic cell computation failed",VOROPP_MEMORY_ERROR);
+}
+
+/** Applies a pair of opposing plane cuts from a periodic image point
+ * to the unit Voronoi cell.
+ * \param[in] (i,j,k) the index of the periodic image to consider. */
+inline void unitcell::unit_voro_apply(int i,int j,int k) {
+	double x=i*bx+j*bxy+k*bxz,y=j*by+k*byz,z=k*bz;
+	unit_voro.plane(x,y,z);
+	unit_voro.plane(-x,-y,-z);
+}
+
+/** Calculates whether the unit Voronoi cell intersects a given periodic image
+ * of the domain.
+ * \param[in] (dx,dy,dz) the displacement of the periodic image.
+ * \param[out] vol the proportion of the unit cell volume within this image,
+ *                 only computed in the case that the two intersect.
+ * \return True if they intersect, false otherwise. */
+bool unitcell::intersects_image(double dx,double dy,double dz,double &vol) {
+	const double bxinv=1/bx,byinv=1/by,bzinv=1/bz,ivol=bxinv*byinv*bzinv;
+	voronoicell c;
+	c=unit_voro;
+	dx*=2;dy*=2;dz*=2;
+	if(!c.plane(0,0,bzinv,dz+1)) return false;
+	if(!c.plane(0,0,-bzinv,-dz+1)) return false;
+	if(!c.plane(0,byinv,-byz*byinv*bzinv,dy+1)) return false;
+	if(!c.plane(0,-byinv,byz*byinv*bzinv,-dy+1)) return false;
+	if(!c.plane(bxinv,-bxy*bxinv*byinv,(bxy*byz-by*bxz)*ivol,dx+1)) return false;
+	if(!c.plane(-bxinv,bxy*bxinv*byinv,(-bxy*byz+by*bxz)*ivol,-dx+1)) return false;
+	vol=c.volume()*ivol;
+	return true;
+}
+
+/** Computes a list of periodic domain images that intersect the unit Voronoi cell.
+ * \param[out] vi a vector containing triplets (i,j,k) corresponding to domain
+ *                images that intersect the unit Voronoi cell, when it is
+ *                centered in the middle of the primary domain.
+ * \param[out] vd a vector containing the fraction of the Voronoi cell volume
+ *                within each corresponding image listed in vi. */
+void unitcell::images(std::vector<int> &vi,std::vector<double> &vd) {
+	const int ms2=max_unit_voro_shells*2+1,mss=ms2*ms2*ms2;
+	bool *a=new bool[mss],*ac=a+max_unit_voro_shells*(1+ms2*(1+ms2)),*ap=a;
+	int i,j,k;
+	double vol;
+
+	// Initialize mask
+	while(ap<ac) *(ap++)=true;
+	*(ap++)=false;
+	while(ap<a+mss) *(ap++)=true;
+
+	// Set up the queue and add (0,0,0) image to it
+	std::queue<int> q;
+	q.push(0);q.push(0);q.push(0);
+
+	while(!q.empty()) {
+
+		// Read the next entry on the queue
+		i=q.front();q.pop();
+		j=q.front();q.pop();
+		k=q.front();q.pop();
+
+		// Check intersection of this image
+		if(intersects_image(i,j,k,vol)) {
+
+			// Add this entry to the output vectors
+			vi.push_back(i);
+			vi.push_back(j);
+			vi.push_back(k);
+			vd.push_back(vol);
+
+			// Add neighbors to the queue if they have not been
+			// tested
+			ap=ac+i+ms2*(j+ms2*k);
+			if(k>-max_unit_voro_shells&&*(ap-ms2*ms2)) {q.push(i);q.push(j);q.push(k-1);*(ap-ms2*ms2)=false;}
+			if(j>-max_unit_voro_shells&&*(ap-ms2)) {q.push(i);q.push(j-1);q.push(k);*(ap-ms2)=false;}
+			if(i>-max_unit_voro_shells&&*(ap-1)) {q.push(i-1);q.push(j);q.push(k);*(ap-1)=false;}
+			if(i<max_unit_voro_shells&&*(ap+1)) {q.push(i+1);q.push(j);q.push(k);*(ap+1)=false;}
+			if(j<max_unit_voro_shells&&*(ap+ms2)) {q.push(i);q.push(j+1);q.push(k);*(ap+ms2)=false;}
+			if(k<max_unit_voro_shells&&*(ap+ms2*ms2)) {q.push(i);q.push(j);q.push(k+1);*(ap+ms2*ms2)=false;}
+		}
+	}
+
+	// Remove mask memory
+	delete [] a;
+}
+
+/** Tests to see if a shell of periodic images could possibly cut the periodic
+ * unit cell.
+ * \param[in] l the index of the shell to consider.
+ * \return True if a point in the shell cuts the cell, false otherwise. */
+bool unitcell::unit_voro_intersect(int l) {
+	int i,j;
+	if(unit_voro_test(l,0,0)) return true;
+	for(i=1;i<l;i++) {
+		if(unit_voro_test(l,i,0)) return true;
+		if(unit_voro_test(-l,i,0)) return true;
+	}
+	for(i=-l;i<=l;i++) if(unit_voro_test(i,l,0)) return true;
+	for(i=1;i<l;i++) for(j=-l+1;j<=l;j++) {
+		if(unit_voro_test(l,j,i)) return true;
+		if(unit_voro_test(-j,l,i)) return true;
+		if(unit_voro_test(-l,-j,i)) return true;
+		if(unit_voro_test(j,-l,i)) return true;
+	}
+	for(i=-l;i<=l;i++) for(j=-l;j<=l;j++) if(unit_voro_test(i,j,l)) return true;
+	return false;
+}
+
+/** Tests to see if a plane cut from a particular periodic image will cut th
+ * unit Voronoi cell.
+ * \param[in] (i,j,k) the index of the periodic image to consider.
+ * \return True if the image cuts the cell, false otherwise. */
+inline bool unitcell::unit_voro_test(int i,int j,int k) {
+	double x=i*bx+j*bxy+k*bxz,y=j*by+k*byz,z=k*bz;
+	double rsq=x*x+y*y+z*z;
+	return unit_voro.plane_intersects(x,y,z,rsq);
+}
+
+/** Draws the periodic domain in gnuplot format.
+ * \param[in] fp the file handle to write to. */
+void unitcell::draw_domain_gnuplot(FILE *fp) {
+	fprintf(fp,"0 0 0\n%g 0 0\n%g %g 0\n%g %g 0\n",bx,bx+bxy,by,bxy,by);
+	fprintf(fp,"%g %g %g\n%g %g %g\n%g %g %g\n%g %g %g\n",bxy+bxz,by+byz,bz,bx+bxy+bxz,by+byz,bz,bx+bxz,byz,bz,bxz,byz,bz);
+	fprintf(fp,"0 0 0\n%g %g 0\n\n%g %g %g\n%g %g %g\n\n",bxy,by,bxz,byz,bz,bxy+bxz,by+byz,bz);
+	fprintf(fp,"%g 0 0\n%g %g %g\n\n%g %g 0\n%g %g %g\n\n",bx,bx+bxz,byz,bz,bx+bxy,by,bx+bxy+bxz,by+byz,bz);
+}
+
+/** Draws the periodic domain in POV-Ray format.
+ * \param[in] fp the file handle to write to. */
+void unitcell::draw_domain_pov(FILE *fp) {
+	fprintf(fp,"cylinder{0,0,0>,<%g,0,0>,rr}\n"
+		   "cylinder{<%g,%g,0>,<%g,%g,0>,rr}\n",bx,bxy,by,bx+bxy,by);
+	fprintf(fp,"cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\n"
+		   "cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\n",bxz,byz,bz,bx+bxz,byz,bz,bxy+bxz,by+byz,bz,bx+bxy+bxz,by+byz,bz);
+	fprintf(fp,"cylinder{<0,0,0>,<%g,%g,0>,rr}\n"
+		   "cylinder{<%g,0,0>,<%g,%g,0>,rr}\n",bxy,by,bx,bx+bxy,by);
+	fprintf(fp,"cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\n"
+		   "cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\n",bxz,byz,bz,bxy+bxz,by+byz,bz,bx+bxz,byz,bz,bx+bxy+bxz,by+byz,bz);
+	fprintf(fp,"cylinder{<0,0,0>,<%g,%g,%g>,rr}\n"
+		   "cylinder{<%g,0,0>,<%g,%g,%g>,rr}\n",bxz,byz,bz,bx,bx+bxz,byz,bz);
+	fprintf(fp,"cylinder{<%g,%g,0>,<%g,%g,%g>,rr}\n"
+		   "cylinder{<%g,%g,0>,<%g,%g,%g>,rr}\n",bxy,by,bxy+bxz,by+byz,bz,bx+bxy,by,bx+bxy+bxz,by+byz,bz);
+	fprintf(fp,"sphere{<0,0,0>,rr}\nsphere{<%g,0,0>,rr}\n"
+		   "sphere{<%g,%g,0>,rr}\nsphere{<%g,%g,0>,rr}\n",bx,bxy,by,bx+bxy,by);
+	fprintf(fp,"sphere{<%g,%g,%g>,rr}\nsphere{<%g,%g,%g>,rr}\n"
+		   "sphere{<%g,%g,%g>,rr}\nsphere{<%g,%g,%g>,rr}\n",bxz,byz,bz,bx+bxz,byz,bz,bxy+bxz,by+byz,bz,bx+bxy+bxz,by+byz,bz);
+}
+
+}
diff -ru --new-file blender-2.76b.old/extern/voro++/src/unitcell.hh blender-2.76b/extern/voro++/src/unitcell.hh
--- blender-2.76b.old/extern/voro++/src/unitcell.hh	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/unitcell.hh	2016-01-27 19:07:21.253650661 +0300
@@ -0,0 +1,79 @@
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \file unitcell.hh
+ * \brief Header file for the unitcell class. */
+
+#ifndef VOROPP_UNITCELL_HH
+#define VOROPP_UNITCELL_HH
+
+#include <vector>
+
+#include "config.hh"
+#include "cell.hh"
+
+namespace voro {
+
+/** \brief Class for computation of the unit Voronoi cell associated with
+ * a 3D non-rectangular periodic domain. */
+class unitcell {
+	public:
+		/** The x coordinate of the first vector defining the periodic
+		 * domain. */
+		const double bx;
+		/** The x coordinate of the second vector defining the periodic
+		 * domain. */
+		const double bxy;
+		/** The y coordinate of the second vector defining the periodic
+		 * domain. */
+		const double by;
+		/** The x coordinate of the third vector defining the periodic
+		 * domain. */
+		const double bxz;
+		/** The y coordinate of the third vector defining the periodic
+		 * domain. */
+		const double byz;
+		/** The z coordinate of the third vector defining the periodic
+		 * domain. */
+		const double bz;
+		/** The computed unit Voronoi cell corresponding the given
+		 * 3D non-rectangular periodic domain geometry. */
+		voronoicell unit_voro;
+		unitcell(double bx_,double bxy_,double by_,double bxz_,double byz_,double bz_);
+		/** Draws an outline of the domain in Gnuplot format.
+		 * \param[in] filename the filename to write to. */
+		inline void draw_domain_gnuplot(const char* filename) {
+			FILE *fp(safe_fopen(filename,"w"));
+			draw_domain_gnuplot(fp);
+			fclose(fp);
+		}
+		void draw_domain_gnuplot(FILE *fp=stdout);
+		/** Draws an outline of the domain in Gnuplot format.
+		 * \param[in] filename the filename to write to. */
+		inline void draw_domain_pov(const char* filename) {
+			FILE *fp(safe_fopen(filename,"w"));
+			draw_domain_pov(fp);
+			fclose(fp);
+		}
+		void draw_domain_pov(FILE *fp=stdout);
+		bool intersects_image(double dx,double dy,double dz,double &vol);
+		void images(std::vector<int> &vi,std::vector<double> &vd);
+	protected:
+		/** The maximum y-coordinate that could possibly cut the
+		 * computed unit Voronoi cell. */
+		double max_uv_y;
+		/** The maximum z-coordinate that could possibly cut the
+		 * computed unit Voronoi cell. */
+		double max_uv_z;
+	private:
+		inline void unit_voro_apply(int i,int j,int k);
+		bool unit_voro_intersect(int l);
+		inline bool unit_voro_test(int i,int j,int k);
+};
+
+}
+
+#endif
diff -ru --new-file blender-2.76b.old/extern/voro++/src/v_base.cc blender-2.76b/extern/voro++/src/v_base.cc
--- blender-2.76b.old/extern/voro++/src/v_base.cc	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/v_base.cc	2016-01-27 19:08:48.955988752 +0300
@@ -0,0 +1,118 @@
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \file v_base.cc
+ * \brief Function implementations for the base Voronoi container class. */
+
+#include "v_base.hh"
+#include "config.hh"
+
+namespace voro {
+
+/** This function is called during container construction. The routine scans
+ * all of the worklists in the wl[] array. For a given worklist of blocks
+ * labeled \f$w_1\f$ to \f$w_n\f$, it computes a sequence \f$r_0\f$ to
+ * \f$r_n\f$ so that $r_i$ is the minimum distance to all the blocks
+ * \f$w_{j}\f$ where \f$j>i\f$ and all blocks outside the worklist. The values
+ * of \f$r_n\f$ is calculated first, as the minimum distance to any block in
+ * the shell surrounding the worklist. The \f$r_i\f$ are then computed in
+ * reverse order by considering the distance to \f$w_{i+1}\f$. */
+voro_base::voro_base(int nx_,int ny_,int nz_,double boxx_,double boxy_,double boxz_) :
+	nx(nx_), ny(ny_), nz(nz_), nxy(nx_*ny_), nxyz(nxy*nz_), boxx(boxx_), boxy(boxy_), boxz(boxz_),
+	xsp(1/boxx_), ysp(1/boxy_), zsp(1/boxz_), mrad(new double[wl_hgridcu*wl_seq_length]) {
+	const unsigned int b1=1<<21,b2=1<<22,b3=1<<24,b4=1<<25,b5=1<<27,b6=1<<28;
+	const double xstep=boxx/wl_fgrid,ystep=boxy/wl_fgrid,zstep=boxz/wl_fgrid;
+	int i,j,k,lx,ly,lz,q;
+	unsigned int f,*e=const_cast<unsigned int*> (wl);
+	double xlo,ylo,zlo,xhi,yhi,zhi,minr,*radp=mrad;
+	for(zlo=0,zhi=zstep,lz=0;lz<wl_hgrid;zlo=zhi,zhi+=zstep,lz++) {
+		for(ylo=0,yhi=ystep,ly=0;ly<wl_hgrid;ylo=yhi,yhi+=ystep,ly++) {
+			for(xlo=0,xhi=xstep,lx=0;lx<wl_hgrid;xlo=xhi,xhi+=xstep,lx++) {
+				minr=large_number;
+				for(q=e[0]+1;q<wl_seq_length;q++) {
+					f=e[q];
+					i=(f&127)-64;
+					j=(f>>7&127)-64;
+					k=(f>>14&127)-64;
+					if((f&b2)==b2) {
+						compute_minimum(minr,xlo,xhi,ylo,yhi,zlo,zhi,i-1,j,k);
+						if((f&b1)==0) compute_minimum(minr,xlo,xhi,ylo,yhi,zlo,zhi,i+1,j,k);
+					} else if((f&b1)==b1) compute_minimum(minr,xlo,xhi,ylo,yhi,zlo,zhi,i+1,j,k);
+					if((f&b4)==b4) {
+						compute_minimum(minr,xlo,xhi,ylo,yhi,zlo,zhi,i,j-1,k);
+						if((f&b3)==0) compute_minimum(minr,xlo,xhi,ylo,yhi,zlo,zhi,i,j+1,k);
+					} else if((f&b3)==b3) compute_minimum(minr,xlo,xhi,ylo,yhi,zlo,zhi,i,j+1,k);
+					if((f&b6)==b6) {
+						compute_minimum(minr,xlo,xhi,ylo,yhi,zlo,zhi,i,j,k-1);
+						if((f&b5)==0) compute_minimum(minr,xlo,xhi,ylo,yhi,zlo,zhi,i,j,k+1);
+					} else if((f&b5)==b5) compute_minimum(minr,xlo,xhi,ylo,yhi,zlo,zhi,i,j,k+1);
+				}
+				q--;
+				while(q>0) {
+					radp[q]=minr;
+					f=e[q];
+					i=(f&127)-64;
+					j=(f>>7&127)-64;
+					k=(f>>14&127)-64;
+					compute_minimum(minr,xlo,xhi,ylo,yhi,zlo,zhi,i,j,k);
+					q--;
+				}
+				*radp=minr;
+				e+=wl_seq_length;
+				radp+=wl_seq_length;
+			}
+		}
+	}
+}
+
+/** Computes the minimum distance from a subregion to a given block. If this distance
+ * is smaller than the value of minr, then it passes
+ * \param[in,out] minr a pointer to the current minimum distance. If the distance
+ *                     computed in this function is smaller, then this distance is
+ *                     set to the new one.
+ * \param[out] (xlo,ylo,zlo) the lower coordinates of the subregion being
+ *                           considered.
+ * \param[out] (xhi,yhi,zhi) the upper coordinates of the subregion being
+ *                           considered.
+ * \param[in] (ti,tj,tk) the coordinates of the block. */
+void voro_base::compute_minimum(double &minr,double &xlo,double &xhi,double &ylo,double &yhi,double &zlo,double &zhi,int ti,int tj,int tk) {
+	double radsq,temp;
+	if(ti>0) {temp=boxx*ti-xhi;radsq=temp*temp;}
+	else if(ti<0) {temp=xlo-boxx*(1+ti);radsq=temp*temp;}
+	else radsq=0;
+
+	if(tj>0) {temp=boxy*tj-yhi;radsq+=temp*temp;}
+	else if(tj<0) {temp=ylo-boxy*(1+tj);radsq+=temp*temp;}
+
+	if(tk>0) {temp=boxz*tk-zhi;radsq+=temp*temp;}
+	else if(tk<0) {temp=zlo-boxz*(1+tk);radsq+=temp*temp;}
+
+	if(radsq<minr) minr=radsq;
+}
+
+/** Checks to see whether "%n" appears in a format sequence to determine
+ * whether neighbor information is required or not.
+ * \param[in] format the format string to check.
+ * \return True if a "%n" is found, false otherwise. */
+bool voro_base::contains_neighbor(const char *format) {
+	char *fmp=(const_cast<char*>(format));
+
+	// Check to see if "%n" appears in the format sequence
+	while(*fmp!=0) {
+		if(*fmp=='%') {
+			fmp++;
+			if(*fmp=='n') return true;
+			else if(*fmp==0) return false;
+		}
+		fmp++;
+	}
+
+	return false;
+}
+
+#include "v_base_wl.cc"
+
+}
diff -ru --new-file blender-2.76b.old/extern/voro++/src/v_base.hh blender-2.76b/extern/voro++/src/v_base.hh
--- blender-2.76b.old/extern/voro++/src/v_base.hh	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/v_base.hh	2016-01-27 19:08:15.797239577 +0300
@@ -0,0 +1,88 @@
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \file v_base.hh
+ * \brief Header file for the base Voronoi container class. */
+
+#ifndef VOROPP_V_BASE_HH
+#define VOROPP_V_BASE_HH
+
+#include "worklist.hh"
+
+namespace voro {
+
+/** \brief Class containing data structures common across all particle container classes.
+ *
+ * This class contains constants and data structures that are common across all
+ * particle container classes. It contains constants setting the size of the
+ * underlying subgrid of blocks that forms the basis of the Voronoi cell
+ * computations. It also constructs bound tables that are used in the Voronoi
+ * cell computation, and contains a number of routines that are common across
+ * all container classes. */
+class voro_base {
+	public:
+		/** The number of blocks in the x direction. */
+		const int nx;
+		/** The number of blocks in the y direction. */
+		const int ny;
+		/** The number of blocks in the z direction. */
+		const int nz;
+		/** A constant, set to the value of nx multiplied by ny, which
+		 * is used in the routines that step through blocks in
+		 * sequence. */
+		const int nxy;
+		/** A constant, set to the value of nx*ny*nz, which is used in
+		 * the routines that step through blocks in sequence. */
+		const int nxyz;
+		/** The size of a computational block in the x direction. */
+		const double boxx;
+		/** The size of a computational block in the y direction. */
+		const double boxy;
+		/** The size of a computational block in the z direction. */
+		const double boxz;
+		/** The inverse box length in the x direction. */
+		const double xsp;
+		/** The inverse box length in the y direction. */
+		const double ysp;
+		/** The inverse box length in the z direction. */
+		const double zsp;
+		/** An array to hold the minimum distances associated with the
+		 * worklists. This array is initialized during container
+		 * construction, by the initialize_radii() routine. */
+		double *mrad;
+		/** The pre-computed block worklists. */
+		static const unsigned int wl[wl_seq_length*wl_hgridcu];
+		bool contains_neighbor(const char* format);
+		voro_base(int nx_,int ny_,int nz_,double boxx_,double boxy_,double boxz_);
+		~voro_base() {delete [] mrad;}
+	protected:
+		/** A custom int function that returns consistent stepping
+		 * for negative numbers, so that (-1.5, -0.5, 0.5, 1.5) maps
+		 * to (-2,-1,0,1).
+		 * \param[in] a the number to consider.
+		 * \return The value of the custom int operation. */
+		inline int step_int(double a) {return a<0?int(a)-1:int(a);}
+		/** A custom modulo function that returns consistent stepping
+		 * for negative numbers. For example, (-2,-1,0,1,2) step_mod 2
+		 * is (0,1,0,1,0).
+		 * \param[in] (a,b) the input integers.
+		 * \return The value of a modulo b, consistent for negative
+		 * numbers. */
+		inline int step_mod(int a,int b) {return a>=0?a%b:b-1-(b-1-a)%b;}
+		/** A custom integer division function that returns consistent
+		 * stepping for negative numbers. For example, (-2,-1,0,1,2)
+		 * step_div 2 is (-1,-1,0,0,1).
+		 * \param[in] (a,b) the input integers.
+		 * \return The value of a div b, consistent for negative
+		 * numbers. */
+		inline int step_div(int a,int b) {return a>=0?a/b:-1+(a+1)/b;}
+	private:
+		void compute_minimum(double &minr,double &xlo,double &xhi,double &ylo,double &yhi,double &zlo,double &zhi,int ti,int tj,int tk);
+};
+
+}
+
+#endif
diff -ru --new-file blender-2.76b.old/extern/voro++/src/v_base_wl.cc blender-2.76b/extern/voro++/src/v_base_wl.cc
--- blender-2.76b.old/extern/voro++/src/v_base_wl.cc	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/v_base_wl.cc	2016-01-27 19:09:24.660718750 +0300
@@ -0,0 +1,79 @@
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \file v_base_wl.cc
+ * \brief The table of block worklists that are used during the cell
+ * computation, which is part of the voro_base class.
+ *
+ * This file is automatically generated by worklist_gen.pl and it is not
+ * intended to be edited by hand. */
+
+const unsigned int voro_base::wl[wl_seq_length*wl_hgridcu]={
+	7,0x10203f,0x101fc0,0xfe040,0xfe03f,0x101fbf,0xfdfc0,0xfdfbf,0x10fe0bf,0x11020bf,0x11020c0,0x10fe0c0,0x2fe041,0x302041,0x301fc1,0x2fdfc1,0x8105fc0,0x8106040,0x810603f,0x8105fbf,0x701fbe,0x70203e,0x6fe03e,0x6fdfbe,0x30fdf3f,0x3101f3f,0x3101f40,0x30fdf40,0x180f9fc0,0x180fa040,0x180fa03f,0x180f9fbf,0x12fe0c1,0x13020c1,0x91060c0,0x91060bf,0x8306041,0x8305fc1,0x3301f41,0x32fdf41,0x182f9fc1,0x182fa041,0x190fa0c0,0x190fa0bf,0x16fe0be,0x17020be,0x870603e,0x8705fbe,0xb105f3f,0xb105f40,0x3701f3e,0x36fdf3e,0x186f9fbe,0x186fa03e,0x1b0f9f3f,0x1b0f9f40,0x93060c1,0x192fa0c1,0x97060be,0xb305f41,0x1b2f9f41,0x196fa0be,0xb705f3e,0x1b6f9f3e,
+	11,0x101fc0,0xfe040,0xfdfc0,0x10203f,0x101fbf,0xfe03f,0xfdfbf,0xfdfc1,0x101fc1,0x102041,0xfe041,0x10fe0c0,0x11020c0,0x8106040,0x8105fc0,0x8105fbf,0x810603f,0x11020bf,0x10fe0bf,0x180fa040,0x180f9fc0,0x30fdf40,0x3101f40,0x3101f3f,0x30fdf3f,0x180f9fbf,0x180fa03f,0x6fe03e,0x70203e,0x701fbe,0x6fdfbe,0x8105fc1,0x8106041,0x11020c1,0x10fe0c1,0x180fa041,0x180f9fc1,0x30fdf41,0x3101f41,0x91060c0,0x91060bf,0x190fa0c0,0x190fa0bf,0xb105f40,0xb105f3f,0x8705fbe,0x870603e,0x97020be,0x16fe0be,0x1b0f9f40,0x1b0f9f3f,0x36fdf3e,0xb701f3e,0x1b6f9fbe,0x196fa03e,0x93060c1,0xb305f41,0x192fa0c1,0x1b2f9f41,0x1b2fdfc2,0xb301fc2,0x9302042,0x192fe042,
+	11,0x101fc0,0xfe040,0xfdfc0,0xfdfbf,0x101fbf,0x10203f,0xfe03f,0xfe041,0x102041,0x101fc1,0xfdfc1,0x8105fc0,0x8106040,0x11020c0,0x10fe0c0,0x10fe0bf,0x11020bf,0x810603f,0x8105fbf,0x3101f40,0x30fdf40,0x180f9fc0,0x180fa040,0x180fa03f,0x180f9fbf,0x30fdf3f,0x3101f3f,0x8105fc1,0x8106041,0x11020c1,0x10fe0c1,0x180fa041,0x180f9fc1,0x30fdf41,0x3101f41,0x701fbe,0x70203e,0x6fe03e,0x6fdfbe,0x91060c0,0x91060bf,0xb105f40,0xb105f3f,0x190fa0c0,0x190fa0bf,0x93060c1,0x1b0f9f40,0x1b0f9f3f,0xb305f41,0x192fa0c1,0x16fe0be,0x17020be,0x970603e,0x8705fbe,0xb701f3e,0x36fdf3e,0x1b2f9f41,0x1b2fdfc2,0x192fe042,0x9302042,0xb301fc2,0x1b6f9fbe,0x196fa03e,
+	11,0x101fc0,0xfe040,0xfdfc0,0xfdfbf,0x101fbf,0x10203f,0xfe03f,0xfe041,0x102041,0x101fc1,0xfdfc1,0x8105fc0,0x8106040,0x11020c0,0x10fe0c0,0x10fe0bf,0x11020bf,0x810603f,0x8105fbf,0x3101f40,0x30fdf40,0x180f9fc0,0x180fa040,0x10fe0c1,0x11020c1,0x8106041,0x8105fc1,0x3101f3f,0x30fdf3f,0x180f9fbf,0x180fa03f,0x180fa041,0x180f9fc1,0x30fdf41,0x3101f41,0x91060c0,0x91060bf,0x70203e,0x701fbe,0x6fdfbe,0x6fe03e,0x190fa0c0,0xb105f40,0xb105f3f,0x93060c1,0x190fa0bf,0x192fa0c1,0x1b0f9f40,0x1b0f9f3f,0xb305f41,0xb301fc2,0x9302042,0x192fe042,0x1b2fdfc2,0x1b2f9f41,0x16fe0be,0x17020be,0x970603e,0x8705fbe,0xb701f3e,0x36fdf3e,0x1b6f9fbe,0x196fa03e,
+	11,0x10203f,0xfe040,0xfe03f,0x101fc0,0x101fbf,0xfdfc0,0xfdfbf,0xfe0bf,0x1020bf,0x1020c0,0xfe0c0,0x2fe041,0x302041,0x8106040,0x810603f,0x8105fbf,0x8105fc0,0x301fc1,0x2fdfc1,0x180fa040,0x180fa03f,0x6fe03e,0x70203e,0x701fbe,0x6fdfbe,0x180f9fbf,0x180f9fc0,0x30fdf40,0x3101f40,0x3101f3f,0x30fdf3f,0x81060bf,0x81060c0,0x3020c1,0x2fe0c1,0x180fa0c0,0x180fa0bf,0x6fe0be,0x7020be,0x8306041,0x8305fc1,0x182fa041,0x182f9fc1,0x870603e,0x8705fbe,0xb105f3f,0xb105f40,0xb301f41,0x32fdf41,0x186fa03e,0x186f9fbe,0x36fdf3e,0xb701f3e,0x1b6f9f3f,0x1b2f9f40,0x93060c1,0x97060be,0x192fa0c1,0x196fa0be,0x196fe13f,0x970213f,0x9302140,0x192fe140,
+	9,0xfe040,0x10203f,0x101fc0,0xfdfc0,0xfe03f,0xfdfbf,0x101fbf,0x102041,0xfe041,0x10fe0c0,0x11020c0,0x11020bf,0x10fe0bf,0xfdfc1,0x101fc1,0x8106040,0x810603f,0x8105fc0,0x8105fbf,0x180fa040,0x180f9fc0,0x180fa03f,0x180f9fbf,0x10fe0c1,0x11020c1,0x70203e,0x6fe03e,0x6fdfbe,0x701fbe,0x3101f3f,0x3101f40,0x30fdf40,0x30fdf3f,0x8106041,0x91060c0,0x91060bf,0x8305fc1,0x180fa041,0x190fa0c0,0x190fa0bf,0x180f9fc1,0x30fdf41,0x3301f41,0x17020be,0x16fe0be,0x93060c1,0x870603e,0x8705fbe,0xb105f3f,0xb105f40,0x192fa0c1,0x1b0f9f40,0x1b0f9f3f,0x186f9fbe,0x196fa03e,0x1b6fdf3e,0xb701f3e,0x97060be,0xb305f41,0x1b2f9f41,0x1b2fdfc2,0x192fe042,0xa302042,
+	11,0xfe040,0x101fc0,0xfdfc0,0xfe03f,0x10203f,0x101fbf,0xfdfbf,0xfe041,0x102041,0x101fc1,0xfdfc1,0x10fe0c0,0x11020c0,0x11020bf,0x10fe0bf,0x8106040,0x8105fc0,0x810603f,0x8105fbf,0x11020c1,0x10fe0c1,0x180fa040,0x180f9fc0,0x180fa03f,0x180f9fbf,0x30fdf40,0x3101f40,0x8106041,0x8105fc1,0x3101f3f,0x30fdf3f,0x91060c0,0x91060bf,0x180fa041,0x180f9fc1,0x6fe03e,0x70203e,0x701fbe,0x6fdfbe,0x190fa0c0,0x190fa0bf,0x30fdf41,0x3101f41,0x93060c1,0x192fa0c1,0xb105f40,0xb105f3f,0x17020be,0x16fe0be,0x970603e,0x8705fbe,0x1b0f9f40,0x1b0f9f3f,0x186f9fbe,0x196fa03e,0xb305f41,0xb301fc2,0x9302042,0x192fe042,0x1b2fdfc2,0x1b2f9f41,0x1b6fdf3e,0xb701f3e,
+	11,0xfe040,0x101fc0,0xfdfc0,0xfe03f,0x10203f,0x101fbf,0xfdfbf,0xfe041,0x102041,0x101fc1,0xfdfc1,0x10fe0c0,0x11020c0,0x11020bf,0x10fe0bf,0x8106040,0x8105fc0,0x11020c1,0x10fe0c1,0x810603f,0x8105fbf,0x180fa040,0x180f9fc0,0x8106041,0x8105fc1,0x3101f40,0x180fa03f,0x180f9fbf,0x30fdf40,0x180fa041,0x180f9fc1,0x91060c0,0x3101f3f,0x30fdf3f,0x30fdf41,0x3101f41,0x91060bf,0x190fa0c0,0x91060c1,0x190fa0bf,0x186fe03e,0x70203e,0x3701fbe,0x1b6fdfbe,0x190fa0c1,0x182fe042,0xb105f40,0xb105f3f,0x302042,0x3301fc2,0x1b2fdfc2,0x1b0f9f40,0x1b6f9f3f,0xb105f41,0x17020be,0x196fe0be,0x970603e,0xb705fbe,0x1b2f9f41,0x192fe0c2,0x13020c2,0x9306042,0xb305fc2,
+	11,0x10203f,0xfe040,0xfe03f,0xfdfbf,0x101fbf,0x101fc0,0xfdfc0,0xfe0c0,0x1020c0,0x1020bf,0xfe0bf,0x810603f,0x8106040,0x302041,0x2fe041,0x2fdfc1,0x301fc1,0x8105fc0,0x8105fbf,0x70203e,0x6fe03e,0x180fa03f,0x180fa040,0x180f9fc0,0x180f9fbf,0x6fdfbe,0x701fbe,0x81060bf,0x81060c0,0x3020c1,0x2fe0c1,0x180fa0c0,0x180fa0bf,0x6fe0be,0x7020be,0x3101f3f,0x3101f40,0x30fdf40,0x30fdf3f,0x8306041,0x8305fc1,0x870603e,0x8705fbe,0x182fa041,0x182f9fc1,0x93060c1,0x186fa03e,0x186f9fbe,0x97060be,0x192fa0c1,0x32fdf41,0x3301f41,0xb305f40,0xb105f3f,0xb701f3e,0x36fdf3e,0x196fa0be,0x196fe13f,0x192fe140,0x9302140,0x970213f,0x1b6f9f3f,0x1b2f9f40,
+	11,0xfe040,0x10203f,0xfe03f,0xfdfc0,0x101fc0,0x101fbf,0xfdfbf,0xfe0c0,0x1020c0,0x1020bf,0xfe0bf,0x2fe041,0x302041,0x301fc1,0x2fdfc1,0x8106040,0x810603f,0x8105fc0,0x8105fbf,0x3020c1,0x2fe0c1,0x180fa040,0x180fa03f,0x180f9fc0,0x180f9fbf,0x6fe03e,0x70203e,0x81060c0,0x81060bf,0x701fbe,0x6fdfbe,0x8306041,0x8305fc1,0x180fa0c0,0x180fa0bf,0x30fdf40,0x3101f40,0x3101f3f,0x30fdf3f,0x182fa041,0x182f9fc1,0x6fe0be,0x7020be,0x93060c1,0x192fa0c1,0x870603e,0x8705fbe,0x3301f41,0x32fdf41,0xb305f40,0xb105f3f,0x186fa03e,0x186f9fbe,0x1b0f9f3f,0x1b2f9f40,0x97060be,0x970213f,0x9302140,0x192fe140,0x196fe13f,0x196fa0be,0x1b6fdf3e,0xb701f3e,
+	15,0xfe040,0xfe03f,0x10203f,0x101fc0,0xfdfc0,0xfdfbf,0x101fbf,0x102041,0xfe041,0xfe0c0,0x1020c0,0x1020bf,0xfe0bf,0xfdfc1,0x101fc1,0x8106040,0x1020c1,0xfe0c1,0x810603f,0x8105fc0,0x8105fbf,0x180fa040,0x180fa03f,0x180f9fc0,0x180f9fbf,0x8106041,0x81060c0,0x81060bf,0x8105fc1,0x180fa041,0x180fa0c0,0x180fa0bf,0x6fe03e,0x70203e,0x3101f40,0x30fdf40,0x180f9fc1,0x30fdf3f,0x3101f3f,0x3701fbe,0x36fdfbe,0x93060c1,0x192fa0c1,0x6fe0be,0x7020be,0x3101f41,0x30fdf41,0xb305f40,0xb105f3f,0x970603e,0xb705fbe,0x196fa03e,0x186f9fbe,0x1b2f9f40,0x1b6f9f3f,0x192fe042,0x9302042,0xb301fc2,0x1b2fdfc2,0x192fe140,0x9302140,0x970213f,0x196fe13f,
+	15,0xfe040,0xfdfc0,0x101fc0,0x10203f,0xfe03f,0xfdfbf,0x101fbf,0x102041,0xfe041,0xfdfc1,0x101fc1,0x1020c0,0xfe0c0,0xfe0bf,0x1020bf,0x1020c1,0xfe0c1,0x8106040,0x8105fc0,0x810603f,0x8105fbf,0x180fa040,0x180f9fc0,0x8106041,0x8105fc1,0x81060c0,0x180fa03f,0x180f9fbf,0x180fa041,0x180f9fc1,0x180fa0c0,0x81060bf,0x91060c1,0x3101f40,0x30fdf40,0x30fdf3f,0x180fa0bf,0x190fa0c1,0x3101f3f,0x3101f41,0x30fdf41,0x186fe03e,0x70203e,0x3701fbe,0x1b6fdfbe,0x186fe0be,0x7020be,0x8302042,0x182fe042,0x1b2fdfc2,0xb301fc2,0xb105f40,0xb705f3f,0xb305f41,0x1b2f9f40,0x1b6f9f3f,0x192fe140,0x9302140,0x93020c2,0x192fe0c2,0x196fe13f,0x970213f,0xa70603e,
+	11,0x10203f,0xfe040,0xfe03f,0xfdfbf,0x101fbf,0x101fc0,0xfdfc0,0xfe0c0,0x1020c0,0x1020bf,0xfe0bf,0x810603f,0x8106040,0x302041,0x2fe041,0x2fdfc1,0x301fc1,0x8105fc0,0x8105fbf,0x70203e,0x6fe03e,0x180fa03f,0x180fa040,0x2fe0c1,0x3020c1,0x81060c0,0x81060bf,0x701fbe,0x6fdfbe,0x180f9fbf,0x180f9fc0,0x180fa0c0,0x180fa0bf,0x6fe0be,0x7020be,0x8306041,0x8305fc1,0x3101f40,0x3101f3f,0x30fdf3f,0x30fdf40,0x182fa041,0x870603e,0x8705fbe,0x93060c1,0x182f9fc1,0x192fa0c1,0x186fa03e,0x186f9fbe,0x97060be,0x970213f,0x9302140,0x192fe140,0x196fe13f,0x196fa0be,0x32fdf41,0x3301f41,0xb305f40,0xb105f3f,0xb701f3e,0x36fdf3e,0x1b6f9f3f,0x1b2f9f40,
+	11,0xfe040,0x10203f,0xfe03f,0xfdfc0,0x101fc0,0x101fbf,0xfdfbf,0xfe0c0,0x1020c0,0x1020bf,0xfe0bf,0x2fe041,0x302041,0x301fc1,0x2fdfc1,0x8106040,0x810603f,0x3020c1,0x2fe0c1,0x8105fc0,0x8105fbf,0x180fa040,0x180fa03f,0x81060c0,0x81060bf,0x70203e,0x180f9fc0,0x180f9fbf,0x6fe03e,0x180fa0c0,0x180fa0bf,0x8306041,0x701fbe,0x6fdfbe,0x6fe0be,0x7020be,0x8305fc1,0x182fa041,0x83060c1,0x182f9fc1,0x1b0fdf40,0x3101f40,0x3701f3f,0x1b6fdf3f,0x182fa0c1,0x190fe140,0x870603e,0x8705fbe,0x1102140,0x170213f,0x196fe13f,0x186fa03e,0x1b6f9fbe,0x87060be,0x3301f41,0x1b2fdf41,0xb305f40,0xb705f3f,0x196fa0be,0x192fe141,0x1302141,0x9306140,0x970613f,
+	15,0xfe040,0xfe03f,0x10203f,0x101fc0,0xfdfc0,0xfdfbf,0x101fbf,0x1020c0,0xfe0c0,0xfe0bf,0x1020bf,0x102041,0xfe041,0xfdfc1,0x101fc1,0x1020c1,0xfe0c1,0x8106040,0x810603f,0x8105fc0,0x8105fbf,0x180fa040,0x180fa03f,0x81060c0,0x81060bf,0x8106041,0x180f9fc0,0x180f9fbf,0x180fa0c0,0x180fa0bf,0x180fa041,0x8105fc1,0x83060c1,0x70203e,0x6fe03e,0x6fdfbe,0x180f9fc1,0x182fa0c1,0x701fbe,0x7020be,0x6fe0be,0x1b0fdf40,0x3101f40,0x3701f3f,0x1b6fdf3f,0x1b0fdf41,0x3101f41,0x9102140,0x190fe140,0x196fe13f,0x970213f,0x870603e,0xb705fbe,0x97060be,0x196fa03e,0x1b6f9fbe,0x192fe042,0x9302042,0x9302141,0x192fe141,0x1b2fdfc2,0xb301fc2,0xb505f40,
+	17,0xfe040,0xfe03f,0x10203f,0x101fc0,0xfdfc0,0xfe041,0x102041,0x1020c0,0xfe0c0,0xfdfbf,0x101fbf,0x1020bf,0xfe0bf,0xfdfc1,0x101fc1,0x1020c1,0xfe0c1,0x8106040,0x810603f,0x8105fc0,0x8106041,0x81060c0,0x180fa040,0x180fa03f,0x180f9fc0,0x8105fbf,0x81060bf,0x8105fc1,0x180fa041,0x180fa0c0,0x180f9fbf,0x81060c1,0x180fa0bf,0x180f9fc1,0x180fa0c1,0x186fe03e,0x70203e,0x3101f40,0x1b0fdf40,0x1b0fdf3f,0x3101f3f,0x3701fbe,0x1b6fdfbe,0x186fe0be,0x7020be,0x9102140,0x190fe140,0x182fe042,0x8302042,0x3101f41,0x1b0fdf41,0x1b2fdfc2,0xb301fc2,0x83020c2,0x182fe0c2,0x196fe13f,0x970213f,0x9302141,0x192fe141,0x970603e,0xb305f40,0xb105f3f,0xb705fbe,
+	11,0x10203f,0x101fc0,0x101fbf,0xfe040,0xfe03f,0xfdfc0,0xfdfbf,0x105fbf,0x10603f,0x106040,0x105fc0,0x301fc1,0x302041,0x11020c0,0x11020bf,0x10fe0bf,0x10fe0c0,0x2fe041,0x2fdfc1,0x3101f40,0x3101f3f,0x701fbe,0x70203e,0x6fe03e,0x6fdfbe,0x30fdf3f,0x30fdf40,0x180f9fc0,0x180fa040,0x180fa03f,0x180f9fbf,0x11060bf,0x11060c0,0x306041,0x305fc1,0x3105f40,0x3105f3f,0x705fbe,0x70603e,0x13020c1,0x12fe0c1,0x3301f41,0x32fdf41,0x17020be,0x16fe0be,0x190fa0bf,0x190fa0c0,0x192fa041,0x182f9fc1,0x3701f3e,0x36fdf3e,0x186f9fbe,0x196fa03e,0x1b6f9f3f,0x1b2f9f40,0x93060c1,0x97060be,0xb305f41,0xb705f3e,0xb709fbf,0x970a03f,0x930a040,0xb309fc0,
+	9,0x101fc0,0x10203f,0xfe040,0xfdfc0,0x101fbf,0xfdfbf,0xfe03f,0x102041,0x101fc1,0x8105fc0,0x8106040,0x810603f,0x8105fbf,0xfdfc1,0xfe041,0x11020c0,0x11020bf,0x10fe0c0,0x10fe0bf,0x3101f40,0x30fdf40,0x3101f3f,0x30fdf3f,0x8105fc1,0x8106041,0x70203e,0x701fbe,0x6fdfbe,0x6fe03e,0x180fa03f,0x180fa040,0x180f9fc0,0x180f9fbf,0x11020c1,0x91060c0,0x91060bf,0x12fe0c1,0x3101f41,0xb105f40,0xb105f3f,0x30fdf41,0x180f9fc1,0x182fa041,0x870603e,0x8705fbe,0x93060c1,0x17020be,0x16fe0be,0x190fa0bf,0x190fa0c0,0xb305f41,0x1b0f9f40,0x1b0f9f3f,0x36fdf3e,0xb701f3e,0x1b6f9fbe,0x196fa03e,0x97060be,0x192fa0c1,0x1b2f9f41,0x1b2fdfc2,0xb301fc2,0x11302042,
+	11,0x101fc0,0xfe040,0xfdfc0,0x101fbf,0x10203f,0xfe03f,0xfdfbf,0x101fc1,0x102041,0xfe041,0xfdfc1,0x8105fc0,0x8106040,0x810603f,0x8105fbf,0x11020c0,0x10fe0c0,0x11020bf,0x10fe0bf,0x8106041,0x8105fc1,0x3101f40,0x30fdf40,0x3101f3f,0x30fdf3f,0x180f9fc0,0x180fa040,0x11020c1,0x10fe0c1,0x180fa03f,0x180f9fbf,0x91060c0,0x91060bf,0x3101f41,0x30fdf41,0x701fbe,0x70203e,0x6fe03e,0x6fdfbe,0xb105f40,0xb105f3f,0x180f9fc1,0x180fa041,0x93060c1,0xb305f41,0x190fa0c0,0x190fa0bf,0x870603e,0x8705fbe,0x97020be,0x16fe0be,0x1b0f9f40,0x1b0f9f3f,0x36fdf3e,0xb701f3e,0x192fa0c1,0x192fe042,0x9302042,0xb301fc2,0x1b2fdfc2,0x1b2f9f41,0x1b6f9fbe,0x196fa03e,
+	11,0x101fc0,0xfe040,0xfdfc0,0x101fbf,0x10203f,0xfe03f,0xfdfbf,0x101fc1,0x102041,0xfe041,0xfdfc1,0x8105fc0,0x8106040,0x810603f,0x8105fbf,0x11020c0,0x10fe0c0,0x8106041,0x8105fc1,0x11020bf,0x10fe0bf,0x3101f40,0x30fdf40,0x11020c1,0x10fe0c1,0x180fa040,0x3101f3f,0x30fdf3f,0x180f9fc0,0x3101f41,0x30fdf41,0x91060c0,0x180fa03f,0x180f9fbf,0x180f9fc1,0x180fa041,0x91060bf,0xb105f40,0x91060c1,0xb105f3f,0x3701fbe,0x70203e,0x186fe03e,0x1b6fdfbe,0xb105f41,0x3301fc2,0x190fa0c0,0x190fa0bf,0x302042,0x182fe042,0x1b2fdfc2,0x1b0f9f40,0x1b6f9f3f,0x190fa0c1,0x870603e,0xb705fbe,0x97020be,0x196fe0be,0x1b2f9f41,0xb305fc2,0x8306042,0x93020c2,0x192fe0c2,
+	9,0x10203f,0x101fc0,0xfe040,0xfe03f,0x101fbf,0xfdfbf,0xfdfc0,0x1020c0,0x1020bf,0x810603f,0x8106040,0x8105fc0,0x8105fbf,0xfe0bf,0xfe0c0,0x302041,0x301fc1,0x2fe041,0x2fdfc1,0x70203e,0x6fe03e,0x701fbe,0x6fdfbe,0x81060bf,0x81060c0,0x3101f40,0x3101f3f,0x30fdf3f,0x30fdf40,0x180f9fc0,0x180fa040,0x180fa03f,0x180f9fbf,0x3020c1,0x8306041,0x8305fc1,0x12fe0c1,0x7020be,0x870603e,0x8705fbe,0x6fe0be,0x180fa0bf,0x190fa0c0,0xb105f40,0xb105f3f,0x93060c1,0x3301f41,0x32fdf41,0x182f9fc1,0x182fa041,0x97060be,0x186fa03e,0x186f9fbe,0x36fdf3e,0xb701f3e,0x1b6f9f3f,0x1b2f9f40,0xb305f41,0x192fa0c1,0x196fa0be,0x196fe13f,0x970213f,0x11302140,
+	7,0x10203f,0x101fc0,0xfe040,0xfe03f,0x101fbf,0xfdfc0,0xfdfbf,0x302041,0x1020c0,0x8106040,0x810603f,0x1020bf,0xfe0c0,0x2fe041,0x301fc1,0x8105fc0,0x8105fbf,0xfe0bf,0x2fdfc1,0x3020c1,0x8306041,0x81060c0,0x81060bf,0x2fe0c1,0x8305fc1,0x3101f40,0x3101f3f,0x701fbe,0x70203e,0x6fe03e,0x180fa03f,0x180fa040,0x180f9fc0,0x30fdf40,0x30fdf3f,0x6fdfbe,0x180f9fbf,0x180fa0c0,0x182fa041,0x93060c1,0x870603e,0x7020be,0x6fe0be,0x180fa0bf,0x182f9fc1,0x32fdf41,0x3301f41,0xb105f40,0xb105f3f,0x8705fbe,0x97060be,0x192fa0c1,0xb305f41,0xb701f3e,0x36fdf3e,0x1b0f9f3f,0x1b2f9f40,0x1b6f9fbe,0x196fa03e,0x196fe13f,0x9302140,0x970213f,0x192fe140,
+	11,0x101fc0,0xfe040,0xfdfc0,0x10203f,0x101fbf,0xfe03f,0xfdfbf,0x102041,0x101fc1,0xfe041,0xfdfc1,0x11020c0,0x8106040,0x8105fc0,0x10fe0c0,0x11020bf,0x810603f,0x8105fbf,0x10fe0bf,0x11020c1,0x8106041,0x8105fc1,0x10fe0c1,0x91060c0,0x91060bf,0x3101f40,0x30fdf40,0x180f9fc0,0x180fa040,0x180fa03f,0x180f9fbf,0x30fdf3f,0x3101f3f,0x701fbe,0x70203e,0x6fe03e,0x6fdfbe,0x93060c1,0x3101f41,0x30fdf41,0x180f9fc1,0x180fa041,0x190fa0c0,0x190fa0bf,0xb105f40,0xb105f3f,0x8705fbe,0x870603e,0x17020be,0x16fe0be,0x192fa0c1,0xb305f41,0xb301fc2,0x9302042,0x192fe042,0x1b2fdfc2,0x1b2f9f40,0x1b0f9f3f,0x186f9fbe,0x196fa03e,0x97060be,0xb701f3e,0x1b6fdf3e,
+	11,0x101fc0,0xfe040,0xfdfc0,0x10203f,0x101fbf,0xfe03f,0xfdfbf,0x102041,0x101fc1,0xfe041,0xfdfc1,0x11020c0,0x8106040,0x8105fc0,0x10fe0c0,0x11020bf,0x810603f,0x8105fbf,0x10fe0bf,0x11020c1,0x8106041,0x8105fc1,0x10fe0c1,0x91060c0,0x91060bf,0x3101f40,0x30fdf40,0x180f9fc0,0x180fa040,0x180fa03f,0x180f9fbf,0x30fdf3f,0x3101f3f,0x3101f41,0x91060c1,0x180fa041,0x180f9fc1,0x30fdf41,0xb105f40,0x70203e,0x3701fbe,0x186fe03e,0x1b6fdfbe,0x190fa0c0,0x190fa0bf,0x190fa0c1,0xb105f3f,0xb105f41,0x3301fc2,0x302042,0x182fe042,0x1b2fdfc2,0x1b0f9f40,0x17020be,0x970603e,0xb705fbe,0x196fe0be,0x1b6f9f3f,0x1b2f9f41,0x13020c2,0x9306042,0xb305fc2,0x192fe0c2,
+	11,0x10203f,0xfe040,0xfe03f,0x101fbf,0x101fc0,0xfdfc0,0xfdfbf,0x1020bf,0x1020c0,0xfe0c0,0xfe0bf,0x810603f,0x8106040,0x8105fc0,0x8105fbf,0x302041,0x2fe041,0x301fc1,0x2fdfc1,0x81060c0,0x81060bf,0x70203e,0x6fe03e,0x701fbe,0x6fdfbe,0x180fa03f,0x180fa040,0x3020c1,0x2fe0c1,0x180f9fc0,0x180f9fbf,0x8306041,0x8305fc1,0x7020be,0x6fe0be,0x3101f3f,0x3101f40,0x30fdf40,0x30fdf3f,0x870603e,0x8705fbe,0x180fa0bf,0x180fa0c0,0x93060c1,0x97060be,0x182fa041,0x182f9fc1,0xb105f40,0xb105f3f,0xb301f41,0x32fdf41,0x186fa03e,0x186f9fbe,0x36fdf3e,0xb701f3e,0x192fa0c1,0x192fe140,0x9302140,0x970213f,0x196fe13f,0x196fa0be,0x1b6f9f3f,0x1b2f9f40,
+	11,0x10203f,0xfe040,0xfe03f,0x101fc0,0x101fbf,0xfdfc0,0xfdfbf,0x1020c0,0x1020bf,0xfe0c0,0xfe0bf,0x302041,0x8106040,0x810603f,0x2fe041,0x301fc1,0x8105fc0,0x8105fbf,0x2fdfc1,0x3020c1,0x81060c0,0x81060bf,0x2fe0c1,0x8306041,0x8305fc1,0x70203e,0x6fe03e,0x180fa03f,0x180fa040,0x180f9fc0,0x180f9fbf,0x6fdfbe,0x701fbe,0x3101f3f,0x3101f40,0x30fdf40,0x30fdf3f,0x93060c1,0x7020be,0x6fe0be,0x180fa0bf,0x180fa0c0,0x182fa041,0x182f9fc1,0x870603e,0x8705fbe,0xb105f3f,0xb105f40,0x3301f41,0x32fdf41,0x192fa0c1,0x97060be,0x970213f,0x9302140,0x192fe140,0x196fe13f,0x196fa03e,0x186f9fbe,0x1b0f9f3f,0x1b2f9f40,0xb305f41,0xb701f3e,0x1b6fdf3e,
+	15,0xfe040,0x10203f,0x101fc0,0xfdfc0,0xfe03f,0x101fbf,0xfdfbf,0x102041,0x1020c0,0xfe0c0,0xfe041,0x101fc1,0xfdfc1,0x1020bf,0xfe0bf,0x8106040,0x810603f,0x8105fc0,0x8105fbf,0x1020c1,0xfe0c1,0x8106041,0x81060c0,0x81060bf,0x8105fc1,0x180fa040,0x180f9fc0,0x180fa03f,0x180f9fbf,0x93060c1,0x70203e,0x6fe03e,0x3101f40,0x1b0fdf40,0x3101f3f,0x3701fbe,0x6fdfbe,0x1b6fdf3f,0x180fa041,0x180fa0c0,0x180fa0bf,0x180f9fc1,0x1b0fdf41,0x3101f41,0x7020be,0x6fe0be,0x870603e,0x8705fbe,0xb105f40,0xb705f3f,0x192fa0c1,0x192fe140,0x9302140,0x970213f,0x97060be,0x9302042,0x192fe042,0xb301fc2,0xb305f41,0x1b2fdfc2,0x196fe13f,0x196fa03e,0x1b6f9fbe,
+	14,0xfe040,0x101fc0,0xfdfc0,0x10203f,0xfe03f,0x101fbf,0xfdfbf,0x102041,0xfe041,0x101fc1,0xfdfc1,0x1020c0,0xfe0c0,0x1020bf,0x8106040,0xfe0bf,0x8105fc0,0x1020c1,0xfe0c1,0x810603f,0x8105fbf,0x8106041,0x8105fc1,0x81060c0,0x81060bf,0x91060c1,0x180fa040,0x180f9fc0,0x180fa03f,0x180f9fbf,0x180fa041,0x180f9fc1,0x1b0fdf40,0x3101f40,0x3101f3f,0x1b0fdf3f,0x180fa0c0,0x190fa0bf,0x186fe03e,0x70203e,0x3701fbe,0x3101f41,0x1b0fdf41,0x1b6fdfbe,0x190fa0c1,0x182fe042,0x302042,0xb105f40,0xb105f3f,0x3301fc2,0x1b2fdfc2,0x7020be,0x196fe0be,0x970603e,0xb705fbe,0xb105f41,0x9302140,0x192fe140,0x13020c2,0x192fe0c2,0x9306042,0xb305fc2,0x1170213f,
+	11,0x10203f,0xfe040,0xfe03f,0x101fbf,0x101fc0,0xfdfc0,0xfdfbf,0x1020bf,0x1020c0,0xfe0c0,0xfe0bf,0x810603f,0x8106040,0x8105fc0,0x8105fbf,0x302041,0x2fe041,0x81060c0,0x81060bf,0x301fc1,0x2fdfc1,0x70203e,0x6fe03e,0x3020c1,0x2fe0c1,0x180fa040,0x701fbe,0x6fdfbe,0x180fa03f,0x7020be,0x6fe0be,0x8306041,0x180f9fc0,0x180f9fbf,0x180fa0bf,0x180fa0c0,0x8305fc1,0x870603e,0x83060c1,0x8705fbe,0x3701f3f,0x3101f40,0x1b0fdf40,0x1b6fdf3f,0x87060be,0x170213f,0x182fa041,0x182f9fc1,0x1102140,0x190fe140,0x196fe13f,0x186fa03e,0x1b6f9fbe,0x182fa0c1,0xb105f40,0xb705f3f,0xb301f41,0x1b2fdf41,0x196fa0be,0x970613f,0x9106140,0x9302141,0x192fe141,
+	11,0x10203f,0xfe040,0xfe03f,0x101fc0,0x101fbf,0xfdfc0,0xfdfbf,0x1020c0,0x1020bf,0xfe0c0,0xfe0bf,0x302041,0x8106040,0x810603f,0x2fe041,0x301fc1,0x8105fc0,0x8105fbf,0x2fdfc1,0x3020c1,0x81060c0,0x81060bf,0x2fe0c1,0x8306041,0x8305fc1,0x70203e,0x6fe03e,0x180fa03f,0x180fa040,0x180f9fc0,0x180f9fbf,0x6fdfbe,0x701fbe,0x7020be,0x83060c1,0x180fa0c0,0x180fa0bf,0x6fe0be,0x870603e,0x3101f40,0x3701f3f,0x1b0fdf40,0x1b6fdf3f,0x182fa041,0x182f9fc1,0x182fa0c1,0x8705fbe,0x87060be,0x170213f,0x1102140,0x190fe140,0x196fe13f,0x186fa03e,0x3301f41,0xb305f40,0xb705f3f,0x1b2fdf41,0x1b6f9fbe,0x196fa0be,0x1302141,0x9306140,0x970613f,0x192fe141,
+	14,0xfe040,0x10203f,0xfe03f,0x101fc0,0xfdfc0,0x101fbf,0xfdfbf,0x1020c0,0xfe0c0,0x1020bf,0xfe0bf,0x102041,0xfe041,0x101fc1,0x8106040,0xfdfc1,0x810603f,0x1020c1,0xfe0c1,0x8105fc0,0x8105fbf,0x81060c0,0x81060bf,0x8106041,0x8105fc1,0x83060c1,0x180fa040,0x180fa03f,0x180f9fc0,0x180f9fbf,0x180fa0c0,0x180fa0bf,0x186fe03e,0x70203e,0x701fbe,0x186fdfbe,0x180fa041,0x182f9fc1,0x1b0fdf40,0x3101f40,0x3701f3f,0x7020be,0x186fe0be,0x1b6fdf3f,0x182fa0c1,0x190fe140,0x1102140,0x870603e,0x8705fbe,0x170213f,0x196fe13f,0x3101f41,0x1b2fdf41,0xb305f40,0xb705f3f,0x87060be,0x9302042,0x192fe042,0x1302141,0x192fe141,0x9306140,0x970613f,0x13301fc2,
+	17,0xfe040,0x10203f,0x101fc0,0xfdfc0,0xfe03f,0x1020c0,0x102041,0xfe041,0xfe0c0,0x101fbf,0xfdfbf,0x1020bf,0xfe0bf,0x101fc1,0xfdfc1,0x1020c1,0xfe0c1,0x8106040,0x810603f,0x8105fc0,0x8106041,0x81060c0,0x8105fbf,0x81060bf,0x8105fc1,0x81060c1,0x180fa040,0x180f9fc0,0x180fa03f,0x180fa0c0,0x180fa041,0x180f9fbf,0x180fa0bf,0x180f9fc1,0x180fa0c1,0x70203e,0x186fe03e,0x3101f40,0x1b0fdf40,0x3101f3f,0x3701fbe,0x186fdfbe,0x1b6fdf3f,0x3101f41,0x1b0fdf41,0x8302042,0x182fe042,0x9102140,0x7020be,0x186fe0be,0x190fe140,0x970213f,0x196fe13f,0x9102141,0xb301fc2,0x1b2fdfc2,0x93020c2,0x182fe0c2,0x192fe141,0x970603e,0xb305f40,0xb105f3f,0xb705fbe,
+	11,0x10203f,0x101fc0,0x101fbf,0xfdfbf,0xfe03f,0xfe040,0xfdfc0,0x105fc0,0x106040,0x10603f,0x105fbf,0x11020bf,0x11020c0,0x302041,0x301fc1,0x2fdfc1,0x2fe041,0x10fe0c0,0x10fe0bf,0x70203e,0x701fbe,0x3101f3f,0x3101f40,0x30fdf40,0x30fdf3f,0x6fdfbe,0x6fe03e,0x11060bf,0x11060c0,0x306041,0x305fc1,0x3105f40,0x3105f3f,0x705fbe,0x70603e,0x180fa03f,0x180fa040,0x180f9fc0,0x180f9fbf,0x13020c1,0x12fe0c1,0x17020be,0x16fe0be,0x3301f41,0x32fdf41,0x93060c1,0x3701f3e,0x36fdf3e,0x97060be,0xb305f41,0x182f9fc1,0x182fa041,0x192fa0c0,0x190fa0bf,0x196fa03e,0x186f9fbe,0xb705f3e,0xb709fbf,0xb309fc0,0x930a040,0x970a03f,0x1b6f9f3f,0x1b2f9f40,
+	11,0x101fc0,0x10203f,0x101fbf,0xfdfc0,0xfe040,0xfe03f,0xfdfbf,0x105fc0,0x106040,0x10603f,0x105fbf,0x301fc1,0x302041,0x2fe041,0x2fdfc1,0x11020c0,0x11020bf,0x10fe0c0,0x10fe0bf,0x306041,0x305fc1,0x3101f40,0x3101f3f,0x30fdf40,0x30fdf3f,0x701fbe,0x70203e,0x11060c0,0x11060bf,0x6fe03e,0x6fdfbe,0x13020c1,0x12fe0c1,0x3105f40,0x3105f3f,0x180f9fc0,0x180fa040,0x180fa03f,0x180f9fbf,0x3301f41,0x32fdf41,0x705fbe,0x70603e,0x93060c1,0xb305f41,0x17020be,0x16fe0be,0x182fa041,0x182f9fc1,0x192fa0c0,0x190fa0bf,0x3701f3e,0x36fdf3e,0x1b0f9f3f,0x1b2f9f40,0x97060be,0x970a03f,0x930a040,0xb309fc0,0xb709fbf,0xb705f3e,0x1b6f9fbe,0x196fa03e,
+	15,0x101fc0,0x101fbf,0x10203f,0xfe040,0xfdfc0,0xfdfbf,0xfe03f,0x102041,0x101fc1,0x105fc0,0x106040,0x10603f,0x105fbf,0xfdfc1,0xfe041,0x11020c0,0x106041,0x105fc1,0x11020bf,0x10fe0c0,0x10fe0bf,0x3101f40,0x3101f3f,0x30fdf40,0x30fdf3f,0x11020c1,0x11060c0,0x11060bf,0x10fe0c1,0x3101f41,0x3105f40,0x3105f3f,0x701fbe,0x70203e,0x180fa040,0x180f9fc0,0x30fdf41,0x180f9fbf,0x180fa03f,0x186fe03e,0x186fdfbe,0x93060c1,0xb305f41,0x705fbe,0x70603e,0x180fa041,0x180f9fc1,0x192fa0c0,0x190fa0bf,0x97020be,0x196fe0be,0xb701f3e,0x36fdf3e,0x1b2f9f40,0x1b6f9f3f,0xb301fc2,0x9302042,0x192fe042,0x1b2fdfc2,0xb309fc0,0x930a040,0x970a03f,0xb709fbf,
+	15,0x101fc0,0xfdfc0,0xfe040,0x10203f,0x101fbf,0xfdfbf,0xfe03f,0x102041,0x101fc1,0xfdfc1,0xfe041,0x106040,0x105fc0,0x105fbf,0x10603f,0x106041,0x105fc1,0x11020c0,0x10fe0c0,0x11020bf,0x10fe0bf,0x3101f40,0x30fdf40,0x11020c1,0x10fe0c1,0x11060c0,0x3101f3f,0x30fdf3f,0x3101f41,0x30fdf41,0x3105f40,0x11060bf,0x91060c1,0x180fa040,0x180f9fc0,0x180f9fbf,0x3105f3f,0xb105f41,0x180fa03f,0x180fa041,0x180f9fc1,0x3701fbe,0x70203e,0x186fe03e,0x1b6fdfbe,0x3705fbe,0x70603e,0x1302042,0x3301fc2,0x1b2fdfc2,0x192fe042,0x190fa0c0,0x196fa0bf,0x192fa0c1,0x1b2f9f40,0x1b6f9f3f,0xb309fc0,0x930a040,0x9306042,0xb305fc2,0xb709fbf,0x970a03f,0x117020be,
+	11,0x10203f,0x101fc0,0x101fbf,0xfe03f,0xfe040,0xfdfc0,0xfdfbf,0x10603f,0x106040,0x105fc0,0x105fbf,0x11020bf,0x11020c0,0x10fe0c0,0x10fe0bf,0x302041,0x301fc1,0x2fe041,0x2fdfc1,0x11060c0,0x11060bf,0x70203e,0x701fbe,0x6fe03e,0x6fdfbe,0x3101f3f,0x3101f40,0x306041,0x305fc1,0x30fdf40,0x30fdf3f,0x13020c1,0x12fe0c1,0x70603e,0x705fbe,0x180fa03f,0x180fa040,0x180f9fc0,0x180f9fbf,0x17020be,0x16fe0be,0x3105f3f,0x3105f40,0x93060c1,0x97060be,0x3301f41,0x32fdf41,0x190fa0c0,0x190fa0bf,0x192fa041,0x182f9fc1,0x3701f3e,0x36fdf3e,0x186f9fbe,0x196fa03e,0xb305f41,0xb309fc0,0x930a040,0x970a03f,0xb709fbf,0xb705f3e,0x1b6f9f3f,0x1b2f9f40,
+	11,0x10203f,0x101fc0,0x101fbf,0xfe040,0xfe03f,0xfdfc0,0xfdfbf,0x106040,0x10603f,0x105fc0,0x105fbf,0x302041,0x11020c0,0x11020bf,0x301fc1,0x2fe041,0x10fe0c0,0x10fe0bf,0x2fdfc1,0x306041,0x11060c0,0x11060bf,0x305fc1,0x13020c1,0x12fe0c1,0x70203e,0x701fbe,0x3101f3f,0x3101f40,0x30fdf40,0x30fdf3f,0x6fdfbe,0x6fe03e,0x180fa03f,0x180fa040,0x180f9fc0,0x180f9fbf,0x93060c1,0x70603e,0x705fbe,0x3105f3f,0x3105f40,0x3301f41,0x32fdf41,0x17020be,0x16fe0be,0x190fa0bf,0x190fa0c0,0x182fa041,0x182f9fc1,0xb305f41,0x97060be,0x970a03f,0x930a040,0xb309fc0,0xb709fbf,0xb701f3e,0x36fdf3e,0x1b0f9f3f,0x1b2f9f40,0x192fa0c1,0x196fa03e,0x1b6f9fbe,
+	15,0x101fc0,0x10203f,0xfe040,0xfdfc0,0x101fbf,0xfe03f,0xfdfbf,0x102041,0x106040,0x105fc0,0x101fc1,0xfe041,0xfdfc1,0x10603f,0x105fbf,0x11020c0,0x11020bf,0x10fe0c0,0x10fe0bf,0x106041,0x105fc1,0x11020c1,0x11060c0,0x11060bf,0x10fe0c1,0x3101f40,0x30fdf40,0x3101f3f,0x30fdf3f,0x93060c1,0x70203e,0x701fbe,0x180fa040,0x1b0f9fc0,0x180fa03f,0x186fe03e,0x6fdfbe,0x1b6f9fbf,0x3101f41,0x3105f40,0x3105f3f,0x30fdf41,0x1b0f9fc1,0x180fa041,0x70603e,0x705fbe,0x17020be,0x16fe0be,0x190fa0c0,0x196fa0bf,0xb305f41,0xb309fc0,0x930a040,0x970a03f,0x97060be,0x9302042,0xb301fc2,0x192fe042,0x192fa0c1,0x1b2fdfc2,0xb709fbf,0xb701f3e,0x1b6fdf3e,
+	14,0x101fc0,0xfe040,0xfdfc0,0x10203f,0x101fbf,0xfe03f,0xfdfbf,0x102041,0x101fc1,0xfe041,0xfdfc1,0x106040,0x105fc0,0x10603f,0x11020c0,0x105fbf,0x10fe0c0,0x106041,0x105fc1,0x11020bf,0x10fe0bf,0x11020c1,0x10fe0c1,0x11060c0,0x11060bf,0x91060c1,0x3101f40,0x30fdf40,0x3101f3f,0x30fdf3f,0x3101f41,0x30fdf41,0x1b0f9fc0,0x180fa040,0x180fa03f,0x1b0f9fbf,0x3105f40,0xb105f3f,0x3701fbe,0x70203e,0x186fe03e,0x180fa041,0x1b0f9fc1,0x1b6fdfbe,0xb105f41,0x3301fc2,0x302042,0x190fa0c0,0x190fa0bf,0x182fe042,0x1b2fdfc2,0x70603e,0xb705fbe,0x97020be,0x196fe0be,0x190fa0c1,0x930a040,0xb309fc0,0x8306042,0xb305fc2,0x93020c2,0x192fe0c2,0xa70a03f,
+	15,0x10203f,0x101fbf,0x101fc0,0xfe040,0xfe03f,0xfdfbf,0xfdfc0,0x1020c0,0x1020bf,0x10603f,0x106040,0x105fc0,0x105fbf,0xfe0bf,0xfe0c0,0x302041,0x1060c0,0x1060bf,0x301fc1,0x2fe041,0x2fdfc1,0x70203e,0x701fbe,0x6fe03e,0x6fdfbe,0x3020c1,0x306041,0x305fc1,0x2fe0c1,0x7020be,0x70603e,0x705fbe,0x3101f3f,0x3101f40,0x180fa040,0x180fa03f,0x6fe0be,0x180f9fbf,0x180f9fc0,0x1b0fdf40,0x1b0fdf3f,0x93060c1,0x97060be,0x3105f3f,0x3105f40,0x180fa0c0,0x180fa0bf,0x192fa041,0x182f9fc1,0xb301f41,0x1b2fdf41,0xb701f3e,0x36fdf3e,0x196fa03e,0x1b6f9fbe,0x970213f,0x9302140,0x192fe140,0x196fe13f,0x970a03f,0x930a040,0xb309fc0,0xb709fbf,
+	15,0x10203f,0x101fc0,0xfe040,0xfe03f,0x101fbf,0xfdfc0,0xfdfbf,0x1020c0,0x106040,0x10603f,0x1020bf,0xfe0c0,0xfe0bf,0x105fc0,0x105fbf,0x302041,0x301fc1,0x2fe041,0x2fdfc1,0x1060c0,0x1060bf,0x3020c1,0x306041,0x305fc1,0x2fe0c1,0x70203e,0x6fe03e,0x701fbe,0x6fdfbe,0x93060c1,0x3101f40,0x3101f3f,0x180fa040,0x186fa03f,0x180f9fc0,0x1b0fdf40,0x30fdf3f,0x1b6f9fbf,0x7020be,0x70603e,0x705fbe,0x6fe0be,0x186fa0bf,0x180fa0c0,0x3105f40,0x3105f3f,0x3301f41,0x32fdf41,0x182fa041,0x1b2f9fc1,0x97060be,0x970a03f,0x930a040,0xb309fc0,0xb305f41,0x9302140,0x970213f,0x192fe140,0x192fa0c1,0x196fe13f,0xb709fbf,0xb701f3e,0x1b6fdf3e,
+	16,0x10203f,0x101fc0,0xfe040,0xfe03f,0x101fbf,0xfdfc0,0xfdfbf,0x102041,0x1020c0,0x106040,0x10603f,0x1020bf,0xfe0c0,0xfe041,0x101fc1,0x105fc0,0x105fbf,0xfe0bf,0xfdfc1,0x1020c1,0x106041,0x1060c0,0x1060bf,0xfe0c1,0x105fc1,0x93060c1,0x70203e,0x3101f40,0x180fa040,0x180fa03f,0x186fe03e,0x701fbe,0x3701f3f,0x30fdf40,0x1b0f9fc0,0x180f9fbf,0x186fdfbe,0x1b6fdf3f,0x3101f41,0x3105f40,0xb105f3f,0x70603e,0x7020be,0x6fe0be,0x180fa0c0,0x180fa041,0x182f9fc1,0x1b2fdf41,0xb705fbe,0x186fa0bf,0x192fa0c1,0x97060be,0xb305f41,0x9302042,0x192fe042,0x13301fc2,0x930a040,0x970a03f,0xb509fc0,0x9302140,0x970213f,0x192fe140,0x196fe13f,
+	15,0x101fc0,0xfe040,0xfdfc0,0x10203f,0x101fbf,0xfe03f,0x102041,0x101fc1,0xfdfbf,0xfe041,0x1020c0,0x106040,0xfdfc1,0x105fc0,0xfe0c0,0x1020bf,0x10603f,0x105fbf,0xfe0bf,0x1020c1,0x106041,0x105fc1,0xfe0c1,0x1060c0,0x11060bf,0x91060c1,0x3101f40,0x180fa040,0x180f9fc0,0x1b0fdf40,0x3101f3f,0x30fdf3f,0x180fa03f,0x1b0f9fbf,0x180fa041,0x180f9fc1,0x3101f41,0x1b0fdf41,0x70203e,0x3701fbe,0x186fe03e,0x1b6fdfbe,0x3105f40,0xb105f3f,0x180fa0c0,0x190fa0bf,0x192fa0c1,0x302042,0x3301fc2,0xb305f41,0x182fe042,0x1b2fdfc2,0x17020be,0x170603e,0xb705fbe,0x196fe0be,0x9502140,0x194fe140,0x193020c2,0xa306042,0x930a040,0xb309fc0,0xa70a03f,
+	15,0x10203f,0xfe03f,0xfe040,0x101fc0,0x101fbf,0xfdfbf,0xfdfc0,0x1020c0,0x1020bf,0xfe0bf,0xfe0c0,0x106040,0x10603f,0x105fbf,0x105fc0,0x1060c0,0x1060bf,0x302041,0x2fe041,0x301fc1,0x2fdfc1,0x70203e,0x6fe03e,0x3020c1,0x2fe0c1,0x306041,0x701fbe,0x6fdfbe,0x7020be,0x6fe0be,0x70603e,0x305fc1,0x83060c1,0x180fa040,0x180fa03f,0x180f9fbf,0x705fbe,0x87060be,0x180f9fc0,0x180fa0c0,0x180fa0bf,0x3701f3f,0x3101f40,0x1b0fdf40,0x1b6fdf3f,0x3705f3f,0x3105f40,0x1302140,0x170213f,0x196fe13f,0x192fe140,0x182fa041,0x1b2f9fc1,0x192fa0c1,0x196fa03e,0x1b6f9fbe,0x970a03f,0x930a040,0x9306140,0x970613f,0xb709fbf,0xb309fc0,0x13301f41,
+	14,0x10203f,0xfe040,0xfe03f,0x101fc0,0x101fbf,0xfdfc0,0xfdfbf,0x1020c0,0x1020bf,0xfe0c0,0xfe0bf,0x106040,0x10603f,0x105fc0,0x302041,0x105fbf,0x2fe041,0x1060c0,0x1060bf,0x301fc1,0x2fdfc1,0x3020c1,0x2fe0c1,0x306041,0x305fc1,0x83060c1,0x70203e,0x6fe03e,0x701fbe,0x6fdfbe,0x7020be,0x6fe0be,0x186fa03f,0x180fa040,0x180f9fc0,0x186f9fbf,0x70603e,0x8705fbe,0x3701f3f,0x3101f40,0x1b0fdf40,0x180fa0c0,0x186fa0bf,0x1b6fdf3f,0x87060be,0x170213f,0x1102140,0x182fa041,0x182f9fc1,0x190fe140,0x196fe13f,0x3105f40,0xb705f3f,0xb301f41,0x1b2fdf41,0x182fa0c1,0x930a040,0x970a03f,0x9106140,0x970613f,0x9302141,0x192fe141,0xb509fc0,
+	15,0x10203f,0xfe040,0xfe03f,0x101fc0,0x101fbf,0xfdfc0,0x1020c0,0x1020bf,0xfdfbf,0xfe0c0,0x102041,0x106040,0xfe0bf,0x10603f,0xfe041,0x101fc1,0x105fc0,0x105fbf,0xfdfc1,0x1020c1,0x1060c0,0x1060bf,0xfe0c1,0x106041,0x305fc1,0x83060c1,0x70203e,0x180fa040,0x180fa03f,0x186fe03e,0x701fbe,0x6fdfbe,0x180f9fc0,0x186f9fbf,0x180fa0c0,0x180fa0bf,0x7020be,0x186fe0be,0x3101f40,0x3701f3f,0x1b0fdf40,0x1b6fdf3f,0x70603e,0x8705fbe,0x180fa041,0x182f9fc1,0x192fa0c1,0x1102140,0x170213f,0x97060be,0x190fe140,0x196fe13f,0x3301f41,0x3305f40,0xb705f3f,0x1b2fdf41,0xa302042,0x1a2fe042,0x19302141,0x9506140,0x930a040,0x970a03f,0xb509fc0,
+	17,0xfe040,0x10203f,0x101fc0,0xfdfc0,0xfe03f,0x1020c0,0x102041,0x101fbf,0xfe041,0xfe0c0,0x106040,0xfdfbf,0x1020bf,0x101fc1,0xfdfc1,0xfe0bf,0x1020c1,0x10603f,0x105fc0,0xfe0c1,0x1060c0,0x106041,0x8105fbf,0x81060bf,0x8105fc1,0x81060c1,0x180fa040,0x180f9fc0,0x180fa03f,0x180fa0c0,0x180fa041,0x180f9fbf,0x70203e,0x186fe03e,0x3101f40,0x1b0fdf40,0x180f9fc1,0x180fa0bf,0x701fbe,0x3701f3f,0x1b0fdf3f,0x1b6fdfbe,0x7020be,0x186fe0be,0x192fa0c1,0x9102140,0x190fe140,0x8302042,0x3101f41,0x1b0fdf41,0x182fe042,0xb301fc2,0xb305f40,0x870603e,0x970213f,0x196fe13f,0x11102141,0x113020c2,0x1b2fdfc2,0xb105f3f,0xb705fbe,0x97060be,0xa50a040,
+	11,0x10203f,0x101fc0,0x101fbf,0xfdfbf,0xfe03f,0xfe040,0xfdfc0,0x105fc0,0x106040,0x10603f,0x105fbf,0x11020bf,0x11020c0,0x302041,0x301fc1,0x2fdfc1,0x2fe041,0x10fe0c0,0x10fe0bf,0x70203e,0x701fbe,0x3101f3f,0x3101f40,0x305fc1,0x306041,0x11060c0,0x11060bf,0x6fe03e,0x6fdfbe,0x30fdf3f,0x30fdf40,0x3105f40,0x3105f3f,0x705fbe,0x70603e,0x13020c1,0x12fe0c1,0x180fa040,0x180fa03f,0x180f9fbf,0x180f9fc0,0x3301f41,0x17020be,0x16fe0be,0x93060c1,0x32fdf41,0xb305f41,0x3701f3e,0x36fdf3e,0x97060be,0x970a03f,0x930a040,0xb309fc0,0xb709fbf,0xb705f3e,0x182f9fc1,0x182fa041,0x192fa0c0,0x190fa0bf,0x196fa03e,0x186f9fbe,0x1b6f9f3f,0x1b2f9f40,
+	11,0x101fc0,0x10203f,0x101fbf,0xfdfc0,0xfe040,0xfe03f,0xfdfbf,0x105fc0,0x106040,0x10603f,0x105fbf,0x301fc1,0x302041,0x2fe041,0x2fdfc1,0x11020c0,0x11020bf,0x306041,0x305fc1,0x10fe0c0,0x10fe0bf,0x3101f40,0x3101f3f,0x11060c0,0x11060bf,0x70203e,0x30fdf40,0x30fdf3f,0x701fbe,0x3105f40,0x3105f3f,0x13020c1,0x6fe03e,0x6fdfbe,0x705fbe,0x70603e,0x12fe0c1,0x3301f41,0x13060c1,0x32fdf41,0x1b0f9fc0,0x180fa040,0x186fa03f,0x1b6f9fbf,0x3305f41,0xb109fc0,0x17020be,0x16fe0be,0x810a040,0x870a03f,0xb709fbf,0x3701f3e,0x1b6fdf3e,0x17060be,0x182fa041,0x1b2f9fc1,0x192fa0c0,0x196fa0bf,0xb705f3e,0xb309fc1,0x830a041,0x930a0c0,0x970a0bf,
+	15,0x101fc0,0x101fbf,0x10203f,0xfe040,0xfdfc0,0xfdfbf,0xfe03f,0x106040,0x105fc0,0x105fbf,0x10603f,0x102041,0x101fc1,0xfdfc1,0xfe041,0x106041,0x105fc1,0x11020c0,0x11020bf,0x10fe0c0,0x10fe0bf,0x3101f40,0x3101f3f,0x11060c0,0x11060bf,0x11020c1,0x30fdf40,0x30fdf3f,0x3105f40,0x3105f3f,0x3101f41,0x10fe0c1,0x13060c1,0x70203e,0x701fbe,0x6fdfbe,0x30fdf41,0x3305f41,0x6fe03e,0x70603e,0x705fbe,0x1b0f9fc0,0x180fa040,0x186fa03f,0x1b6f9fbf,0x1b0f9fc1,0x180fa041,0x910a040,0xb109fc0,0xb709fbf,0x970a03f,0x17020be,0x196fe0be,0x97060be,0xb701f3e,0x1b6fdf3e,0xb301fc2,0x9302042,0x930a041,0xb309fc1,0x1b2fdfc2,0x192fe042,0x194fa0c0,
+	17,0x101fc0,0x101fbf,0x10203f,0xfe040,0xfdfc0,0x101fc1,0x102041,0x106040,0x105fc0,0xfdfbf,0xfe03f,0x10603f,0x105fbf,0xfdfc1,0xfe041,0x106041,0x105fc1,0x11020c0,0x11020bf,0x10fe0c0,0x11020c1,0x11060c0,0x3101f40,0x3101f3f,0x30fdf40,0x10fe0bf,0x11060bf,0x10fe0c1,0x3101f41,0x3105f40,0x30fdf3f,0x11060c1,0x3105f3f,0x30fdf41,0x3105f41,0x3701fbe,0x70203e,0x180fa040,0x1b0f9fc0,0x1b0f9fbf,0x180fa03f,0x186fe03e,0x1b6fdfbe,0x3705fbe,0x70603e,0x910a040,0xb109fc0,0x3301fc2,0x1302042,0x180fa041,0x1b0f9fc1,0x1b2fdfc2,0x192fe042,0x1306042,0x3305fc2,0xb709fbf,0x970a03f,0x930a041,0xb309fc1,0x97020be,0x192fa0c0,0x190fa0bf,0x196fe0be,
+	11,0x10203f,0x101fc0,0x101fbf,0xfe03f,0xfe040,0xfdfc0,0xfdfbf,0x10603f,0x106040,0x105fc0,0x105fbf,0x11020bf,0x11020c0,0x10fe0c0,0x10fe0bf,0x302041,0x301fc1,0x11060c0,0x11060bf,0x2fe041,0x2fdfc1,0x70203e,0x701fbe,0x306041,0x305fc1,0x3101f40,0x6fe03e,0x6fdfbe,0x3101f3f,0x70603e,0x705fbe,0x13020c1,0x30fdf40,0x30fdf3f,0x3105f3f,0x3105f40,0x12fe0c1,0x17020be,0x13060c1,0x16fe0be,0x186fa03f,0x180fa040,0x1b0f9fc0,0x1b6f9fbf,0x17060be,0x870a03f,0x3301f41,0x32fdf41,0x810a040,0xb109fc0,0xb709fbf,0x3701f3e,0x1b6fdf3e,0x3305f41,0x190fa0c0,0x196fa0bf,0x192fa041,0x1b2f9fc1,0xb705f3e,0x970a0bf,0x910a0c0,0x930a041,0xb309fc1,
+	11,0x10203f,0x101fc0,0x101fbf,0xfe040,0xfe03f,0xfdfc0,0xfdfbf,0x106040,0x10603f,0x105fc0,0x105fbf,0x302041,0x11020c0,0x11020bf,0x301fc1,0x2fe041,0x10fe0c0,0x10fe0bf,0x2fdfc1,0x306041,0x11060c0,0x11060bf,0x305fc1,0x13020c1,0x12fe0c1,0x70203e,0x701fbe,0x3101f3f,0x3101f40,0x30fdf40,0x30fdf3f,0x6fdfbe,0x6fe03e,0x70603e,0x13060c1,0x3105f40,0x3105f3f,0x705fbe,0x17020be,0x180fa040,0x186fa03f,0x1b0f9fc0,0x1b6f9fbf,0x3301f41,0x32fdf41,0x3305f41,0x16fe0be,0x17060be,0x870a03f,0x810a040,0xb109fc0,0xb709fbf,0x3701f3e,0x182fa041,0x192fa0c0,0x196fa0bf,0x1b2f9fc1,0x1b6fdf3e,0xb705f3e,0x830a041,0x930a0c0,0x970a0bf,0xb309fc1,
+	14,0x101fc0,0x10203f,0x101fbf,0xfe040,0xfdfc0,0xfe03f,0xfdfbf,0x106040,0x105fc0,0x10603f,0x105fbf,0x102041,0x101fc1,0xfe041,0x11020c0,0xfdfc1,0x11020bf,0x106041,0x105fc1,0x10fe0c0,0x10fe0bf,0x11060c0,0x11060bf,0x11020c1,0x10fe0c1,0x13060c1,0x3101f40,0x3101f3f,0x30fdf40,0x30fdf3f,0x3105f40,0x3105f3f,0x3701fbe,0x70203e,0x6fe03e,0x36fdfbe,0x3101f41,0x32fdf41,0x1b0f9fc0,0x180fa040,0x186fa03f,0x70603e,0x3705fbe,0x1b6f9fbf,0x3305f41,0xb109fc0,0x810a040,0x17020be,0x16fe0be,0x870a03f,0xb709fbf,0x180fa041,0x1b2f9fc1,0x192fa0c0,0x196fa0bf,0x17060be,0x9302042,0xb301fc2,0x830a041,0xb309fc1,0x930a0c0,0x970a0bf,0x1a2fe042,
+	17,0x101fc0,0x10203f,0xfe040,0xfdfc0,0x101fbf,0x106040,0x102041,0x101fc1,0x105fc0,0xfe03f,0xfdfbf,0x10603f,0x105fbf,0xfe041,0xfdfc1,0x106041,0x105fc1,0x11020c0,0x11020bf,0x10fe0c0,0x11020c1,0x11060c0,0x10fe0bf,0x11060bf,0x10fe0c1,0x11060c1,0x3101f40,0x30fdf40,0x3101f3f,0x3105f40,0x3101f41,0x30fdf3f,0x3105f3f,0x30fdf41,0x3105f41,0x70203e,0x3701fbe,0x180fa040,0x1b0f9fc0,0x180fa03f,0x186fe03e,0x36fdfbe,0x1b6f9fbf,0x180fa041,0x1b0f9fc1,0x1302042,0x3301fc2,0x910a040,0x70603e,0x3705fbe,0xb109fc0,0x970a03f,0xb709fbf,0x910a041,0x192fe042,0x1b2fdfc2,0x9306042,0x3305fc2,0xb309fc1,0x97020be,0x192fa0c0,0x190fa0bf,0x196fe0be,
+	15,0x10203f,0x101fbf,0x101fc0,0xfe040,0xfe03f,0xfdfbf,0xfdfc0,0x106040,0x10603f,0x105fbf,0x105fc0,0x1020c0,0x1020bf,0xfe0bf,0xfe0c0,0x1060c0,0x1060bf,0x302041,0x301fc1,0x2fe041,0x2fdfc1,0x70203e,0x701fbe,0x306041,0x305fc1,0x3020c1,0x6fe03e,0x6fdfbe,0x70603e,0x705fbe,0x7020be,0x2fe0c1,0x13060c1,0x3101f40,0x3101f3f,0x30fdf3f,0x6fe0be,0x17060be,0x30fdf40,0x3105f40,0x3105f3f,0x186fa03f,0x180fa040,0x1b0f9fc0,0x1b6f9fbf,0x186fa0bf,0x180fa0c0,0x830a040,0x870a03f,0xb709fbf,0xb309fc0,0x3301f41,0x1b2fdf41,0xb305f41,0xb701f3e,0x1b6fdf3e,0x970213f,0x9302140,0x930a0c0,0x970a0bf,0x196fe13f,0x192fe140,0x1a2fa041,
+	14,0x10203f,0x101fc0,0x101fbf,0xfe040,0xfe03f,0xfdfc0,0xfdfbf,0x106040,0x10603f,0x105fc0,0x105fbf,0x1020c0,0x1020bf,0xfe0c0,0x302041,0xfe0bf,0x301fc1,0x1060c0,0x1060bf,0x2fe041,0x2fdfc1,0x306041,0x305fc1,0x3020c1,0x2fe0c1,0x13060c1,0x70203e,0x701fbe,0x6fe03e,0x6fdfbe,0x70603e,0x705fbe,0x3701f3f,0x3101f40,0x30fdf40,0x36fdf3f,0x7020be,0x16fe0be,0x186fa03f,0x180fa040,0x1b0f9fc0,0x3105f40,0x3705f3f,0x1b6f9fbf,0x17060be,0x870a03f,0x810a040,0x3301f41,0x32fdf41,0xb109fc0,0xb709fbf,0x180fa0c0,0x196fa0bf,0x192fa041,0x1b2f9fc1,0x3305f41,0x9302140,0x970213f,0x910a0c0,0x970a0bf,0x930a041,0xb309fc1,0x194fe140,
+	15,0x10203f,0x101fc0,0x101fbf,0xfe040,0xfe03f,0xfdfc0,0x106040,0x10603f,0xfdfbf,0x105fc0,0x102041,0x1020c0,0x105fbf,0x1020bf,0x101fc1,0xfe041,0xfe0c0,0xfe0bf,0xfdfc1,0x106041,0x1060c0,0x1060bf,0x105fc1,0x1020c1,0x2fe0c1,0x13060c1,0x70203e,0x3101f40,0x3101f3f,0x3701fbe,0x6fe03e,0x6fdfbe,0x30fdf40,0x36fdf3f,0x3105f40,0x3105f3f,0x70603e,0x3705fbe,0x180fa040,0x186fa03f,0x1b0f9fc0,0x1b6f9fbf,0x7020be,0x16fe0be,0x3101f41,0x32fdf41,0xb305f41,0x810a040,0x870a03f,0x97060be,0xb109fc0,0xb709fbf,0x182fa041,0x182fa0c0,0x196fa0bf,0x1b2f9fc1,0x11302042,0x13301fc2,0xb30a041,0x950a0c0,0x9302140,0x970213f,0x194fe140,
+	17,0x101fc0,0x10203f,0xfe040,0xfdfc0,0x101fbf,0x106040,0x102041,0xfe03f,0x101fc1,0x105fc0,0x1020c0,0xfdfbf,0x10603f,0xfe041,0xfdfc1,0x105fbf,0x106041,0x1020bf,0xfe0c0,0x105fc1,0x1060c0,0x1020c1,0x10fe0bf,0x11060bf,0x10fe0c1,0x11060c1,0x3101f40,0x30fdf40,0x3101f3f,0x3105f40,0x3101f41,0x30fdf3f,0x70203e,0x3701fbe,0x180fa040,0x1b0f9fc0,0x30fdf41,0x3105f3f,0x6fe03e,0x186fa03f,0x1b0f9fbf,0x1b6fdfbe,0x70603e,0x3705fbe,0xb305f41,0x910a040,0xb109fc0,0x1302042,0x180fa041,0x1b0f9fc1,0x3301fc2,0x192fe042,0x192fa0c0,0x17020be,0x970a03f,0xb709fbf,0xa10a041,0xa306042,0x1b2fdfc2,0x190fa0bf,0x196fe0be,0x97060be,0x11502140,
+	17,0x10203f,0x101fbf,0x101fc0,0xfe040,0xfe03f,0x1020bf,0x1020c0,0x106040,0x10603f,0xfdfbf,0xfdfc0,0x105fc0,0x105fbf,0xfe0bf,0xfe0c0,0x1060c0,0x1060bf,0x302041,0x301fc1,0x2fe041,0x3020c1,0x306041,0x70203e,0x701fbe,0x6fe03e,0x2fdfc1,0x305fc1,0x2fe0c1,0x7020be,0x70603e,0x6fdfbe,0x3060c1,0x705fbe,0x6fe0be,0x7060be,0x3701f3f,0x3101f40,0x180fa040,0x186fa03f,0x186f9fbf,0x180f9fc0,0x1b0fdf40,0x1b6fdf3f,0x3705f3f,0x3105f40,0x830a040,0x870a03f,0x170213f,0x1302140,0x180fa0c0,0x186fa0bf,0x196fe13f,0x192fe140,0x1306140,0x170613f,0xb709fbf,0xb309fc0,0x930a0c0,0x970a0bf,0xb301f41,0x192fa041,0x182f9fc1,0x1b2fdf41,
+	17,0x10203f,0x101fc0,0xfe040,0xfe03f,0x101fbf,0x106040,0x1020c0,0x1020bf,0x10603f,0xfdfc0,0xfdfbf,0x105fc0,0x105fbf,0xfe0c0,0xfe0bf,0x1060c0,0x1060bf,0x302041,0x301fc1,0x2fe041,0x3020c1,0x306041,0x2fdfc1,0x305fc1,0x2fe0c1,0x3060c1,0x70203e,0x6fe03e,0x701fbe,0x70603e,0x7020be,0x6fdfbe,0x705fbe,0x6fe0be,0x7060be,0x3101f40,0x3701f3f,0x180fa040,0x186fa03f,0x180f9fc0,0x1b0fdf40,0x36fdf3f,0x1b6f9fbf,0x180fa0c0,0x186fa0bf,0x1302140,0x170213f,0x830a040,0x3105f40,0x3705f3f,0x870a03f,0xb309fc0,0xb709fbf,0x830a0c0,0x192fe140,0x196fe13f,0x9306140,0x170613f,0x970a0bf,0xb301f41,0x192fa041,0x182f9fc1,0x1b2fdf41,
+	17,0x10203f,0x101fc0,0xfe040,0xfe03f,0x101fbf,0x106040,0x1020c0,0xfdfc0,0x1020bf,0x10603f,0x102041,0xfdfbf,0x105fc0,0xfe0c0,0xfe0bf,0x105fbf,0x1060c0,0x101fc1,0xfe041,0x1060bf,0x106041,0x1020c1,0x2fdfc1,0x305fc1,0x2fe0c1,0x3060c1,0x70203e,0x6fe03e,0x701fbe,0x70603e,0x7020be,0x6fdfbe,0x3101f40,0x3701f3f,0x180fa040,0x186fa03f,0x6fe0be,0x705fbe,0x30fdf40,0x1b0f9fc0,0x186f9fbf,0x1b6fdf3f,0x3105f40,0x3705f3f,0x97060be,0x830a040,0x870a03f,0x1302140,0x180fa0c0,0x186fa0bf,0x170213f,0x192fe140,0x192fa041,0x3301f41,0xb309fc0,0xb709fbf,0x850a0c0,0x9506140,0x196fe13f,0x182f9fc1,0x1b2fdf41,0xb305f41,0x12302042,
+	16,0x10203f,0x101fc0,0xfe040,0x102041,0x1020c0,0x106040,0x101fbf,0xfe03f,0xfdfc0,0x101fc1,0x105fc0,0x10603f,0x1020bf,0xfe0c0,0xfe041,0xfdfbf,0x1020c1,0x106041,0x1060c0,0x105fbf,0xfe0bf,0xfdfc1,0x105fc1,0x1060bf,0xfe0c1,0x83060c1,0x70203e,0x3101f40,0x180fa040,0x180fa03f,0x186fe03e,0x701fbe,0x3701f3f,0x30fdf40,0x1b0f9fc0,0x180fa041,0x180fa0c0,0x7020be,0x70603e,0x3105f40,0xb101f41,0x9302042,0x1102140,0x930a040,0x6fdfbe,0x36fdf3f,0x1b6f9fbf,0x190fa0bf,0x196fe0be,0x170213f,0x196fe140,0x182f9fc1,0x1b2fdf41,0xb301fc2,0x1a2fe042,0x192fa0c1,0x8705fbe,0xb705f3f,0xb309fc0,0xa70a03f,0x97060be,0x9706140,0x11302141
+};
diff -ru --new-file blender-2.76b.old/extern/voro++/src/v_compute.cc blender-2.76b/extern/voro++/src/v_compute.cc
--- blender-2.76b.old/extern/voro++/src/v_compute.cc	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/v_compute.cc	2016-01-27 19:10:58.914006407 +0300
@@ -0,0 +1,1006 @@
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \file v_compute.cc
+ * \brief Function implementantions for the voro_compute template. */
+
+#include "worklist.hh"
+#include "v_compute.hh"
+#include "rad_option.hh"
+#include "container.hh"
+#include "container_prd.hh"
+
+namespace voro {
+
+/** The class constructor initializes constants from the container class, and
+ * sets up the mask and queue used for Voronoi computations.
+ * \param[in] con_ a reference to the container class to use.
+ * \param[in] (hx_,hy_,hz_) the size of the mask to use. */
+template<class c_class>
+voro_compute<c_class>::voro_compute(c_class &con_,int hx_,int hy_,int hz_) :
+	con(con_), boxx(con_.boxx), boxy(con_.boxy), boxz(con_.boxz),
+	xsp(con_.xsp), ysp(con_.ysp), zsp(con_.zsp),
+	hx(hx_), hy(hy_), hz(hz_), hxy(hx_*hy_), hxyz(hxy*hz_), ps(con_.ps),
+	id(con_.id), p(con_.p), co(con_.co), bxsq(boxx*boxx+boxy*boxy+boxz*boxz),
+	mv(0), qu_size(3*(3+hxy+hz*(hx+hy))), wl(con_.wl), mrad(con_.mrad),
+	mask(new unsigned int[hxyz]), qu(new int[qu_size]), qu_l(qu+qu_size) {
+	reset_mask();
+}
+
+/** Scans all of the particles within a block to see if any of them have a
+ * smaller distance to the given test vector. If one is found, the routine
+ * updates the minimum distance and store information about this particle.
+ * \param[in] ijk the index of the block.
+ * \param[in] (x,y,z) the test vector to consider (which may have already had a
+ *                    periodic displacement applied to it).
+ * \param[in] (di,dj,dk) the coordinates of the current block, to store if the
+ *			 particle record is updated.
+ * \param[in,out] w a reference to a particle record in which to store
+ *		    information about the particle whose Voronoi cell the
+ *		    vector is within.
+ * \param[in,out] mrs the current minimum distance, that may be updated if a
+ * 		      closer particle is found. */
+template<class c_class>
+inline void voro_compute<c_class>::scan_all(int ijk,double x,double y,double z,int di,int dj,int dk,particle_record &w,double &mrs) {
+	double x1,y1,z1,rs;bool in_block=false;
+	for(int l=0;l<co[ijk];l++) {
+		x1=p[ijk][ps*l]-x;
+		y1=p[ijk][ps*l+1]-y;
+		z1=p[ijk][ps*l+2]-z;
+		rs=con.r_current_sub(x1*x1+y1*y1+z1*z1,ijk,l);
+		if(rs<mrs) {mrs=rs;w.l=l;in_block=true;}
+	}
+	if(in_block) {w.ijk=ijk;w.di=di;w.dj=dj,w.dk=dk;}
+}
+
+/** Finds the Voronoi cell that given vector is within. For containers that are
+ * not radially dependent, this corresponds to findig the particle that is
+ * closest to the vector; for the radical tessellation containers, this
+ * corresponds to a finding the minimum weighted distance.
+ * \param[in] (x,y,z) the vector to consider.
+ * \param[in] (ci,cj,ck) the coordinates of the block that the test particle is
+ *                       in relative to the container data structure.
+ * \param[in] ijk the index of the block that the test particle is in.
+ * \param[out] w a reference to a particle record in which to store information
+ * 		 about the particle whose Voronoi cell the vector is within.
+ * \param[out] mrs the minimum computed distance. */
+template<class c_class>
+void voro_compute<c_class>::find_voronoi_cell(double x,double y,double z,int ci,int cj,int ck,int ijk,particle_record &w,double &mrs) {
+	double qx=0,qy=0,qz=0,rs;
+	int i,j,k,di,dj,dk,ei,ej,ek,f,g,disp;
+	double fx,fy,fz,mxs,mys,mzs,*radp;
+	unsigned int q,*e,*mijk;
+
+	// Init setup for parameters to return
+	w.ijk=-1;mrs=large_number;
+
+	con.initialize_search(ci,cj,ck,ijk,i,j,k,disp);
+
+	// Test all particles in the particle's local region first
+	scan_all(ijk,x,y,z,0,0,0,w,mrs);
+
+	// Now compute the fractional position of the particle within its
+	// region and store it in (fx,fy,fz). We use this to compute an index
+	// (di,dj,dk) of which subregion the particle is within.
+	unsigned int m1,m2;
+	con.frac_pos(x,y,z,ci,cj,ck,fx,fy,fz);
+	di=int(fx*xsp*wl_fgrid);dj=int(fy*ysp*wl_fgrid);dk=int(fz*zsp*wl_fgrid);
+
+	// The indices (di,dj,dk) tell us which worklist to use, to test the
+	// blocks in the optimal order. But we only store worklists for the
+	// eighth of the region where di, dj, and dk are all less than half the
+	// full grid. The rest of the cases are handled by symmetry. In this
+	// section, we detect for these cases, by reflecting high values of di,
+	// dj, and dk. For these cases, a mask is constructed in m1 and m2
+	// which is used to flip the worklist information when it is loaded.
+	if(di>=wl_hgrid) {
+		mxs=boxx-fx;
+		m1=127+(3<<21);m2=1+(1<<21);di=wl_fgrid-1-di;if(di<0) di=0;
+	} else {m1=m2=0;mxs=fx;}
+	if(dj>=wl_hgrid) {
+		mys=boxy-fy;
+		m1|=(127<<7)+(3<<24);m2|=(1<<7)+(1<<24);dj=wl_fgrid-1-dj;if(dj<0) dj=0;
+	} else mys=fy;
+	if(dk>=wl_hgrid) {
+		mzs=boxz-fz;
+		m1|=(127<<14)+(3<<27);m2|=(1<<14)+(1<<27);dk=wl_fgrid-1-dk;if(dk<0) dk=0;
+	} else mzs=fz;
+
+	// Do a quick test to account for the case when the minimum radius is
+	// small enought that no other blocks need to be considered
+	rs=con.r_max_add(mrs);
+	if(mxs*mxs>rs&&mys*mys>rs&&mzs*mzs>rs) return;
+
+	// Now compute which worklist we are going to use, and set radp and e to
+	// point at the right offsets
+	ijk=di+wl_hgrid*(dj+wl_hgrid*dk);
+	radp=mrad+ijk*wl_seq_length;
+	e=(const_cast<unsigned int*> (wl))+ijk*wl_seq_length;
+
+	// Read in how many items in the worklist can be tested without having to
+	// worry about writing to the mask
+	f=e[0];g=0;
+	do {
+
+		// If mrs is less than the minimum distance to any untested
+		// block, then we are done
+		if(con.r_max_add(mrs)<radp[g]) return;
+		g++;
+
+		// Load in a block off the worklist, permute it with the
+		// symmetry mask, and decode its position. These are all
+		// integer bit operations so they should run very fast.
+		q=e[g];q^=m1;q+=m2;
+		di=q&127;di-=64;
+		dj=(q>>7)&127;dj-=64;
+		dk=(q>>14)&127;dk-=64;
+
+		// Check that the worklist position is in range
+		ei=di+i;if(ei<0||ei>=hx) continue;
+		ej=dj+j;if(ej<0||ej>=hy) continue;
+		ek=dk+k;if(ek<0||ek>=hz) continue;
+
+		// Call the compute_min_max_radius() function. This returns
+		// true if the minimum distance to the block is bigger than the
+		// current mrs, in which case we skip this block and move on.
+		// Otherwise, it computes the maximum distance to the block and
+		// returns it in crs.
+		if(compute_min_radius(di,dj,dk,fx,fy,fz,mrs)) continue;
+
+		// Now compute which region we are going to loop over, adding a
+		// displacement for the periodic cases
+		ijk=con.region_index(ci,cj,ck,ei,ej,ek,qx,qy,qz,disp);
+
+		// If mrs is bigger than the maximum distance to the block,
+		// then we have to test all particles in the block for
+		// intersections. Otherwise, we do additional checks and skip
+		// those particles which can't possibly intersect the block.
+		scan_all(ijk,x-qx,y-qy,z-qz,di,dj,dk,w,mrs);
+	} while(g<f);
+
+	// Update mask value and initialize queue
+	mv++;
+	if(mv==0) {reset_mask();mv=1;}
+	int *qu_s=qu,*qu_e=qu;
+
+	while(g<wl_seq_length-1) {
+
+		// If mrs is less than the minimum distance to any untested
+		// block, then we are done
+		if(con.r_max_add(mrs)<radp[g]) return;
+		g++;
+
+		// Load in a block off the worklist, permute it with the
+		// symmetry mask, and decode its position. These are all
+		// integer bit operations so they should run very fast.
+		q=e[g];q^=m1;q+=m2;
+		di=q&127;di-=64;
+		dj=(q>>7)&127;dj-=64;
+		dk=(q>>14)&127;dk-=64;
+
+		// Compute the position in the mask of the current block. If
+		// this lies outside the mask, then skip it. Otherwise, mark
+		// it.
+		ei=di+i;if(ei<0||ei>=hx) continue;
+		ej=dj+j;if(ej<0||ej>=hy) continue;
+		ek=dk+k;if(ek<0||ek>=hz) continue;
+		mijk=mask+ei+hx*(ej+hy*ek);
+		*mijk=mv;
+
+		// Skip this block if it is further away than the current
+		// minimum radius
+		if(compute_min_radius(di,dj,dk,fx,fy,fz,mrs)) continue;
+
+		// Now compute which region we are going to loop over, adding a
+		// displacement for the periodic cases
+		ijk=con.region_index(ci,cj,ck,ei,ej,ek,qx,qy,qz,disp);
+		scan_all(ijk,x-qx,y-qy,z-qz,di,dj,dk,w,mrs);
+
+		if(qu_e>qu_l-18) add_list_memory(qu_s,qu_e);
+		scan_bits_mask_add(q,mijk,ei,ej,ek,qu_e);
+	}
+
+	// Do a check to see if we've reached the radius cutoff
+	if(con.r_max_add(mrs)<radp[g]) return;
+
+	// We were unable to completely compute the cell based on the blocks in
+	// the worklist, so now we have to go block by block, reading in items
+	// off the list
+	while(qu_s!=qu_e) {
+
+		// Read the next entry of the queue
+		if(qu_s==qu_l) qu_s=qu;
+		ei=*(qu_s++);ej=*(qu_s++);ek=*(qu_s++);
+		di=ei-i;dj=ej-j;dk=ek-k;
+		if(compute_min_radius(di,dj,dk,fx,fy,fz,mrs)) continue;
+
+		ijk=con.region_index(ci,cj,ck,ei,ej,ek,qx,qy,qz,disp);
+		scan_all(ijk,x-qx,y-qy,z-qz,di,dj,dk,w,mrs);
+
+		// Test the neighbors of the current block, and add them to the
+		// block list if they haven't already been tested
+		if((qu_s<=qu_e?(qu_l-qu_e)+(qu_s-qu):qu_s-qu_e)<18) add_list_memory(qu_s,qu_e);
+		add_to_mask(ei,ej,ek,qu_e);
+	}
+}
+
+/** Scans the six orthogonal neighbors of a given block and adds them to the
+ * queue if they haven't been considered already. It assumes that the queue
+ * will definitely have enough memory to add six entries at the end.
+ * \param[in] (ei,ej,ek) the block to consider.
+ * \param[in,out] qu_e a pointer to the end of the queue. */
+template<class c_class>
+inline void voro_compute<c_class>::add_to_mask(int ei,int ej,int ek,int *&qu_e) {
+	unsigned int *mijk=mask+ei+hx*(ej+hy*ek);
+	if(ek>0) if(*(mijk-hxy)!=mv) {if(qu_e==qu_l) qu_e=qu;*(mijk-hxy)=mv;*(qu_e++)=ei;*(qu_e++)=ej;*(qu_e++)=ek-1;}
+	if(ej>0) if(*(mijk-hx)!=mv) {if(qu_e==qu_l) qu_e=qu;*(mijk-hx)=mv;*(qu_e++)=ei;*(qu_e++)=ej-1;*(qu_e++)=ek;}
+	if(ei>0) if(*(mijk-1)!=mv) {if(qu_e==qu_l) qu_e=qu;*(mijk-1)=mv;*(qu_e++)=ei-1;*(qu_e++)=ej;*(qu_e++)=ek;}
+	if(ei<hx-1) if(*(mijk+1)!=mv) {if(qu_e==qu_l) qu_e=qu;*(mijk+1)=mv;*(qu_e++)=ei+1;*(qu_e++)=ej;*(qu_e++)=ek;}
+	if(ej<hy-1) if(*(mijk+hx)!=mv) {if(qu_e==qu_l) qu_e=qu;*(mijk+hx)=mv;*(qu_e++)=ei;*(qu_e++)=ej+1;*(qu_e++)=ek;}
+	if(ek<hz-1) if(*(mijk+hxy)!=mv) {if(qu_e==qu_l) qu_e=qu;*(mijk+hxy)=mv;*(qu_e++)=ei;*(qu_e++)=ej;*(qu_e++)=ek+1;}
+}
+
+/** Scans a worklist entry and adds any blocks to the queue
+ * \param[in] (ei,ej,ek) the block to consider.
+ * \param[in,out] qu_e a pointer to the end of the queue. */
+template<class c_class>
+inline void voro_compute<c_class>::scan_bits_mask_add(unsigned int q,unsigned int *mijk,int ei,int ej,int ek,int *&qu_e) {
+	const unsigned int b1=1<<21,b2=1<<22,b3=1<<24,b4=1<<25,b5=1<<27,b6=1<<28;
+	if((q&b2)==b2) {
+		if(ei>0) {*(mijk-1)=mv;*(qu_e++)=ei-1;*(qu_e++)=ej;*(qu_e++)=ek;}
+		if((q&b1)==0&&ei<hx-1) {*(mijk+1)=mv;*(qu_e++)=ei+1;*(qu_e++)=ej;*(qu_e++)=ek;}
+	} else if((q&b1)==b1&&ei<hx-1) {*(mijk+1)=mv;*(qu_e++)=ei+1;*(qu_e++)=ej;*(qu_e++)=ek;}
+	if((q&b4)==b4) {
+		if(ej>0) {*(mijk-hx)=mv;*(qu_e++)=ei;*(qu_e++)=ej-1;*(qu_e++)=ek;}
+		if((q&b3)==0&&ej<hy-1) {*(mijk+hx)=mv;*(qu_e++)=ei;*(qu_e++)=ej+1;*(qu_e++)=ek;}
+	} else if((q&b3)==b3&&ej<hy-1) {*(mijk+hx)=mv;*(qu_e++)=ei;*(qu_e++)=ej+1;*(qu_e++)=ek;}
+	if((q&b6)==b6) {
+		if(ek>0) {*(mijk-hxy)=mv;*(qu_e++)=ei;*(qu_e++)=ej;*(qu_e++)=ek-1;}
+		if((q&b5)==0&&ek<hz-1) {*(mijk+hxy)=mv;*(qu_e++)=ei;*(qu_e++)=ej;*(qu_e++)=ek+1;}
+	} else if((q&b5)==b5&&ek<hz-1) {*(mijk+hxy)=mv;*(qu_e++)=ei;*(qu_e++)=ej;*(qu_e++)=ek+1;}
+}
+
+/** This routine computes a Voronoi cell for a single particle in the
+ * container. It can be called by the user, but is also forms the core part of
+ * several of the main functions, such as store_cell_volumes(), print_all(),
+ * and the drawing routines. The algorithm constructs the cell by testing over
+ * the neighbors of the particle, working outwards until it reaches those
+ * particles which could not possibly intersect the cell. For maximum
+ * efficiency, this algorithm is divided into three parts. In the first
+ * section, the algorithm tests over the blocks which are in the immediate
+ * vicinity of the particle, by making use of one of the precomputed worklists.
+ * The code then continues to test blocks on the worklist, but also begins to
+ * construct a list of neighboring blocks outside the worklist which may need
+ * to be test. In the third section, the routine starts testing these
+ * neighboring blocks, evaluating whether or not a particle in them could
+ * possibly intersect the cell. For blocks that intersect the cell, it tests
+ * the particles in that block, and then adds the block neighbors to the list
+ * of potential places to consider.
+ * \param[in,out] c a reference to a voronoicell object.
+ * \param[in] ijk the index of the block that the test particle is in.
+ * \param[in] s the index of the particle within the test block.
+ * \param[in] (ci,cj,ck) the coordinates of the block that the test particle is
+ *                       in relative to the container data structure.
+ * \return False if the Voronoi cell was completely removed during the
+ *         computation and has zero volume, true otherwise. */
+template<class c_class>
+template<class v_cell>
+bool voro_compute<c_class>::compute_cell(v_cell &c,int ijk,int s,int ci,int cj,int ck) {
+	static const int count_list[8]={7,11,15,19,26,35,45,59},*count_e=count_list+8;
+	double x,y,z,x1,y1,z1,qx=0,qy=0,qz=0;
+	double xlo,ylo,zlo,xhi,yhi,zhi,x2,y2,z2,rs;
+	int i,j,k,di,dj,dk,ei,ej,ek,f,g,l,disp;
+	double fx,fy,fz,gxs,gys,gzs,*radp;
+	unsigned int q,*e,*mijk;
+
+	if(!con.initialize_voronoicell(c,ijk,s,ci,cj,ck,i,j,k,x,y,z,disp)) return false;
+	con.r_init(ijk,s);
+
+	// Initialize the Voronoi cell to fill the entire container
+	double crs,mrs;
+
+	int next_count=3,*count_p=(const_cast<int*> (count_list));
+
+	// Test all particles in the particle's local region first
+	for(l=0;l<s;l++) {
+		x1=p[ijk][ps*l]-x;
+		y1=p[ijk][ps*l+1]-y;
+		z1=p[ijk][ps*l+2]-z;
+		rs=con.r_scale(x1*x1+y1*y1+z1*z1,ijk,l);
+		if(!c.nplane(x1,y1,z1,rs,id[ijk][l])) return false;
+	}
+	l++;
+	while(l<co[ijk]) {
+		x1=p[ijk][ps*l]-x;
+		y1=p[ijk][ps*l+1]-y;
+		z1=p[ijk][ps*l+2]-z;
+		rs=con.r_scale(x1*x1+y1*y1+z1*z1,ijk,l);
+		if(!c.nplane(x1,y1,z1,rs,id[ijk][l])) return false;
+		l++;
+	}
+
+	// Now compute the maximum distance squared from the cell center to a
+	// vertex. This is used to cut off the calculation since we only need
+	// to test out to twice this range.
+	mrs=c.max_radius_squared();
+
+	// Now compute the fractional position of the particle within its
+	// region and store it in (fx,fy,fz). We use this to compute an index
+	// (di,dj,dk) of which subregion the particle is within.
+	unsigned int m1,m2;
+	con.frac_pos(x,y,z,ci,cj,ck,fx,fy,fz);
+	di=int(fx*xsp*wl_fgrid);dj=int(fy*ysp*wl_fgrid);dk=int(fz*zsp*wl_fgrid);
+
+	// The indices (di,dj,dk) tell us which worklist to use, to test the
+	// blocks in the optimal order. But we only store worklists for the
+	// eighth of the region where di, dj, and dk are all less than half the
+	// full grid. The rest of the cases are handled by symmetry. In this
+	// section, we detect for these cases, by reflecting high values of di,
+	// dj, and dk. For these cases, a mask is constructed in m1 and m2
+	// which is used to flip the worklist information when it is loaded.
+	if(di>=wl_hgrid) {
+		gxs=fx;
+		m1=127+(3<<21);m2=1+(1<<21);di=wl_fgrid-1-di;if(di<0) di=0;
+	} else {m1=m2=0;gxs=boxx-fx;}
+	if(dj>=wl_hgrid) {
+		gys=fy;
+		m1|=(127<<7)+(3<<24);m2|=(1<<7)+(1<<24);dj=wl_fgrid-1-dj;if(dj<0) dj=0;
+	} else gys=boxy-fy;
+	if(dk>=wl_hgrid) {
+		gzs=fz;
+		m1|=(127<<14)+(3<<27);m2|=(1<<14)+(1<<27);dk=wl_fgrid-1-dk;if(dk<0) dk=0;
+	} else gzs=boxz-fz;
+	gxs*=gxs;gys*=gys;gzs*=gzs;
+
+	// Now compute which worklist we are going to use, and set radp and e to
+	// point at the right offsets
+	ijk=di+wl_hgrid*(dj+wl_hgrid*dk);
+	radp=mrad+ijk*wl_seq_length;
+	e=(const_cast<unsigned int*> (wl))+ijk*wl_seq_length;
+
+	// Read in how many items in the worklist can be tested without having to
+	// worry about writing to the mask
+	f=e[0];g=0;
+	do {
+
+		// At the intervals specified by count_list, we recompute the
+		// maximum radius squared
+		if(g==next_count) {
+			mrs=c.max_radius_squared();
+			if(count_p!=count_e) next_count=*(count_p++);
+		}
+
+		// If mrs is less than the minimum distance to any untested
+		// block, then we are done
+		if(con.r_ctest(radp[g],mrs)) return true;
+		g++;
+
+		// Load in a block off the worklist, permute it with the
+		// symmetry mask, and decode its position. These are all
+		// integer bit operations so they should run very fast.
+		q=e[g];q^=m1;q+=m2;
+		di=q&127;di-=64;
+		dj=(q>>7)&127;dj-=64;
+		dk=(q>>14)&127;dk-=64;
+
+		// Check that the worklist position is in range
+		ei=di+i;if(ei<0||ei>=hx) continue;
+		ej=dj+j;if(ej<0||ej>=hy) continue;
+		ek=dk+k;if(ek<0||ek>=hz) continue;
+
+		// Call the compute_min_max_radius() function. This returns
+		// true if the minimum distance to the block is bigger than the
+		// current mrs, in which case we skip this block and move on.
+		// Otherwise, it computes the maximum distance to the block and
+		// returns it in crs.
+		if(compute_min_max_radius(di,dj,dk,fx,fy,fz,gxs,gys,gzs,crs,mrs)) continue;
+
+		// Now compute which region we are going to loop over, adding a
+		// displacement for the periodic cases
+		ijk=con.region_index(ci,cj,ck,ei,ej,ek,qx,qy,qz,disp);
+
+		// If mrs is bigger than the maximum distance to the block,
+		// then we have to test all particles in the block for
+		// intersections. Otherwise, we do additional checks and skip
+		// those particles which can't possibly intersect the block.
+		if(co[ijk]>0) {
+			l=0;x2=x-qx;y2=y-qy;z2=z-qz;
+			if(!con.r_ctest(crs,mrs)) {
+				do {
+					x1=p[ijk][ps*l]-x2;
+					y1=p[ijk][ps*l+1]-y2;
+					z1=p[ijk][ps*l+2]-z2;
+					rs=con.r_scale(x1*x1+y1*y1+z1*z1,ijk,l);
+					if(!c.nplane(x1,y1,z1,rs,id[ijk][l])) return false;
+					l++;
+				} while (l<co[ijk]);
+			} else {
+				do {
+					x1=p[ijk][ps*l]-x2;
+					y1=p[ijk][ps*l+1]-y2;
+					z1=p[ijk][ps*l+2]-z2;
+					rs=x1*x1+y1*y1+z1*z1;
+					if(con.r_scale_check(rs,mrs,ijk,l)&&!c.nplane(x1,y1,z1,rs,id[ijk][l])) return false;
+					l++;
+				} while (l<co[ijk]);
+			}
+		}
+	} while(g<f);
+
+	// If we reach here, we were unable to compute the entire cell using
+	// the first part of the worklist. This section of the algorithm
+	// continues the worklist, but it now starts preparing the mask that we
+	// need if we end up going block by block. We do the same as before,
+	// but we put a mark down on the mask for every block that's tested.
+	// The worklist also contains information about which neighbors of each
+	// block are not also on the worklist, and we start storing those
+	// points in a list in case we have to go block by block. Update the
+	// mask counter, and if it wraps around then reset the whole mask; that
+	// will only happen once every 2^32 tries.
+	mv++;
+	if(mv==0) {reset_mask();mv=1;}
+
+	// Set the queue pointers
+	int *qu_s=qu,*qu_e=qu;
+
+	while(g<wl_seq_length-1) {
+
+		// At the intervals specified by count_list, we recompute the
+		// maximum radius squared
+		if(g==next_count) {
+			mrs=c.max_radius_squared();
+			if(count_p!=count_e) next_count=*(count_p++);
+		}
+
+		// If mrs is less than the minimum distance to any untested
+		// block, then we are done
+		if(con.r_ctest(radp[g],mrs)) return true;
+		g++;
+
+		// Load in a block off the worklist, permute it with the
+		// symmetry mask, and decode its position. These are all
+		// integer bit operations so they should run very fast.
+		q=e[g];q^=m1;q+=m2;
+		di=q&127;di-=64;
+		dj=(q>>7)&127;dj-=64;
+		dk=(q>>14)&127;dk-=64;
+
+		// Compute the position in the mask of the current block. If
+		// this lies outside the mask, then skip it. Otherwise, mark
+		// it.
+		ei=di+i;if(ei<0||ei>=hx) continue;
+		ej=dj+j;if(ej<0||ej>=hy) continue;
+		ek=dk+k;if(ek<0||ek>=hz) continue;
+		mijk=mask+ei+hx*(ej+hy*ek);
+		*mijk=mv;
+
+		// Call the compute_min_max_radius() function. This returns
+		// true if the minimum distance to the block is bigger than the
+		// current mrs, in which case we skip this block and move on.
+		// Otherwise, it computes the maximum distance to the block and
+		// returns it in crs.
+		if(compute_min_max_radius(di,dj,dk,fx,fy,fz,gxs,gys,gzs,crs,mrs)) continue;
+
+		// Now compute which region we are going to loop over, adding a
+		// displacement for the periodic cases
+		ijk=con.region_index(ci,cj,ck,ei,ej,ek,qx,qy,qz,disp);
+
+		// If mrs is bigger than the maximum distance to the block,
+		// then we have to test all particles in the block for
+		// intersections. Otherwise, we do additional checks and skip
+		// those particles which can't possibly intersect the block.
+		if(co[ijk]>0) {
+			l=0;x2=x-qx;y2=y-qy;z2=z-qz;
+			if(!con.r_ctest(crs,mrs)) {
+				do {
+					x1=p[ijk][ps*l]-x2;
+					y1=p[ijk][ps*l+1]-y2;
+					z1=p[ijk][ps*l+2]-z2;
+					rs=con.r_scale(x1*x1+y1*y1+z1*z1,ijk,l);
+					if(!c.nplane(x1,y1,z1,rs,id[ijk][l])) return false;
+					l++;
+				} while (l<co[ijk]);
+			} else {
+				do {
+					x1=p[ijk][ps*l]-x2;
+					y1=p[ijk][ps*l+1]-y2;
+					z1=p[ijk][ps*l+2]-z2;
+					rs=x1*x1+y1*y1+z1*z1;
+					if(con.r_scale_check(rs,mrs,ijk,l)&&!c.nplane(x1,y1,z1,rs,id[ijk][l])) return false;
+					l++;
+				} while (l<co[ijk]);
+			}
+		}
+
+		// If there might not be enough memory on the list for these
+		// additions, then add more
+		if(qu_e>qu_l-18) add_list_memory(qu_s,qu_e);
+
+		// Test the parts of the worklist element which tell us what
+		// neighbors of this block are not on the worklist. Store them
+		// on the block list, and mark the mask.
+		scan_bits_mask_add(q,mijk,ei,ej,ek,qu_e);
+	}
+
+	// Do a check to see if we've reached the radius cutoff
+	if(con.r_ctest(radp[g],mrs)) return true;
+
+	// We were unable to completely compute the cell based on the blocks in
+	// the worklist, so now we have to go block by block, reading in items
+	// off the list
+	while(qu_s!=qu_e) {
+
+		// If we reached the end of the list memory loop back to the
+		// start
+		if(qu_s==qu_l) qu_s=qu;
+
+		// Read in a block off the list, and compute the upper and lower
+		// coordinates in each of the three dimensions
+		ei=*(qu_s++);ej=*(qu_s++);ek=*(qu_s++);
+		xlo=(ei-i)*boxx-fx;xhi=xlo+boxx;
+		ylo=(ej-j)*boxy-fy;yhi=ylo+boxy;
+		zlo=(ek-k)*boxz-fz;zhi=zlo+boxz;
+
+		// Carry out plane tests to see if any particle in this block
+		// could possibly intersect the cell
+		if(ei>i) {
+			if(ej>j) {
+				if(ek>k) {if(corner_test(c,xlo,ylo,zlo,xhi,yhi,zhi)) continue;}
+				else if(ek<k) {if(corner_test(c,xlo,ylo,zhi,xhi,yhi,zlo)) continue;}
+				else {if(edge_z_test(c,xlo,ylo,zlo,xhi,yhi,zhi)) continue;}
+			} else if(ej<j) {
+				if(ek>k) {if(corner_test(c,xlo,yhi,zlo,xhi,ylo,zhi)) continue;}
+				else if(ek<k) {if(corner_test(c,xlo,yhi,zhi,xhi,ylo,zlo)) continue;}
+				else {if(edge_z_test(c,xlo,yhi,zlo,xhi,ylo,zhi)) continue;}
+			} else {
+				if(ek>k) {if(edge_y_test(c,xlo,ylo,zlo,xhi,yhi,zhi)) continue;}
+				else if(ek<k) {if(edge_y_test(c,xlo,ylo,zhi,xhi,yhi,zlo)) continue;}
+				else {if(face_x_test(c,xlo,ylo,zlo,yhi,zhi)) continue;}
+			}
+		} else if(ei<i) {
+			if(ej>j) {
+				if(ek>k) {if(corner_test(c,xhi,ylo,zlo,xlo,yhi,zhi)) continue;}
+				else if(ek<k) {if(corner_test(c,xhi,ylo,zhi,xlo,yhi,zlo)) continue;}
+				else {if(edge_z_test(c,xhi,ylo,zlo,xlo,yhi,zhi)) continue;}
+			} else if(ej<j) {
+				if(ek>k) {if(corner_test(c,xhi,yhi,zlo,xlo,ylo,zhi)) continue;}
+				else if(ek<k) {if(corner_test(c,xhi,yhi,zhi,xlo,ylo,zlo)) continue;}
+				else {if(edge_z_test(c,xhi,yhi,zlo,xlo,ylo,zhi)) continue;}
+			} else {
+				if(ek>k) {if(edge_y_test(c,xhi,ylo,zlo,xlo,yhi,zhi)) continue;}
+				else if(ek<k) {if(edge_y_test(c,xhi,ylo,zhi,xlo,yhi,zlo)) continue;}
+				else {if(face_x_test(c,xhi,ylo,zlo,yhi,zhi)) continue;}
+			}
+		} else {
+			if(ej>j) {
+				if(ek>k) {if(edge_x_test(c,xlo,ylo,zlo,xhi,yhi,zhi)) continue;}
+				else if(ek<k) {if(edge_x_test(c,xlo,ylo,zhi,xhi,yhi,zlo)) continue;}
+				else {if(face_y_test(c,xlo,ylo,zlo,xhi,zhi)) continue;}
+			} else if(ej<j) {
+				if(ek>k) {if(edge_x_test(c,xlo,yhi,zlo,xhi,ylo,zhi)) continue;}
+				else if(ek<k) {if(edge_x_test(c,xlo,yhi,zhi,xhi,ylo,zlo)) continue;}
+				else {if(face_y_test(c,xlo,yhi,zlo,xhi,zhi)) continue;}
+			} else {
+				if(ek>k) {if(face_z_test(c,xlo,ylo,zlo,xhi,yhi)) continue;}
+				else if(ek<k) {if(face_z_test(c,xlo,ylo,zhi,xhi,yhi)) continue;}
+				else voro_fatal_error("Compute cell routine revisiting central block, which should never\nhappen.",VOROPP_INTERNAL_ERROR);
+			}
+		}
+
+		// Now compute the region that we are going to test over, and
+		// set a displacement vector for the periodic cases
+		ijk=con.region_index(ci,cj,ck,ei,ej,ek,qx,qy,qz,disp);
+
+		// Loop over all the elements in the block to test for cuts. It
+		// would be possible to exclude some of these cases by testing
+		// against mrs, but this will probably not save time.
+		if(co[ijk]>0) {
+			l=0;x2=x-qx;y2=y-qy;z2=z-qz;
+			do {
+				x1=p[ijk][ps*l]-x2;
+				y1=p[ijk][ps*l+1]-y2;
+				z1=p[ijk][ps*l+2]-z2;
+				rs=con.r_scale(x1*x1+y1*y1+z1*z1,ijk,l);
+				if(!c.nplane(x1,y1,z1,rs,id[ijk][l])) return false;
+				l++;
+			} while (l<co[ijk]);
+		}
+
+		// If there's not much memory on the block list then add more
+		if((qu_s<=qu_e?(qu_l-qu_e)+(qu_s-qu):qu_s-qu_e)<18) add_list_memory(qu_s,qu_e);
+
+		// Test the neighbors of the current block, and add them to the
+		// block list if they haven't already been tested
+		add_to_mask(ei,ej,ek,qu_e);
+	}
+
+	return true;
+}
+
+/** This function checks to see whether a particular block can possibly have
+ * any intersection with a Voronoi cell, for the case when the closest point
+ * from the cell center to the block is at a corner.
+ * \param[in,out] c a reference to a Voronoi cell.
+ * \param[in] (xl,yl,zl) the relative coordinates of the corner of the block
+ *                       closest to the cell center.
+ * \param[in] (xh,yh,zh) the relative coordinates of the corner of the block
+ *                       furthest away from the cell center.
+ * \return False if the block may intersect, true if does not. */
+template<class c_class>
+template<class v_cell>
+bool voro_compute<c_class>::corner_test(v_cell &c,double xl,double yl,double zl,double xh,double yh,double zh) {
+	con.r_prime(xl*xl+yl*yl+zl*zl);
+	if(c.plane_intersects_guess(xh,yl,zl,con.r_cutoff(xl*xh+yl*yl+zl*zl))) return false;
+	if(c.plane_intersects(xh,yh,zl,con.r_cutoff(xl*xh+yl*yh+zl*zl))) return false;
+	if(c.plane_intersects(xl,yh,zl,con.r_cutoff(xl*xl+yl*yh+zl*zl))) return false;
+	if(c.plane_intersects(xl,yh,zh,con.r_cutoff(xl*xl+yl*yh+zl*zh))) return false;
+	if(c.plane_intersects(xl,yl,zh,con.r_cutoff(xl*xl+yl*yl+zl*zh))) return false;
+	if(c.plane_intersects(xh,yl,zh,con.r_cutoff(xl*xh+yl*yl+zl*zh))) return false;
+	return true;
+}
+
+/** This function checks to see whether a particular block can possibly have
+ * any intersection with a Voronoi cell, for the case when the closest point
+ * from the cell center to the block is on an edge which points along the x
+ * direction.
+ * \param[in,out] c a reference to a Voronoi cell.
+ * \param[in] (x0,x1) the minimum and maximum relative x coordinates of the
+ *                    block.
+ * \param[in] (yl,zl) the relative y and z coordinates of the corner of the
+ *                    block closest to the cell center.
+ * \param[in] (yh,zh) the relative y and z coordinates of the corner of the
+ *                    block furthest away from the cell center.
+ * \return False if the block may intersect, true if does not. */
+template<class c_class>
+template<class v_cell>
+inline bool voro_compute<c_class>::edge_x_test(v_cell &c,double x0,double yl,double zl,double x1,double yh,double zh) {
+	con.r_prime(yl*yl+zl*zl);
+	if(c.plane_intersects_guess(x0,yl,zh,con.r_cutoff(yl*yl+zl*zh))) return false;
+	if(c.plane_intersects(x1,yl,zh,con.r_cutoff(yl*yl+zl*zh))) return false;
+	if(c.plane_intersects(x1,yl,zl,con.r_cutoff(yl*yl+zl*zl))) return false;
+	if(c.plane_intersects(x0,yl,zl,con.r_cutoff(yl*yl+zl*zl))) return false;
+	if(c.plane_intersects(x0,yh,zl,con.r_cutoff(yl*yh+zl*zl))) return false;
+	if(c.plane_intersects(x1,yh,zl,con.r_cutoff(yl*yh+zl*zl))) return false;
+	return true;
+}
+
+/** This function checks to see whether a particular block can possibly have
+ * any intersection with a Voronoi cell, for the case when the closest point
+ * from the cell center to the block is on an edge which points along the y
+ * direction.
+ * \param[in,out] c a reference to a Voronoi cell.
+ * \param[in] (y0,y1) the minimum and maximum relative y coordinates of the
+ *                    block.
+ * \param[in] (xl,zl) the relative x and z coordinates of the corner of the
+ *                    block closest to the cell center.
+ * \param[in] (xh,zh) the relative x and z coordinates of the corner of the
+ *                    block furthest away from the cell center.
+ * \return False if the block may intersect, true if does not. */
+template<class c_class>
+template<class v_cell>
+inline bool voro_compute<c_class>::edge_y_test(v_cell &c,double xl,double y0,double zl,double xh,double y1,double zh) {
+	con.r_prime(xl*xl+zl*zl);
+	if(c.plane_intersects_guess(xl,y0,zh,con.r_cutoff(xl*xl+zl*zh))) return false;
+	if(c.plane_intersects(xl,y1,zh,con.r_cutoff(xl*xl+zl*zh))) return false;
+	if(c.plane_intersects(xl,y1,zl,con.r_cutoff(xl*xl+zl*zl))) return false;
+	if(c.plane_intersects(xl,y0,zl,con.r_cutoff(xl*xl+zl*zl))) return false;
+	if(c.plane_intersects(xh,y0,zl,con.r_cutoff(xl*xh+zl*zl))) return false;
+	if(c.plane_intersects(xh,y1,zl,con.r_cutoff(xl*xh+zl*zl))) return false;
+	return true;
+}
+
+/** This function checks to see whether a particular block can possibly have
+ * any intersection with a Voronoi cell, for the case when the closest point
+ * from the cell center to the block is on an edge which points along the z
+ * direction.
+ * \param[in,out] c a reference to a Voronoi cell.
+ * \param[in] (z0,z1) the minimum and maximum relative z coordinates of the block.
+ * \param[in] (xl,yl) the relative x and y coordinates of the corner of the
+ *                    block closest to the cell center.
+ * \param[in] (xh,yh) the relative x and y coordinates of the corner of the
+ *                    block furthest away from the cell center.
+ * \return False if the block may intersect, true if does not. */
+template<class c_class>
+template<class v_cell>
+inline bool voro_compute<c_class>::edge_z_test(v_cell &c,double xl,double yl,double z0,double xh,double yh,double z1) {
+	con.r_prime(xl*xl+yl*yl);
+	if(c.plane_intersects_guess(xl,yh,z0,con.r_cutoff(xl*xl+yl*yh))) return false;
+	if(c.plane_intersects(xl,yh,z1,con.r_cutoff(xl*xl+yl*yh))) return false;
+	if(c.plane_intersects(xl,yl,z1,con.r_cutoff(xl*xl+yl*yl))) return false;
+	if(c.plane_intersects(xl,yl,z0,con.r_cutoff(xl*xl+yl*yl))) return false;
+	if(c.plane_intersects(xh,yl,z0,con.r_cutoff(xl*xh+yl*yl))) return false;
+	if(c.plane_intersects(xh,yl,z1,con.r_cutoff(xl*xh+yl*yl))) return false;
+	return true;
+}
+
+/** This function checks to see whether a particular block can possibly have
+ * any intersection with a Voronoi cell, for the case when the closest point
+ * from the cell center to the block is on a face aligned with the x direction.
+ * \param[in,out] c a reference to a Voronoi cell.
+ * \param[in] xl the minimum distance from the cell center to the face.
+ * \param[in] (y0,y1) the minimum and maximum relative y coordinates of the
+ *                    block.
+ * \param[in] (z0,z1) the minimum and maximum relative z coordinates of the
+ *                    block.
+ * \return False if the block may intersect, true if does not. */
+template<class c_class>
+template<class v_cell>
+inline bool voro_compute<c_class>::face_x_test(v_cell &c,double xl,double y0,double z0,double y1,double z1) {
+	con.r_prime(xl*xl);
+	if(c.plane_intersects_guess(xl,y0,z0,con.r_cutoff(xl*xl))) return false;
+	if(c.plane_intersects(xl,y0,z1,con.r_cutoff(xl*xl))) return false;
+	if(c.plane_intersects(xl,y1,z1,con.r_cutoff(xl*xl))) return false;
+	if(c.plane_intersects(xl,y1,z0,con.r_cutoff(xl*xl))) return false;
+	return true;
+}
+
+/** This function checks to see whether a particular block can possibly have
+ * any intersection with a Voronoi cell, for the case when the closest point
+ * from the cell center to the block is on a face aligned with the y direction.
+ * \param[in,out] c a reference to a Voronoi cell.
+ * \param[in] yl the minimum distance from the cell center to the face.
+ * \param[in] (x0,x1) the minimum and maximum relative x coordinates of the
+ *                    block.
+ * \param[in] (z0,z1) the minimum and maximum relative z coordinates of the
+ *                    block.
+ * \return False if the block may intersect, true if does not. */
+template<class c_class>
+template<class v_cell>
+inline bool voro_compute<c_class>::face_y_test(v_cell &c,double x0,double yl,double z0,double x1,double z1) {
+	con.r_prime(yl*yl);
+	if(c.plane_intersects_guess(x0,yl,z0,con.r_cutoff(yl*yl))) return false;
+	if(c.plane_intersects(x0,yl,z1,con.r_cutoff(yl*yl))) return false;
+	if(c.plane_intersects(x1,yl,z1,con.r_cutoff(yl*yl))) return false;
+	if(c.plane_intersects(x1,yl,z0,con.r_cutoff(yl*yl))) return false;
+	return true;
+}
+
+/** This function checks to see whether a particular block can possibly have
+ * any intersection with a Voronoi cell, for the case when the closest point
+ * from the cell center to the block is on a face aligned with the z direction.
+ * \param[in,out] c a reference to a Voronoi cell.
+ * \param[in] zl the minimum distance from the cell center to the face.
+ * \param[in] (x0,x1) the minimum and maximum relative x coordinates of the
+ *                    block.
+ * \param[in] (y0,y1) the minimum and maximum relative y coordinates of the
+ *                    block.
+ * \return False if the block may intersect, true if does not. */
+template<class c_class>
+template<class v_cell>
+inline bool voro_compute<c_class>::face_z_test(v_cell &c,double x0,double y0,double zl,double x1,double y1) {
+	con.r_prime(zl*zl);
+	if(c.plane_intersects_guess(x0,y0,zl,con.r_cutoff(zl*zl))) return false;
+	if(c.plane_intersects(x0,y1,zl,con.r_cutoff(zl*zl))) return false;
+	if(c.plane_intersects(x1,y1,zl,con.r_cutoff(zl*zl))) return false;
+	if(c.plane_intersects(x1,y0,zl,con.r_cutoff(zl*zl))) return false;
+	return true;
+}
+
+
+/** This routine checks to see whether a point is within a particular distance
+ * of a nearby region. If the point is within the distance of the region, then
+ * the routine returns true, and computes the maximum distance from the point
+ * to the region. Otherwise, the routine returns false.
+ * \param[in] (di,dj,dk) the position of the nearby region to be tested,
+ *                       relative to the region that the point is in.
+ * \param[in] (fx,fy,fz) the displacement of the point within its region.
+ * \param[in] (gxs,gys,gzs) the maximum squared distances from the point to the
+ *                          sides of its region.
+ * \param[out] crs a reference in which to return the maximum distance to the
+ *                 region (only computed if the routine returns false).
+ * \param[in] mrs the distance to be tested.
+ * \return True if the region is further away than mrs, false if the region in
+ *         within mrs. */
+template<class c_class>
+bool voro_compute<c_class>::compute_min_max_radius(int di,int dj,int dk,double fx,double fy,double fz,double gxs,double gys,double gzs,double &crs,double mrs) {
+	double xlo,ylo,zlo;
+	if(di>0) {
+		xlo=di*boxx-fx;
+		crs=xlo*xlo;
+		if(dj>0) {
+			ylo=dj*boxy-fy;
+			crs+=ylo*ylo;
+			if(dk>0) {
+				zlo=dk*boxz-fz;
+				crs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;
+				crs+=bxsq+2*(boxx*xlo+boxy*ylo+boxz*zlo);
+			} else if(dk<0) {
+				zlo=(dk+1)*boxz-fz;
+				crs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;
+				crs+=bxsq+2*(boxx*xlo+boxy*ylo-boxz*zlo);
+			} else {
+				if(con.r_ctest(crs,mrs)) return true;
+				crs+=boxx*(2*xlo+boxx)+boxy*(2*ylo+boxy)+gzs;
+			}
+		} else if(dj<0) {
+			ylo=(dj+1)*boxy-fy;
+			crs+=ylo*ylo;
+			if(dk>0) {
+				zlo=dk*boxz-fz;
+				crs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;
+				crs+=bxsq+2*(boxx*xlo-boxy*ylo+boxz*zlo);
+			} else if(dk<0) {
+				zlo=(dk+1)*boxz-fz;
+				crs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;
+				crs+=bxsq+2*(boxx*xlo-boxy*ylo-boxz*zlo);
+			} else {
+				if(con.r_ctest(crs,mrs)) return true;
+				crs+=boxx*(2*xlo+boxx)+boxy*(-2*ylo+boxy)+gzs;
+			}
+		} else {
+			if(dk>0) {
+				zlo=dk*boxz-fz;
+				crs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;
+				crs+=boxz*(2*zlo+boxz);
+			} else if(dk<0) {
+				zlo=(dk+1)*boxz-fz;
+				crs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;
+				crs+=boxz*(-2*zlo+boxz);
+			} else {
+				if(con.r_ctest(crs,mrs)) return true;
+				crs+=gzs;
+			}
+			crs+=gys+boxx*(2*xlo+boxx);
+		}
+	} else if(di<0) {
+		xlo=(di+1)*boxx-fx;
+		crs=xlo*xlo;
+		if(dj>0) {
+			ylo=dj*boxy-fy;
+			crs+=ylo*ylo;
+			if(dk>0) {
+				zlo=dk*boxz-fz;
+				crs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;
+				crs+=bxsq+2*(-boxx*xlo+boxy*ylo+boxz*zlo);
+			} else if(dk<0) {
+				zlo=(dk+1)*boxz-fz;
+				crs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;
+				crs+=bxsq+2*(-boxx*xlo+boxy*ylo-boxz*zlo);
+			} else {
+				if(con.r_ctest(crs,mrs)) return true;
+				crs+=boxx*(-2*xlo+boxx)+boxy*(2*ylo+boxy)+gzs;
+			}
+		} else if(dj<0) {
+			ylo=(dj+1)*boxy-fy;
+			crs+=ylo*ylo;
+			if(dk>0) {
+				zlo=dk*boxz-fz;
+				crs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;
+				crs+=bxsq+2*(-boxx*xlo-boxy*ylo+boxz*zlo);
+			} else if(dk<0) {
+				zlo=(dk+1)*boxz-fz;
+				crs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;
+				crs+=bxsq+2*(-boxx*xlo-boxy*ylo-boxz*zlo);
+			} else {
+				if(con.r_ctest(crs,mrs)) return true;
+				crs+=boxx*(-2*xlo+boxx)+boxy*(-2*ylo+boxy)+gzs;
+			}
+		} else {
+			if(dk>0) {
+				zlo=dk*boxz-fz;
+				crs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;
+				crs+=boxz*(2*zlo+boxz);
+			} else if(dk<0) {
+				zlo=(dk+1)*boxz-fz;
+				crs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;
+				crs+=boxz*(-2*zlo+boxz);
+			} else {
+				if(con.r_ctest(crs,mrs)) return true;
+				crs+=gzs;
+			}
+			crs+=gys+boxx*(-2*xlo+boxx);
+		}
+	} else {
+		if(dj>0) {
+			ylo=dj*boxy-fy;
+			crs=ylo*ylo;
+			if(dk>0) {
+				zlo=dk*boxz-fz;
+				crs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;
+				crs+=boxz*(2*zlo+boxz);
+			} else if(dk<0) {
+				zlo=(dk+1)*boxz-fz;
+				crs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;
+				crs+=boxz*(-2*zlo+boxz);
+			} else {
+				if(con.r_ctest(crs,mrs)) return true;
+				crs+=gzs;
+			}
+			crs+=boxy*(2*ylo+boxy);
+		} else if(dj<0) {
+			ylo=(dj+1)*boxy-fy;
+			crs=ylo*ylo;
+			if(dk>0) {
+				zlo=dk*boxz-fz;
+				crs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;
+				crs+=boxz*(2*zlo+boxz);
+			} else if(dk<0) {
+				zlo=(dk+1)*boxz-fz;
+				crs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;
+				crs+=boxz*(-2*zlo+boxz);
+			} else {
+				if(con.r_ctest(crs,mrs)) return true;
+				crs+=gzs;
+			}
+			crs+=boxy*(-2*ylo+boxy);
+		} else {
+			if(dk>0) {
+				zlo=dk*boxz-fz;crs=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;
+				crs+=boxz*(2*zlo+boxz);
+			} else if(dk<0) {
+				zlo=(dk+1)*boxz-fz;crs=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;
+				crs+=boxz*(-2*zlo+boxz);
+			} else {
+				crs=0;
+				voro_fatal_error("Min/max radius function called for central block, which should never\nhappen.",VOROPP_INTERNAL_ERROR);
+			}
+			crs+=gys;
+		}
+		crs+=gxs;
+	}
+	return false;
+}
+
+template<class c_class>
+bool voro_compute<c_class>::compute_min_radius(int di,int dj,int dk,double fx,double fy,double fz,double mrs) {
+	double t,crs;
+
+	if(di>0) {t=di*boxx-fx;crs=t*t;}
+	else if(di<0) {t=(di+1)*boxx-fx;crs=t*t;}
+	else crs=0;
+
+	if(dj>0) {t=dj*boxy-fy;crs+=t*t;}
+	else if(dj<0) {t=(dj+1)*boxy-fy;crs+=t*t;}
+
+	if(dk>0) {t=dk*boxz-fz;crs+=t*t;}
+	else if(dk<0) {t=(dk+1)*boxz-fz;crs+=t*t;}
+
+	return crs>con.r_max_add(mrs);
+}
+
+/** Adds memory to the queue.
+ * \param[in,out] qu_s a reference to the queue start pointer.
+ * \param[in,out] qu_e a reference to the queue end pointer. */
+template<class c_class>
+inline void voro_compute<c_class>::add_list_memory(int*& qu_s,int*& qu_e) {
+	qu_size<<=1;
+	int *qu_n=new int[qu_size],*qu_c=qu_n;
+#if VOROPP_VERBOSE >=2
+	fprintf(stderr,"List memory scaled up to %d\n",qu_size);
+#endif
+	if(qu_s<=qu_e) {
+		while(qu_s<qu_e) *(qu_c++)=*(qu_s++);
+	} else {
+		while(qu_s<qu_l) *(qu_c++)=*(qu_s++);qu_s=qu;
+		while(qu_s<qu_e) *(qu_c++)=*(qu_s++);
+	}
+	delete [] qu;
+	qu_s=qu=qu_n;
+	qu_l=qu+qu_size;
+	qu_e=qu_c;
+}
+
+// Explicit template instantiation
+template voro_compute<container>::voro_compute(container&,int,int,int);
+template voro_compute<container_poly>::voro_compute(container_poly&,int,int,int);
+template bool voro_compute<container>::compute_cell(voronoicell&,int,int,int,int,int);
+template bool voro_compute<container>::compute_cell(voronoicell_neighbor&,int,int,int,int,int);
+template void voro_compute<container>::find_voronoi_cell(double,double,double,int,int,int,int,particle_record&,double&);
+template bool voro_compute<container_poly>::compute_cell(voronoicell&,int,int,int,int,int);
+template bool voro_compute<container_poly>::compute_cell(voronoicell_neighbor&,int,int,int,int,int);
+template void voro_compute<container_poly>::find_voronoi_cell(double,double,double,int,int,int,int,particle_record&,double&);
+
+// Explicit template instantiation
+template voro_compute<container_periodic>::voro_compute(container_periodic&,int,int,int);
+template voro_compute<container_periodic_poly>::voro_compute(container_periodic_poly&,int,int,int);
+template bool voro_compute<container_periodic>::compute_cell(voronoicell&,int,int,int,int,int);
+template bool voro_compute<container_periodic>::compute_cell(voronoicell_neighbor&,int,int,int,int,int);
+template void voro_compute<container_periodic>::find_voronoi_cell(double,double,double,int,int,int,int,particle_record&,double&);
+template bool voro_compute<container_periodic_poly>::compute_cell(voronoicell&,int,int,int,int,int);
+template bool voro_compute<container_periodic_poly>::compute_cell(voronoicell_neighbor&,int,int,int,int,int);
+template void voro_compute<container_periodic_poly>::find_voronoi_cell(double,double,double,int,int,int,int,particle_record&,double&);
+
+}
diff -ru --new-file blender-2.76b.old/extern/voro++/src/v_compute.hh blender-2.76b/extern/voro++/src/v_compute.hh
--- blender-2.76b.old/extern/voro++/src/v_compute.hh	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/v_compute.hh	2016-01-27 19:09:54.051496559 +0300
@@ -0,0 +1,149 @@
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \file v_compute.hh
+ * \brief Header file for the voro_compute template and related classes. */
+
+#ifndef VOROPP_V_COMPUTE_HH
+#define VOROPP_V_COMPUTE_HH
+
+#include "config.hh"
+#include "worklist.hh"
+#include "cell.hh"
+
+namespace voro {
+
+/** \brief Structure for holding information about a particle.
+ *
+ * This small structure holds information about a single particle, and is used
+ * by several of the routines in the voro_compute template for passing
+ * information by reference between functions. */
+struct particle_record {
+	/** The index of the block that the particle is within. */
+	int ijk;
+	/** The number of particle within its block. */
+	int l;
+	/** The x-index of the block. */
+	int di;
+	/** The y-index of the block. */
+	int dj;
+	/** The z-index of the block. */
+	int dk;
+};
+
+/** \brief Template for carrying out Voronoi cell computations. */
+template <class c_class>
+class voro_compute {
+	public:
+		/** A reference to the container class on which to carry out*/
+		c_class &con;
+		/** The size of an internal computational block in the x
+		 * direction. */
+		const double boxx;
+		/** The size of an internal computational block in the y
+		 * direction. */
+		const double boxy;
+		/** The size of an internal computational block in the z
+		 * direction. */
+		const double boxz;
+		/** The inverse box length in the x direction, set to
+		 * nx/(bx-ax). */
+		const double xsp;
+		/** The inverse box length in the y direction, set to
+		 * ny/(by-ay). */
+		const double ysp;
+		/** The inverse box length in the z direction, set to
+		 * nz/(bz-az). */
+		const double zsp;
+		/** The number of boxes in the x direction for the searching mask. */
+		const int hx;
+		/** The number of boxes in the y direction for the searching mask. */
+		const int hy;
+		/** The number of boxes in the z direction for the searching mask. */
+		const int hz;
+		/** A constant, set to the value of hx multiplied by hy, which
+		 * is used in the routines which step through mask boxes in
+		 * sequence. */
+		const int hxy;
+		/** A constant, set to the value of hx*hy*hz, which is used in
+		 * the routines which step through mask boxes in sequence. */
+		const int hxyz;
+		/** The number of floating point entries to store for each
+		 * particle. */
+		const int ps;
+		/** This array holds the numerical IDs of each particle in each
+		 * computational box. */
+		int **id;
+		/** A two dimensional array holding particle positions. For the
+		 * derived container_poly class, this also holds particle
+		 * radii. */
+		double **p;
+		/** An array holding the number of particles within each
+		 * computational box of the container. */
+		int *co;
+		voro_compute(c_class &con_,int hx_,int hy_,int hz_);
+		/** The class destructor frees the dynamically allocated memory
+		 * for the mask and queue. */
+		~voro_compute() {
+			delete [] qu;
+			delete [] mask;
+		}
+		template<class v_cell>
+		bool compute_cell(v_cell &c,int ijk,int s,int ci,int cj,int ck);
+		void find_voronoi_cell(double x,double y,double z,int ci,int cj,int ck,int ijk,particle_record &w,double &mrs);
+	private:
+		/** A constant set to boxx*boxx+boxy*boxy+boxz*boxz, which is
+		 * frequently used in the computation. */
+		const double bxsq;
+		/** This sets the current value being used to mark tested blocks
+		 * in the mask. */
+		unsigned int mv;
+		/** The current size of the search list. */
+		int qu_size;
+		/** A pointer to the array of worklists. */
+		const unsigned int *wl;
+		/** An pointer to the array holding the minimum distances
+		 * associated with the worklists. */
+		double *mrad;
+		/** This array is used during the cell computation to determine
+		 * which blocks have been considered. */
+		unsigned int *mask;
+		/** An array is used to store the queue of blocks to test
+		 * during the Voronoi cell computation. */
+		int *qu;
+		/** A pointer to the end of the queue array, used to determine
+		 * when the queue is full. */
+		int *qu_l;
+		template<class v_cell>
+		bool corner_test(v_cell &c,double xl,double yl,double zl,double xh,double yh,double zh);
+		template<class v_cell>
+		inline bool edge_x_test(v_cell &c,double x0,double yl,double zl,double x1,double yh,double zh);
+		template<class v_cell>
+		inline bool edge_y_test(v_cell &c,double xl,double y0,double zl,double xh,double y1,double zh);
+		template<class v_cell>
+		inline bool edge_z_test(v_cell &c,double xl,double yl,double z0,double xh,double yh,double z1);
+		template<class v_cell>
+		inline bool face_x_test(v_cell &c,double xl,double y0,double z0,double y1,double z1);
+		template<class v_cell>
+		inline bool face_y_test(v_cell &c,double x0,double yl,double z0,double x1,double z1);
+		template<class v_cell>
+		inline bool face_z_test(v_cell &c,double x0,double y0,double zl,double x1,double y1);
+		bool compute_min_max_radius(int di,int dj,int dk,double fx,double fy,double fz,double gx,double gy,double gz,double& crs,double mrs);
+		bool compute_min_radius(int di,int dj,int dk,double fx,double fy,double fz,double mrs);
+		inline void add_to_mask(int ei,int ej,int ek,int *&qu_e);
+		inline void scan_bits_mask_add(unsigned int q,unsigned int *mijk,int ei,int ej,int ek,int *&qu_e);
+		inline void scan_all(int ijk,double x,double y,double z,int di,int dj,int dk,particle_record &w,double &mrs);
+		void add_list_memory(int*& qu_s,int*& qu_e);
+		/** Resets the mask in cases where the mask counter wraps
+		 * around. */
+		inline void reset_mask() {
+			for(unsigned int *mp(mask);mp<mask+hxyz;mp++) *mp=0;
+		}
+};
+
+}
+
+#endif
diff -ru --new-file blender-2.76b.old/extern/voro++/src/voro++.hh blender-2.76b/extern/voro++/src/voro++.hh
--- blender-2.76b.old/extern/voro++/src/voro++.hh	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/voro++.hh	2016-01-27 19:11:34.050741001 +0300
@@ -0,0 +1,357 @@
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \file voro++.hh
+ * \brief A file that loads all of the Voro++ header files. */
+
+/** \mainpage Voro++ class reference manual
+ * \section intro Introduction
+ * Voro++ is a software library for carrying out three-dimensional computations
+ * of the Voronoi tessellation. A distinguishing feature of the Voro++ library
+ * is that it carries out cell-based calculations, computing the Voronoi cell
+ * for each particle individually, rather than computing the Voronoi
+ * tessellation as a global network of vertices and edges. It is particularly
+ * well-suited for applications that rely on cell-based statistics, where
+ * features of Voronoi cells (eg. volume, centroid, number of faces) can be
+ * used to analyze a system of particles.
+ *
+ * Voro++ is written in C++ and can be built as a static library that can be
+ * linked to. This manual provides a reference for every function in the class
+ * structure. For a general overview of the program, see the Voro++ website at
+ * http://math.lbl.gov/voro++/ and in particular the example programs at
+ * http://math.lbl.gov/voro++/examples/ that demonstrate many of the library's
+ * features.
+ *
+ * \section class C++ class structure
+ * The code is structured around several C++ classes. The voronoicell_base
+ * class contains all of the routines for constructing a single Voronoi cell.
+ * It represents the cell as a collection of vertices that are connected by
+ * edges, and there are routines for initializing, making, and outputting the
+ * cell. The voronoicell_base class form the base of the voronoicell and
+ * voronoicell_neighbor classes, which add specialized routines depending on
+ * whether neighboring particle ID information for each face must be tracked or
+ * not. Collectively, these classes are referred to as "voronoicell classes"
+ * within the documentation.
+ *
+ * There is a hierarchy of classes that represent three-dimensional particle
+ * systems. All of these are derived from the voro_base class, which contains
+ * constants that divide a three-dimensional system into a rectangular grid of
+ * equally-sized rectangular blocks; this grid is used for computational
+ * efficiency during the Voronoi calculations.
+ *
+ * The container_base, container, and container_poly are then derived from the
+ * voro_base class to represent a particle system in a specific
+ * three-dimensional rectangular box using both periodic and non-periodic
+ * boundary conditions. In addition, the container_periodic_base,
+ * container_periodic, and container_periodic_poly classes represent
+ * a particle system in a three-dimensional non-orthogonal periodic domain,
+ * defined by three periodicity vectors that represent a parallelepiped.
+ * Collectively, these classes are referred to as "container classes" within
+ * the documentation.
+ *
+ * The voro_compute template encapsulates all of the routines for computing
+ * Voronoi cells. Each container class has a voro_compute template within
+ * it, that accesses the container's particle system, and computes the Voronoi
+ * cells.
+ *
+ * There are several wall classes that can be used to apply certain boundary
+ * conditions using additional plane cuts during the Voronoi cell compution.
+ * The code also contains a number of small loop classes, c_loop_all,
+ * c_loop_subset, c_loop_all_periodic, and c_loop_order that can be used to
+ * iterate over a certain subset of particles in a container. The latter class
+ * makes use of a special particle_order class that stores a specific order of
+ * particles within the container. The library also contains the classes
+ * pre_container_base, pre_container, and pre_container_poly, that can be used
+ * as temporary storage when importing data of unknown size.
+ *
+ * \section voronoicell The voronoicell classes
+ * The voronoicell class represents a single Voronoi cell as a convex
+ * polyhedron, with a set of vertices that are connected by edges. The class
+ * contains a variety of functions that can be used to compute and output the
+ * Voronoi cell corresponding to a particular particle. The command init()
+ * can be used to initialize a cell as a large rectangular box. The Voronoi cell
+ * can then be computed by repeatedly cutting it with planes that correspond to
+ * the perpendicular bisectors between that particle and its neighbors.
+ *
+ * This is achieved by using the plane() routine, which will recompute the
+ * cell's vertices and edges after cutting it with a single plane. This is the
+ * key routine in voronoicell class. It begins by exploiting the convexity
+ * of the underlying cell, tracing between edges to work out if the cell
+ * intersects the cutting plane. If it does not intersect, then the routine
+ * immediately exits. Otherwise, it finds an edge or vertex that intersects
+ * the plane, and from there, traces out a new face on the cell, recomputing
+ * the edge and vertex structure accordingly.
+ *
+ * Once the cell is computed, there are many routines for computing features of
+ * the the Voronoi cell, such as its volume, surface area, or centroid. There
+ * are also many routines for outputting features of the Voronoi cell, or
+ * writing its shape in formats that can be read by Gnuplot or POV-Ray.
+ *
+ * \subsection internal Internal data representation
+ * The voronoicell class has a public member p representing the
+ * number of vertices. The polyhedral structure of the cell is stored
+ * in the following arrays:
+ *
+ * - pts: a one-dimensional array of floating point numbers, that represent the
+ *   position vectors x_0, x_1, ..., x_{p-1} of the polyhedron vertices.
+ * - nu: the order of each vertex n_0, n_1, ..., n_{p-1}, corresponding to
+ *   the number of other vertices to which each is connected.
+ * - ed: a two-dimensional table of edges and relations. For the ith vertex,
+ *   ed[i] has 2n_i+1 elements. The first n_i elements are the edges e(j,i),
+ *   where e(j,i) is the jth neighbor of vertex i. The edges are ordered
+ *   according to a right-hand rule with respect to an outward-pointing normal.
+ *   The next n_i elements are the relations l(j,i) which satisfy the property
+ *   e(l(j,i),e(j,i)) = i. The final element of the ed[i] list is a back
+ *   pointer used in memory allocation.
+ *
+ * In a very large number of cases, the values of n_i will be 3. This is because
+ * the only way that a higher-order vertex can be created in the plane()
+ * routine is if the cutting plane perfectly intersects an existing vertex. For
+ * random particle arrangements with position vectors specified to double
+ * precision this should happen very rarely. A preliminary version of this code
+ * was quite successful with only making use of vertices of order 3. However,
+ * when calculating millions of cells, it was found that this approach is not
+ * robust, since a single floating point error can invalidate the computation.
+ * This can also be a problem for cases featuring crystalline arrangements of
+ * particles where the corresponding Voronoi cells may have high-order vertices
+ * by construction.
+ *
+ * Because of this, Voro++ takes the approach that it if an existing vertex is
+ * within a small numerical tolerance of the cutting plane, it is treated as
+ * being exactly on the plane, and the polyhedral topology is recomputed
+ * accordingly. However, while this improves robustness, it also adds the
+ * complexity that n_i may no longer always be 3. This causes memory management
+ * to be significantly more complicated, as different vertices require a
+ * different number of elements in the ed[][] array. To accommodate this, the
+ * voronoicell class allocated edge memory in a different array called mep[][],
+ * in such a way that all vertices of order k are held in mep[k]. If vertex
+ * i has order k, then ed[i] points to memory within mep[k]. The array ed[][]
+ * is never directly initialized as a two-dimensional array itself, but points
+ * at allocations within mep[][]. To the user, it appears as though each row of
+ * ed[][] has a different number of elements. When vertices are added or
+ * deleted, care must be taken to reorder and reassign elements in these
+ * arrays.
+ *
+ * During the plane() routine, the code traces around the vertices of the cell,
+ * and adds new vertices along edges which intersect the cutting plane to
+ * create a new face. The values of l(j,i) are used in this computation, as
+ * when the code is traversing from one vertex on the cell to another, this
+ * information allows the code to immediately work out which edge of a vertex
+ * points back to the one it came from. As new vertices are created, the l(j,i)
+ * are also updated to ensure consistency. To ensure robustness, the plane
+ * cutting algorithm should work with any possible combination of vertices
+ * which are inside, outside, or exactly on the cutting plane.
+ *
+ * Vertices exactly on the cutting plane create some additional computational
+ * difficulties. If there are two marginal vertices connected by an existing
+ * edge, then it would be possible for duplicate edges to be created between
+ * those two vertices, if the plane routine traces along both sides of this
+ * edge while constructing the new face. The code recognizes these cases and
+ * prevents the double edge from being formed. Another possibility is the
+ * formation of vertices of order two or one. At the end of the plane cutting
+ * routine, the code checks to see if any of these are present, removing the
+ * order one vertices by just deleting them, and removing the order two
+ * vertices by connecting the two neighbors of each vertex together. It is
+ * possible that the removal of a single low-order vertex could result in the
+ * creation of additional low-order vertices, so the process is applied
+ * recursively until no more are left.
+ *
+ * \section container The container classes
+ * There are four container classes available for general usage: container,
+ * container_poly, container_periodic, and container_periodic_poly. Each of
+ * these represent a system of particles in a specific three-dimensional
+ * geometry. They contain routines for importing particles from a text file,
+ * and adding particles individually. They also contain a large number of
+ * analyzing and outputting the particle system. Internally, the routines that
+ * compute Voronoi cells do so by making use of the voro_compute template.
+ * Each container class contains routines that tell the voro_compute template
+ * about the specific geometry of this container.
+ *
+ * \section voro_compute The voro_compute template
+ * The voro_compute template encapsulates the routines for carrying out the
+ * Voronoi cell computations. It contains data structures suchs as a mask and a
+ * queue that are used in the computations. The voro_compute template is
+ * associated with a specific container class, and during the computation, it
+ * calls routines in the container class to access the particle positions that
+ * are stored there.
+ *
+ * The key routine in this class is compute_cell(), which makes use of a
+ * voronoicell class to construct a Voronoi cell for a specific particle in the
+ * container. The basic approach that this function takes is to repeatedly cut
+ * the Voronoi cell by planes corresponding neighboring particles, and stop
+ * when it recognizes that all the remaining particles in the container are too
+ * far away to possibly influence cell's shape. The code makes use of two
+ * possible methods for working out when a cell computation is complete:
+ *
+ * - Radius test: if the maximum distance of a Voronoi cell
+ *   vertex from the cell center is R, then no particles more than a distance
+ *   2R away can possibly influence the cell. This a very fast computation to
+ *   do, but it has no directionality: if the cell extends a long way in one
+ *   direction then particles a long distance in other directions will still
+ *   need to be tested.
+ * - Region test: it is possible to test whether a specific region can
+ *   possibly influence the cell by applying a series of plane tests at the
+ *   point on the region which is closest to the Voronoi cell center. This is a
+ *   slower computation to do, but it has directionality.
+ *
+ * Another useful observation is that the regions that need to be tested are
+ * simply connected, meaning that if a particular region does not need to be
+ * tested, then neighboring regions which are further away do not need to be
+ * tested.
+ *
+ * For maximum efficiency, it was found that a hybrid approach making use of
+ * both of the above tests worked well in practice. Radius tests work well for
+ * the first few blocks, but switching to region tests after then prevent the
+ * code from becoming extremely slow, due to testing over very large spherical
+ * shells of particles. The compute_cell() routine therefore takes the
+ * following approach:
+ *
+ * - Initialize the voronoicell class to fill the entire computational domain.
+ * - Cut the cell by any wall objects that have been added to the container.
+ * - Apply plane cuts to the cell corresponding to the other particles which
+ *   are within the current particle's region.
+ * - Test over a pre-computed worklist of neighboring regions, that have been
+ *   ordered according to the minimum distance away from the particle's
+ *   position. Apply radius tests after every few regions to see if the
+ *   calculation can terminate.
+ * - If the code reaches the end of the worklist, add all the neighboring
+ *   regions to a new list.
+ * - Carry out a region test on the first item of the list. If the region needs
+ *   to be tested, apply the plane() routine for all of its particles, and then
+ *   add any neighboring regions to the end of the list that need to be tested.
+ *   Continue until the list has no elements left.
+ *
+ * The compute_cell() routine forms the basis of many other routines, such as
+ * store_cell_volumes() and draw_cells_gnuplot() that can be used to calculate
+ * and draw the cells in a container.
+ *
+ * \section walls Wall computation
+ * Wall computations are handled by making use of a pure virtual wall class.
+ * Specific wall types are derived from this class, and require the
+ * specification of two routines: point_inside() that tests to see if a point
+ * is inside a wall or not, and cut_cell() that cuts a cell according to the
+ * wall's position. The walls can be added to the container using the
+ * add_wall() command, and these are called each time a compute_cell() command
+ * is carried out. At present, wall types for planes, spheres, cylinders, and
+ * cones are provided, although custom walls can be added by creating new
+ * classes derived from the pure virtual class. Currently all wall types
+ * approximate the wall surface with a single plane, which produces some small
+ * errors, but generally gives good results for dense particle packings in
+ * direct contact with a wall surface. It would be possible to create more
+ * accurate walls by making cut_cell() routines that approximate the curved
+ * surface with multiple plane cuts.
+ *
+ * The wall objects can used for periodic calculations, although to obtain
+ * valid results, the walls should also be periodic as well. For example, in a
+ * domain that is periodic in the x direction, a cylinder aligned along the x
+ * axis could be added. At present, the interior of all wall objects are convex
+ * domains, and consequently any superposition of them will be a convex domain
+ * also. Carrying out computations in non-convex domains poses some problems,
+ * since this could theoretically lead to non-convex Voronoi cells, which the
+ * internal data representation of the voronoicell class does not support. For
+ * non-convex cases where the wall surfaces feature just a small amount of
+ * negative curvature (eg. a torus) approximating the curved surface with a
+ * single plane cut may give an acceptable level of accuracy. For non-convex
+ * cases that feature internal angles, the best strategy may be to decompose
+ * the domain into several convex subdomains, carry out a calculation in each,
+ * and then add the results together. The voronoicell class cannot be easily
+ * modified to handle non-convex cells as this would fundamentally alter the
+ * algorithms that it uses, and cases could arise where a single plane cut
+ * could create several new faces as opposed to just one.
+ *
+ * \section loops Loop classes
+ * The container classes have a number of simple routines for calculating
+ * Voronoi cells for all particles within them. However, in some situations it
+ * is desirable to iterate over a specific subset of particles. This can be
+ * achieved with the c_loop classes that are all derived from the c_loop_base
+ * class. Each class can iterate over a specific subset of particles in a
+ * container. There are three loop classes for use with the container and
+ * container_poly classes:
+ *
+ * - c_loop_all will loop over all of the particles in a container.
+ * - c_loop_subset will loop over a subset of particles in a container that lie
+ *   within some geometrical region. It can loop over particles in a
+ *   rectangular box, particles in a sphere, or particles that lie within
+ *   specific internal computational blocks.
+ * - c_loop_order will loop over a specific list of particles that were
+ *   previously stored in a particle_order class.
+ *
+ * Several of the key routines within the container classes (such as
+ * draw_cells_gnuplot and print_custom) have versions where they can be passed
+ * a loop class to use. Loop classes can also be used directly and there are
+ * some examples on the library website that demonstrate this. It is also
+ * possible to write custom loop classes.
+ *
+ * In addition to the loop classes mentioned above, there is also a
+ * c_loop_all_periodic class, that is specifically for use with the
+ * container_periodic and container_periodic_poly classes. Since the data
+ * structures of these containers differ considerably, it requires a different
+ * loop class that is not interoperable with the others.
+ *
+ * \section pre_container The pre_container classes
+ * Voro++ makes use of internal computational grid of blocks that are used to
+ * configure the code for maximum efficiency. As discussed on the library
+ * website, the best performance is achieved for around 5 particles per block,
+ * with anything in the range from 3 to 12 giving good performance. Usually
+ * the size of the grid can be chosen by ensuring that the number of blocks is
+ * equal to the number of particles divided by 5.
+ *
+ * However, this can be difficult to choose in cases when the number of
+ * particles is not known a priori, and in thes cases the pre_container classes
+ * can be used. They can import an arbitrary number of particle positions from
+ * a file, dynamically allocating memory in chunks as necessary. Once particles
+ * are imported, they can guess an optimal block arrangement to use for the
+ * container class, and then transfer the particles to the container. By
+ * default, this procedure is used by the command-line utility to enable it to
+ * work well with arbitrary sizes of input data.
+ *
+ * The pre_container class can be used when no particle radius information is
+ * available, and the pre_container_poly class can be used when radius
+ * information is available. At present, the pre_container classes can only be
+ * used with the container and container_poly classes. They do not support
+ * the container_periodic and container_periodic_poly classes. */
+
+#ifndef VOROPP_HH
+#define VOROPP_HH
+
+#include "config.hh"
+#include "common.hh"
+#include "cell.hh"
+#include "v_base.hh"
+#include "rad_option.hh"
+#include "container.hh"
+#include "unitcell.hh"
+#include "container_prd.hh"
+#include "pre_container.hh"
+#include "v_compute.hh"
+#include "c_loops.hh"
+#include "wall.hh"
+
+#endif
+ndex: extern/voro++/src/voro++.cc
+==================================================================
+-- /dev/null
+++ extern/voro++/src/voro++.cc
+@ -0,0 +1,19 @@
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \file voro++.cc
+ * \brief A file that loads all of the function implementation files. */
+
+#include "cell.cc"
+#include "common.cc"
+#include "v_base.cc"
+#include "container.cc"
+#include "unitcell.cc"
+#include "container_prd.cc"
+#include "pre_container.cc"
+#include "v_compute.cc"
+#include "c_loops.cc"
+#include "wall.cc"
diff -ru --new-file blender-2.76b.old/extern/voro++/src/wall.cc blender-2.76b/extern/voro++/src/wall.cc
--- blender-2.76b.old/extern/voro++/src/wall.cc	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/wall.cc	2016-01-27 19:12:22.473375372 +0300
@@ -0,0 +1,132 @@
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \file wall.cc
+ * \brief Function implementations for the derived wall classes. */
+
+#include "wall.hh"
+
+namespace voro {
+
+/** Tests to see whether a point is inside the sphere wall object.
+ * \param[in,out] (x,y,z) the vector to test.
+ * \return True if the point is inside, false if the point is outside. */
+bool wall_sphere::point_inside(double x,double y,double z) {
+	return (x-xc)*(x-xc)+(y-yc)*(y-yc)+(z-zc)*(z-zc)<rc*rc;
+}
+
+/** Cuts a cell by the sphere wall object. The spherical wall is approximated by
+ * a single plane applied at the point on the sphere which is closest to the center
+ * of the cell. This works well for particle arrangements that are packed against
+ * the wall, but loses accuracy for sparse particle distributions.
+ * \param[in,out] c the Voronoi cell to be cut.
+ * \param[in] (x,y,z) the location of the Voronoi cell.
+ * \return True if the cell still exists, false if the cell is deleted. */
+template<class v_cell>
+bool wall_sphere::cut_cell_base(v_cell &c,double x,double y,double z) {
+	double xd=x-xc,yd=y-yc,zd=z-zc,dq=xd*xd+yd*yd+zd*zd;
+	if (dq>1e-5) {
+		dq=2*(sqrt(dq)*rc-dq);
+		return c.nplane(xd,yd,zd,dq,w_id);
+	}
+	return true;
+}
+
+/** Tests to see whether a point is inside the plane wall object.
+ * \param[in] (x,y,z) the vector to test.
+ * \return True if the point is inside, false if the point is outside. */
+bool wall_plane::point_inside(double x,double y,double z) {
+	return x*xc+y*yc+z*zc<ac;
+}
+
+/** Cuts a cell by the plane wall object.
+ * \param[in,out] c the Voronoi cell to be cut.
+ * \param[in] (x,y,z) the location of the Voronoi cell.
+ * \return True if the cell still exists, false if the cell is deleted. */
+template<class v_cell>
+bool wall_plane::cut_cell_base(v_cell &c,double x,double y,double z) {
+	double dq=2*(ac-x*xc-y*yc-z*zc);
+	return c.nplane(xc,yc,zc,dq,w_id);
+}
+
+/** Tests to see whether a point is inside the cylindrical wall object.
+ * \param[in] (x,y,z) the vector to test.
+ * \return True if the point is inside, false if the point is outside. */
+bool wall_cylinder::point_inside(double x,double y,double z) {
+	double xd=x-xc,yd=y-yc,zd=z-zc;
+	double pa=(xd*xa+yd*ya+zd*za)*asi;
+	xd-=xa*pa;yd-=ya*pa;zd-=za*pa;
+	return xd*xd+yd*yd+zd*zd<rc*rc;
+}
+
+/** Cuts a cell by the cylindrical wall object. The cylindrical wall is
+ * approximated by a single plane applied at the point on the cylinder which is
+ * closest to the center of the cell. This works well for particle arrangements
+ * that are packed against the wall, but loses accuracy for sparse particle
+ * distributions.
+ * \param[in,out] c the Voronoi cell to be cut.
+ * \param[in] (x,y,z) the location of the Voronoi cell.
+ * \return True if the cell still exists, false if the cell is deleted. */
+template<class v_cell>
+bool wall_cylinder::cut_cell_base(v_cell &c,double x,double y,double z) {
+	double xd=x-xc,yd=y-yc,zd=z-zc,pa=(xd*xa+yd*ya+zd*za)*asi;
+	xd-=xa*pa;yd-=ya*pa;zd-=za*pa;
+	pa=xd*xd+yd*yd+zd*zd;
+	if(pa>1e-5) {
+		pa=2*(sqrt(pa)*rc-pa);
+		return c.nplane(xd,yd,zd,pa,w_id);
+	}
+	return true;
+}
+
+/** Tests to see whether a point is inside the cone wall object.
+ * \param[in] (x,y,z) the vector to test.
+ * \return True if the point is inside, false if the point is outside. */
+bool wall_cone::point_inside(double x,double y,double z) {
+	double xd=x-xc,yd=y-yc,zd=z-zc,pa=(xd*xa+yd*ya+zd*za)*asi;
+	xd-=xa*pa;yd-=ya*pa;zd-=za*pa;
+	pa*=gra;
+	if (pa<0) return false;
+	pa*=pa;
+	return xd*xd+yd*yd+zd*zd<pa;
+}
+
+/** Cuts a cell by the cone wall object. The conical wall is
+ * approximated by a single plane applied at the point on the cone which is
+ * closest to the center of the cell. This works well for particle arrangements
+ * that are packed against the wall, but loses accuracy for sparse particle
+ * distributions.
+ * \param[in,out] c the Voronoi cell to be cut.
+ * \param[in] (x,y,z) the location of the Voronoi cell.
+ * \return True if the cell still exists, false if the cell is deleted. */
+template<class v_cell>
+bool wall_cone::cut_cell_base(v_cell &c,double x,double y,double z) {
+	double xd=x-xc,yd=y-yc,zd=z-zc,xf,yf,zf,q,pa=(xd*xa+yd*ya+zd*za)*asi;
+	xd-=xa*pa;yd-=ya*pa;zd-=za*pa;
+	pa=xd*xd+yd*yd+zd*zd;
+	if(pa>1e-5) {
+		pa=1/sqrt(pa);
+		q=sqrt(asi);
+		xf=-sang*q*xa+cang*pa*xd;
+		yf=-sang*q*ya+cang*pa*yd;
+		zf=-sang*q*za+cang*pa*zd;
+		pa=2*(xf*(xc-x)+yf*(yc-y)+zf*(zc-z));
+		return c.nplane(xf,yf,zf,pa,w_id);
+	}
+	return true;
+}
+
+// Explicit instantiation
+template bool wall_sphere::cut_cell_base(voronoicell&,double,double,double);
+template bool wall_sphere::cut_cell_base(voronoicell_neighbor&,double,double,double);
+template bool wall_plane::cut_cell_base(voronoicell&,double,double,double);
+template bool wall_plane::cut_cell_base(voronoicell_neighbor&,double,double,double);
+template bool wall_cylinder::cut_cell_base(voronoicell&,double,double,double);
+template bool wall_cylinder::cut_cell_base(voronoicell_neighbor&,double,double,double);
+template bool wall_cone::cut_cell_base(voronoicell&,double,double,double);
+template bool wall_cone::cut_cell_base(voronoicell_neighbor&,double,double,double);
+
+}
diff -ru --new-file blender-2.76b.old/extern/voro++/src/wall.hh blender-2.76b/extern/voro++/src/wall.hh
--- blender-2.76b.old/extern/voro++/src/wall.hh	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/wall.hh	2016-01-27 19:11:58.385557235 +0300
@@ -0,0 +1,119 @@
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \file wall.hh
+ * \brief Header file for the derived wall classes. */
+
+#ifndef VOROPP_WALL_HH
+#define VOROPP_WALL_HH
+
+#include "cell.hh"
+#include "container.hh"
+
+namespace voro {
+
+/** \brief A class representing a spherical wall object.
+ *
+ * This class represents a spherical wall object. */
+struct wall_sphere : public wall {
+	public:
+		/** Constructs a spherical wall object.
+		 * \param[in] w_id_ an ID number to associate with the wall for
+		 *		    neighbor tracking.
+		 * \param[in] (xc_,yc_,zc_) a position vector for the sphere's
+		 * 			    center.
+		 * \param[in] rc_ the radius of the sphere. */
+		wall_sphere(double xc_,double yc_,double zc_,double rc_,int w_id_=-99)
+			: w_id(w_id_), xc(xc_), yc(yc_), zc(zc_), rc(rc_) {}
+		bool point_inside(double x,double y,double z);
+		template<class v_cell>
+		bool cut_cell_base(v_cell &c,double x,double y,double z);
+		bool cut_cell(voronoicell &c,double x,double y,double z) {return cut_cell_base(c,x,y,z);}
+		bool cut_cell(voronoicell_neighbor &c,double x,double y,double z) {return cut_cell_base(c,x,y,z);}
+	private:
+		const int w_id;
+		const double xc,yc,zc,rc;
+};
+
+/** \brief A class representing a plane wall object.
+ *
+ * This class represents a single plane wall object. */
+struct wall_plane : public wall {
+	public:
+		/** Constructs a plane wall object.
+		 * \param[in] (xc_,yc_,zc_) a normal vector to the plane.
+		 * \param[in] ac_ a displacement along the normal vector.
+		 * \param[in] w_id_ an ID number to associate with the wall for
+		 *		    neighbor tracking. */
+		wall_plane(double xc_,double yc_,double zc_,double ac_,int w_id_=-99)
+			: w_id(w_id_), xc(xc_), yc(yc_), zc(zc_), ac(ac_) {}
+		bool point_inside(double x,double y,double z);
+		template<class v_cell>
+		bool cut_cell_base(v_cell &c,double x,double y,double z);
+		bool cut_cell(voronoicell &c,double x,double y,double z) {return cut_cell_base(c,x,y,z);}
+		bool cut_cell(voronoicell_neighbor &c,double x,double y,double z) {return cut_cell_base(c,x,y,z);}
+	private:
+		const int w_id;
+		const double xc,yc,zc,ac;
+};
+
+/** \brief A class representing a cylindrical wall object.
+ *
+ * This class represents a open cylinder wall object. */
+struct wall_cylinder : public wall {
+	public:
+		/** Constructs a cylinder wall object.
+		 * \param[in] (xc_,yc_,zc_) a point on the axis of the
+		 *			    cylinder.
+		 * \param[in] (xa_,ya_,za_) a vector pointing along the
+		 *			    direction of the cylinder.
+		 * \param[in] rc_ the radius of the cylinder
+		 * \param[in] w_id_ an ID number to associate with the wall for
+		 *		    neighbor tracking. */
+		wall_cylinder(double xc_,double yc_,double zc_,double xa_,double ya_,double za_,double rc_,int w_id_=-99)
+			: w_id(w_id_), xc(xc_), yc(yc_), zc(zc_), xa(xa_), ya(ya_), za(za_),
+			asi(1/(xa_*xa_+ya_*ya_+za_*za_)), rc(rc_) {}
+		bool point_inside(double x,double y,double z);
+		template<class v_cell>
+		bool cut_cell_base(v_cell &c,double x,double y,double z);
+		bool cut_cell(voronoicell &c,double x,double y,double z) {return cut_cell_base(c,x,y,z);}
+		bool cut_cell(voronoicell_neighbor &c,double x,double y,double z) {return cut_cell_base(c,x,y,z);}
+	private:
+		const int w_id;
+		const double xc,yc,zc,xa,ya,za,asi,rc;
+};
+
+
+/** \brief A class representing a conical wall object.
+ *
+ * This class represents a cone wall object. */
+struct wall_cone : public wall {
+	public:
+		/** Constructs a cone wall object.
+		 * \param[in] (xc_,yc_,zc_) the apex of the cone.
+		 * \param[in] (xa_,ya_,za_) a vector pointing along the axis of
+		 *			    the cone.
+		 * \param[in] ang the angle (in radians) of the cone, measured
+		 *		  from the axis.
+		 * \param[in] w_id_ an ID number to associate with the wall for
+		 *		    neighbor tracking. */
+		wall_cone(double xc_,double yc_,double zc_,double xa_,double ya_,double za_,double ang,int w_id_=-99)
+			: w_id(w_id_), xc(xc_), yc(yc_), zc(zc_), xa(xa_), ya(ya_), za(za_),
+			asi(1/(xa_*xa_+ya_*ya_+za_*za_)),
+			gra(tan(ang)), sang(sin(ang)), cang(cos(ang)) {}
+		bool point_inside(double x,double y,double z);
+		template<class v_cell>
+		bool cut_cell_base(v_cell &c,double x,double y,double z);
+		bool cut_cell(voronoicell &c,double x,double y,double z) {return cut_cell_base(c,x,y,z);}
+		bool cut_cell(voronoicell_neighbor &c,double x,double y,double z) {return cut_cell_base(c,x,y,z);}
+	private:
+		const int w_id;
+		const double xc,yc,zc,xa,ya,za,asi,gra,sang,cang;
+};
+
+}
+
+#endif
diff -ru --new-file blender-2.76b.old/extern/voro++/src/worklist_gen.pl blender-2.76b/extern/voro++/src/worklist_gen.pl
--- blender-2.76b.old/extern/voro++/src/worklist_gen.pl	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/worklist_gen.pl	2016-01-27 19:13:14.159985261 +0300
@@ -0,0 +1,236 @@
+#!/usr/bin/perl
+# Voro++, a 3D cell-based Voronoi library
+#
+# Author   : Chris H. Rycroft (LBL / UC Berkeley)
+# Email    : chr@alum.mit.edu
+# Date     : August 30th 2011
+#
+# worklist_gen.pl - this perl script is used to automatically generate the
+# worklists of blocks that are stored in worklist.cc, that are used by the
+# compute_cell() routine to ensure maximum efficiency
+
+# Each region is divided into a grid of subregions, and a worklist is
+# constructed for each. This parameter sets is set to half the number of
+# subregions that the block is divided into.
+$hr=4;
+
+# This parameter is automatically set to the the number of subregions that the
+# block is divided into
+$r=$hr*2;
+
+# This parameter sets the total number of block entries in each worklist
+$ls=63;
+
+# When the worklists are being constructed, a mask array is made use of. To
+# prevent the creation of array elements with negative indices, this parameter
+# sets an arbitrary displacement.
+$dis=8;
+
+# Constants used mask indexing
+$d=2*$dis+1;$dd=$d*$d;$d0=(1+$d+$dd)*$dis;
+
+use Math::Trig;
+
+# Construct the worklist header file, based on the parameters above
+open W,">worklist.hh";
+print W <<EOF;
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr\@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \\file worklist.hh
+ * \\brief Header file for setting constants used in the block worklists that are
+ * used during cell computation.
+ *
+ * This file is automatically generated by worklist_gen.pl and it is not
+ * intended to be edited by hand. */
+
+#ifndef VOROPP_WORKLIST_HH
+#define VOROPP_WORKLIST_HH
+
+namespace voro {
+
+/** Each region is divided into a grid of subregions, and a worklist is
+# constructed for each. This parameter sets is set to half the number of
+# subregions that the block is divided into. */
+EOF
+print W "const int wl_hgrid=$hr;\n";
+print W <<EOF;
+/** The number of subregions that a block is subdivided into, which is twice
+the value of hgrid. */
+EOF
+print W "const int wl_fgrid=$r;\n";
+print W <<EOF;
+/** The total number of worklists, set to the cube of hgrid. */
+EOF
+printf W "const int wl_hgridcu=%d;\n",$hr*$hr*$hr;
+print W <<EOF;
+/** The number of elements in each worklist. */
+EOF
+printf W "const int wl_seq_length=%d;\n",$ls+1;
+print W <<EOF;
+
+}
+#endif
+EOF
+close W;
+
+# Construct the preamble to the worklist.cc file
+open W,">v_base_wl.cc";
+print W <<EOF;
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr\@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \\file v_base_wl.cc
+ * \\brief The table of block worklists that are used during the cell
+ * computation, which is part of the voro_base class.
+ *
+ * This file is automatically generated by worklist_gen.pl and it is not
+ * intended to be edited by hand. */
+
+EOF
+printf W "const unsigned int voro_base::wl[wl_seq_length*wl_hgridcu]={\n";
+
+# Now create a worklist for each subregion
+for($kk=0;$kk<$hr;$kk++) {
+	for($jj=0;$jj<$hr;$jj++) {
+		for($ii=0;$ii<$hr;$ii++) {
+			worklist($ii,$jj,$kk);
+		}
+	}
+}
+
+# Finish the file and close it
+print W "};\n";
+close W;
+
+# A subroutine
+sub worklist {
+#	print "@_[0] @_[1] @_[2]\n";
+	$ind=@_[0]+$hr*(@_[1]+$hr*@_[2]);
+	$ac=0;$v+=2;
+	$xp=$yp=$zp=0;
+	$x=(@_[0]+0.5)/$r;
+	$y=(@_[1]+0.5)/$r;
+	$z=(@_[2]+0.5)/$r;
+	$m[$d0]=$v;
+	add(1,0,0);add(0,1,0);add(0,0,1);
+	add(-1,0,0);add(0,-1,0);add(0,0,-1);
+	foreach $l (1..$ls) {
+		$minwei=1e9;
+		foreach (0..$ac-1) {
+			$xt=@a[3*$_];$yt=@a[3*$_+1];$zt=@a[3*$_+2];
+#			$wei=dis($x,$y,$z,$xt,$yt,$zt)+1*acos(($xt*$xp+$yt*$yp+$zt*$zp)/($xt*$xt+$yt*$yt+$zt*$zt)*($xp*$xp+$yp*$yp+$zp*$zp));
+			$wei=adis($x,$y,$z,$xt,$yt,$zt)+0.02*sqrt(($xt-$xp)**2+($yt-$yp)**2+($zt-$zp)**2);
+			$nx=$_,$minwei=$wei if $wei<$minwei;
+		}
+		$xp=@a[3*$nx];$yp=@a[3*$nx+1];$zp=@a[3*$nx+2];
+		add($xp+1,$yp,$zp);add($xp,$yp+1,$zp);add($xp,$yp,$zp+1);
+		add($xp-1,$yp,$zp);add($xp,$yp-1,$zp);add($xp,$yp,$zp-1);
+#		print "=> $l $xp $yp $zp\n" if $l<4;
+		push @b,(splice @a,3*$nx,3);$ac--;
+	}
+
+	# Mark all blocks that are on this worklist entry
+	$m[$d0]=++$v;
+	for($i=0;$i<$#b;$i+=3) {
+		$xt=$b[$i];$yt=$b[$i+1];$zt=$b[$i+2];
+		$m[$d0+$xt+$d*$yt+$dd*$zt]=$v;
+	}
+
+	# Find which neighboring outside blocks need to be marked when
+	# considering this block, being as conservative as possible by
+	# overwriting the marks, so that the last possible entry that can reach
+	# a block is used
+	for($i=$j=0;$i<$#b;$i+=3,$j++) {
+		$xt=$b[$i];$yt=$b[$i+1];$zt=$b[$i+2];
+		$k=$d0+$xt+$yt*$d+$zt*$dd;
+		$la[$k+1]=$j, $m[$k+1]=$v+1 if $xt>=0 && $m[$k+1]!=$v;
+		$la[$k+$d]=$j, $m[$k+$d]=$v+1 if $yt>=0 && $m[$k+$d]!=$v;
+		$la[$k+$dd]=$j, $m[$k+$dd]=$v+1 if $zt>=0 && $m[$k+$dd]!=$v;
+		$la[$k-1]=$j, $m[$k-1]=$v+1 if $xt<=0 && $m[$k-1]!=$v;
+		$la[$k-$d]=$j, $m[$k-$d]=$v+1 if $yt<=0 && $m[$k-$d]!=$v;
+		$la[$k-$dd]=$j, $m[$k-$dd]=$v+1 if $zt<=0 && $m[$k-$dd]!=$v;
+	}
+
+	# Scan to ensure that no neighboring blocks have been missed by the
+	# outwards-looking logic in the above section
+	for($i=0;$i<$#b;$i+=3) {
+		wl_check($d0+$b[$i]+$b[$i+1]*$d+$b[$i+2]*$dd);
+	}
+
+	# Compute the number of entries where outside blocks do not need to be
+	# consider
+	for($i=$j=0;$i<$#b;$i+=3,$j++) {
+		$k=$d0+$b[$i]+$b[$i+1]*$d+$b[$i+2]*$dd;
+		last if $m[$k+1]!=$v;
+		last if $m[$k+$d]!=$v;
+		last if $m[$k+$dd]!=$v;
+		last if $m[$k-1]!=$v;
+		last if $m[$k-$d]!=$v;
+		last if $m[$k-$dd]!=$v;
+	}
+	print W "\t$j";
+
+	# Create worklist entry and save to file
+	$j=0;
+	while ($#b>0) {
+		$xt=shift @b;$yt=shift @b;$zt=shift @b;
+		$k=$d0+$xt+$yt*$d+$zt*$dd;
+		$o=0;
+		$o|=1 if $m[$k+1]!=$v && $la[$k+1]==$j;
+		$o^=3 if $m[$k-1]!=$v && $la[$k-1]==$j;
+		$o|=8 if $m[$k+$d]!=$v && $la[$k+$d]==$j;
+		$o^=24 if $m[$k-$d]!=$v && $la[$k-$d]==$j;
+		$o|=64 if $m[$k+$dd]!=$v && $la[$k+$dd]==$j;
+		$o^=192 if $m[$k-$dd]!=$v && $la[$k-$dd]==$j;
+		printf W ",%#x",(($xt+64)|($yt+64)<<7|($zt+64)<<14|$o<<21);
+		$j++;
+	}
+	print W "," unless $ind==$hr*$hr*$hr-1;
+	print W "\n";
+
+	# Remove list memory
+	undef @a;
+	undef @b;
+}
+
+sub add {
+	if ($m[$d0+@_[0]+$d*@_[1]+$dd*@_[2]]!=$v) {
+		$ac++;
+		push @a,@_[0],@_[1],@_[2];
+		$m[$d0+@_[0]+$d*@_[1]+$dd*@_[2]]=$v;
+	}
+}
+
+sub dis {
+	$xl=@_[3]+0.3-@_[0];$xh=@_[3]+0.7-@_[0];
+	$yl=@_[4]+0.3-@_[1];$yh=@_[4]+0.7-@_[1];
+	$zl=@_[5]+0.3-@_[2];$zh=@_[5]+0.7-@_[2];
+	$dis=(abs($xl)<abs($xh)?$xl:$xh)**2
+		+(abs($yl)<abs($yh)?$yl:$yh)**2
+		+(abs($zl)<abs($zh)?$zl:$zh)**2;
+	return sqrt $dis;
+}
+
+sub adis {
+	$xco=$yco=$zco=0;
+	$xco=@_[0]-@_[3] if @_[3]>0;
+	$xco=@_[0]-@_[3]-1 if @_[3]<0;
+	$yco=@_[1]-@_[4] if @_[4]>0;
+	$yco=@_[1]-@_[4]-1 if @_[4]<0;
+	$zco=@_[2]-@_[5] if @_[5]>0;
+	$zco=@_[2]-@_[5]-1 if @_[5]<0;
+	return sqrt $xco*$xco+$yco*$yco+$zco*$zco;
+}
+
+sub wl_check {
+	die "Failure in worklist construction\n" if $m[@_[0]+1]<$v||$m[@_[0]-1]<$v
+						  ||$m[@_[0]+$d]<$v||$m[@_[0]-$d]<$v
+						  ||$m[@_[0]+$dd]<$v||$m[@_[0]-$dd]<$v;
+}
diff -ru --new-file blender-2.76b.old/extern/voro++/src/worklist.hh blender-2.76b/extern/voro++/src/worklist.hh
--- blender-2.76b.old/extern/voro++/src/worklist.hh	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/extern/voro++/src/worklist.hh	2016-01-27 19:12:41.425232311 +0300
@@ -0,0 +1,32 @@
+// Voro++, a 3D cell-based Voronoi library
+//
+// Author   : Chris H. Rycroft (LBL / UC Berkeley)
+// Email    : chr@alum.mit.edu
+// Date     : August 30th 2011
+
+/** \file worklist.hh
+ * \brief Header file for setting constants used in the block worklists that are
+ * used during cell computation.
+ *
+ * This file is automatically generated by worklist_gen.pl and it is not
+ * intended to be edited by hand. */
+
+#ifndef VOROPP_WORKLIST_HH
+#define VOROPP_WORKLIST_HH
+
+namespace voro {
+
+/** Each region is divided into a grid of subregions, and a worklist is
+# constructed for each. This parameter sets is set to half the number of
+# subregions that the block is divided into. */
+const int wl_hgrid=4;
+/** The number of subregions that a block is subdivided into, which is twice
+the value of hgrid. */
+const int wl_fgrid=8;
+/** The total number of worklists, set to the cube of hgrid. */
+const int wl_hgridcu=64;
+/** The number of elements in each worklist. */
+const int wl_seq_length=64;
+
+}
+#endif
diff -ru --new-file blender-2.76b.old/intern/rigidbody/rb_bullet_api.cpp blender-2.76b/intern/rigidbody/rb_bullet_api.cpp
--- blender-2.76b.old/intern/rigidbody/rb_bullet_api.cpp	2015-10-23 22:02:52.000000000 +0300
+++ blender-2.76b/intern/rigidbody/rb_bullet_api.cpp	2016-01-27 19:16:06.921682534 +0300
@@ -20,7 +20,7 @@
  *
  * The Original Code is: all of this file.
  *
- * Contributor(s): Joshua Leung, Sergej Reich
+ * Contributor(s): Joshua Leung, Sergej Reich, Martin Felke
  *
  * ***** END GPL LICENSE BLOCK *****
  */
@@ -569,6 +569,12 @@
 	body->setActivationState(ISLAND_SLEEPING);
 }
 
+int RB_body_get_activation_state(rbRigidBody* object)
+{
+	btRigidBody* body = object->body;
+	return body->getActivationState();
+}
+
 /* ............ */
 
 
@@ -997,6 +1003,13 @@
 	constraint->setEnabled(enabled);
 }
 
+int RB_constraint_is_enabled(rbConstraint *con)
+{
+	btTypedConstraint *constraint = reinterpret_cast<btTypedConstraint*>(con);
+
+	return constraint->isEnabled();
+}
+
 void RB_constraint_set_limits_hinge(rbConstraint *con, float lower, float upper)
 {
 	btHingeConstraint *constraint = reinterpret_cast<btHingeConstraint*>(con);
diff -ru --new-file blender-2.76b.old/intern/rigidbody/RBI_api.h blender-2.76b/intern/rigidbody/RBI_api.h
--- blender-2.76b.old/intern/rigidbody/RBI_api.h	2015-10-23 22:02:52.000000000 +0300
+++ blender-2.76b/intern/rigidbody/RBI_api.h	2016-01-27 19:14:30.282411024 +0300
@@ -20,7 +20,7 @@
  *
  * The Original Code is: all of this file.
  *
- * Contributor(s): Joshua Leung, Sergej Reich
+ * Contributor(s): Joshua Leung, Sergej Reich, Martin Felke
  *
  * ***** END GPL LICENSE BLOCK *****
  */
@@ -280,6 +280,7 @@
 
 /* Enable or disable constraint */
 void RB_constraint_set_enabled(rbConstraint *con, int enabled);
+int RB_constraint_is_enabled(rbConstraint *con);
 
 /* Limits */
 #define RB_LIMIT_LIN_X 0
diff -ru --new-file blender-2.76b.old/release/scripts/startup/bl_operators/presets.py blender-2.76b/release/scripts/startup/bl_operators/presets.py
--- blender-2.76b.old/release/scripts/startup/bl_operators/presets.py	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/release/scripts/startup/bl_operators/presets.py	2016-01-27 19:17:43.276956747 +0300
@@ -598,6 +598,52 @@
             keyconfigs.remove(keyconfigs.active)
 
 
+class AddPresetFracture(AddPresetBase, Operator):
+    """Add or remove a Fracture Preset"""
+    bl_idname = "fracture.preset_add"
+    bl_label = "Add Fracture Preset"
+    preset_menu = "FRACTURE_MT_presets"
+
+    preset_defines = [
+        "fracture = bpy.context.fracture"
+    ]
+
+    preset_values = [
+        "fracture.frac_algorithm",
+        "fracture.shard_count",
+        "fracture.cluster_count",
+        "fracture.point_seed",
+        "fracture.shards_to_islands",
+        "fracture.auto_execute",
+        "fracture.use_constraints",
+        "fracture.constraint_limit",
+        "fracture.contact_dist",
+        "fracture.breaking_threshold",
+        "fracture.cluster_breaking_threshold",
+        "fracture.point_source",
+        "fracture.extra_group",
+        "fracture.dm_group",
+        "fracture.use_particle_birth_coordinates",
+        "fracture.percentage",
+        "fracture.breaking_percentage",
+        "fracture.breaking_percentage_weighted",
+        "fracture.breaking_angle",
+        "fracture.breaking_angle_weighted",
+        "fracture.breaking_distance",
+        "fracture.breaking_distance_weighted",
+        "fracture.solver_iterations_override",
+        "fracture.use_mass_dependent_thresholds",
+        "fracture.thresh_vertex_group",
+        "fracture.ground_vertex_group",
+        "fracture.inner_vertex_group",
+        "fracture.autohide_dist",
+        "fracture.fix_normals",
+        "fracture.execute_threaded"
+    ]
+
+    preset_subdir = "fracture"
+
+
 class AddPresetOperator(AddPresetBase, Operator):
     """Add or remove an Operator Preset"""
     bl_idname = "wm.operator_preset_add"
diff -ru --new-file blender-2.76b.old/release/scripts/startup/bl_operators/rigidbody.py blender-2.76b/release/scripts/startup/bl_operators/rigidbody.py
--- blender-2.76b.old/release/scripts/startup/bl_operators/rigidbody.py	2015-10-23 22:02:52.000000000 +0300
+++ blender-2.76b/release/scripts/startup/bl_operators/rigidbody.py	2016-01-27 19:20:52.935529751 +0300
@@ -114,6 +114,13 @@
         obj = context.object
         return (obj and obj.rigid_body)
 
+    def has_fracture_modifier(self, ob):
+        for m in ob.modifiers:
+            if m.type == 'FRACTURE':
+               self.report({'WARNING'}, "Object '%s' has a fracture modifier, use 'Convert to Objects' before 'Bake to Keyframes'" % ob.name)
+               return True
+        return False
+
     def execute(self, context):
         bake = []
         objects = []
@@ -122,10 +129,13 @@
         frames_step = range(self.frame_start, self.frame_end + 1, self.step)
         frames_full = range(self.frame_start, self.frame_end + 1)
 
+        constraints = []
         # filter objects selection
         for obj in context.selected_objects:
-            if not obj.rigid_body or obj.rigid_body.type != 'ACTIVE':
+            if (not obj.rigid_body or obj.rigid_body.type != 'ACTIVE' or self.has_fracture_modifier(obj)):
                 obj.select = False
+            if (obj.rigid_body_constraint):
+                constraints.append(obj)
 
         objects = context.selected_objects
 
@@ -171,6 +181,16 @@
 
                 bpy.ops.anim.keyframe_insert(type='BUILTIN_KSI_LocRot', confirm_success=False)
 
+            #remove (selected) constraints first
+            for obj in constraints:
+                obj.select = True
+
+            bpy.ops.rigidbody.constraints_remove()
+
+            for obj in constraints:
+                obj.select = False
+                obj.hide = True
+
             # remove baked objects from simulation
             bpy.ops.rigidbody.objects_remove()
 
diff -ru --new-file blender-2.76b.old/release/scripts/startup/bl_ui/__init__.py blender-2.76b/release/scripts/startup/bl_ui/__init__.py
--- blender-2.76b.old/release/scripts/startup/bl_ui/__init__.py	2015-10-27 19:57:22.000000000 +0300
+++ blender-2.76b/release/scripts/startup/bl_ui/__init__.py	2016-01-27 19:21:30.954243945 +0300
@@ -51,6 +51,7 @@
     "properties_physics_dynamicpaint",
     "properties_physics_field",
     "properties_physics_fluid",
+    "properties_physics_fracture",
     "properties_physics_rigidbody",
     "properties_physics_rigidbody_constraint",
     "properties_physics_smoke",
diff -ru --new-file blender-2.76b.old/release/scripts/startup/bl_ui/properties_data_modifier.py blender-2.76b/release/scripts/startup/bl_ui/properties_data_modifier.py
--- blender-2.76b.old/release/scripts/startup/bl_ui/properties_data_modifier.py	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/release/scripts/startup/bl_ui/properties_data_modifier.py	2016-01-27 20:15:02.022125024 +0300
@@ -365,6 +365,9 @@
     def FLUID_SIMULATION(self, layout, ob, md):
         layout.label(text="Settings are inside the Physics tab")
 
+    def FRACTURE(self, layout, ob, md):
+        layout.label(text="Settings are inside the Physics tab")
+
     def HOOK(self, layout, ob, md):
         use_falloff = (md.falloff_type != 'NONE')
         split = layout.split()
diff -ru --new-file blender-2.76b.old/release/scripts/startup/bl_ui/properties_physics_common.py blender-2.76b/release/scripts/startup/bl_ui/properties_physics_common.py
--- blender-2.76b.old/release/scripts/startup/bl_ui/properties_physics_common.py	2015-10-27 19:57:22.000000000 +0300
+++ blender-2.76b/release/scripts/startup/bl_ui/properties_physics_common.py	2016-01-27 20:16:25.592498591 +0300
@@ -75,6 +75,10 @@
             physics_add(self, col, context.collision, "Collision", 'COLLISION', 'MOD_PHYSICS', False)
             physics_add(self, col, context.cloth, "Cloth", 'CLOTH', 'MOD_CLOTH', True)
             physics_add(self, col, context.dynamic_paint, "Dynamic Paint", 'DYNAMIC_PAINT', 'MOD_DYNAMICPAINT', True)
+            physics_add(self, col, context.fracture, "Fracture", 'FRACTURE', 'MOD_EXPLODE', True)
+
+        if obj.type == 'CURVE' or obj.type == 'SURFACE' or obj.type == 'FONT':
+            physics_add(self, col, context.fracture, "Fracture", 'FRACTURE', 'MOD_EXPLODE', True)
 
         col = split.column()
 
@@ -88,6 +92,12 @@
             physics_add_special(self, col, obj.rigid_body, "Rigid Body",
                                 "rigidbody.object_add",
                                 "rigidbody.object_remove",
+                                'MESH_ICOSPHERE')  # XXX: need dedicated icon
+
+        if obj.type == 'CURVE' or obj.type == 'SURFACE' or obj.type == 'FONT': #works with fracture modifier
+            physics_add_special(self, col, obj.rigid_body, "Rigid Body",
+                                "rigidbody.object_add",
+                                "rigidbody.object_remove",
                                 'MESH_ICOSPHERE')  # XXX: need dedicated icon
 
         # all types of objects can have rigid body constraint
diff -ru --new-file blender-2.76b.old/release/scripts/startup/bl_ui/properties_physics_fracture.py blender-2.76b/release/scripts/startup/bl_ui/properties_physics_fracture.py
--- blender-2.76b.old/release/scripts/startup/bl_ui/properties_physics_fracture.py	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/release/scripts/startup/bl_ui/properties_physics_fracture.py	2016-01-27 20:17:00.300238483 +0300
@@ -0,0 +1,156 @@
+# ##### BEGIN GPL LICENSE BLOCK #####
+#
+#  This program is free software; you can redistribute it and/or
+#  modify it under the terms of the GNU General Public License
+#  as published by the Free Software Foundation; either version 2
+#  of the License, or (at your option) any later version.
+#
+#  This program is distributed in the hope that it will be useful,
+#  but WITHOUT ANY WARRANTY; without even the implied warranty of
+#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+#  GNU General Public License for more details.
+#
+#  You should have received a copy of the GNU General Public License
+#  along with this program; if not, write to the Free Software Foundation,
+#  Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+#
+# ##### END GPL LICENSE BLOCK #####
+
+# <pep8 compliant>
+import bpy
+from bpy.types import Panel, Menu, UIList
+from bpy.app.translations import pgettext_iface as iface_
+
+
+class FLUID_MT_presets(Menu):
+    bl_label = "Fluid Presets"
+    preset_subdir = "fluid"
+    preset_operator = "script.execute_preset"
+    draw = Menu.draw_preset
+
+class FRACTURE_MT_presets(Menu):
+    bl_label = "Fracture Presets"
+    preset_subdir = "fracture"
+    preset_operator = "script.execute_preset"
+    draw = Menu.draw_preset
+
+
+class PhysicButtonsPanel():
+    bl_space_type = 'PROPERTIES'
+    bl_region_type = 'WINDOW'
+    bl_context = "physics"
+
+    @classmethod
+    def poll(cls, context):
+        ob = context.object
+        rd = context.scene.render
+        return (ob and (ob.type == 'MESH' or ob.type == 'CURVE' or ob.type == 'SURFACE' or ob.type == 'FONT')) and (not rd.use_game_engine) and (context.fracture)
+
+class FRACTURE_UL_fracture_levels(UIList):
+    def draw_item(self, context, layout, data, item, icon, active_data, active_propname, index):
+        fl = item
+        if self.layout_type in {'DEFAULT', 'COMPACT'}:
+            layout.prop(fl, "name", text="", emboss=False, icon_value=icon)
+        elif self.layout_type in {'GRID'}:
+            layout.alignment = 'CENTER'
+            layout.label(text="", icon_value=icon)
+
+class PHYSICS_PT_fracture(PhysicButtonsPanel, Panel):
+    bl_label = "Fracture"
+
+    def icon(self, bool):
+        if bool:
+            return 'TRIA_DOWN'
+        else:
+            return 'TRIA_RIGHT'
+
+    def draw(self, context):
+        layout = self.layout
+
+        md = context.fracture
+
+        layout.label(text="Presets:")
+        sub = layout.row(align=True)
+        sub.menu("FRACTURE_MT_presets", text=bpy.types.FRACTURE_MT_presets.bl_label)
+        sub.operator("fracture.preset_add", text="", icon='ZOOMIN')
+        sub.operator("fracture.preset_add", text="", icon='ZOOMOUT').remove_active = True
+
+        layout.prop(md, "frac_algorithm")
+        col = layout.column(align=True)
+        col.prop(md, "shard_count")
+        col.prop(md, "cluster_count")
+        col.prop(md, "point_seed")
+        if md.frac_algorithm == 'BOOLEAN' or md.frac_algorithm == 'BISECT_FILL' or md.frac_algorithm == 'BISECT_FAST_FILL':
+            layout.prop(md, "inner_material")
+        row = layout.row()
+        row.prop(md, "shards_to_islands")
+        row.prop(md, "auto_execute")
+        layout.operator("object.fracture_refresh", text="Execute Fracture")
+
+class PHYSICS_PT_fracture_simulation(PhysicButtonsPanel, Panel):
+    bl_label = "Fracture Simulation"
+
+    def icon(self, bool):
+        if bool:
+            return 'TRIA_DOWN'
+        else:
+            return 'TRIA_RIGHT'
+
+    def draw(self, context):
+        layout = self.layout
+        md = context.fracture
+        ob = context.object
+
+        #layout.operator("object.rigidbody_constraints_refresh", text="Refresh Constraints Only")
+        layout.label("Constraint Building Settings")
+        layout.prop(md, "use_constraints")
+        col = layout.column(align=True)
+        col.prop(md, "constraint_limit", text="Constraint limit, per MeshIsland")
+        col.prop(md, "contact_dist")
+        layout.label("Constraint Breaking Settings")
+        col = layout.column(align=True)
+        col.prop(md, "breaking_threshold", text="Threshold")
+        col.prop(md, "cluster_breaking_threshold")
+
+        #experimental stuff
+        box = layout.box()
+        box.prop(md, "use_experimental", text="Experimental, use with caution !", icon=self.icon(md.use_experimental), emboss = False)
+        if md.use_experimental:
+            box.label("Fracture Point Source:")
+            box.prop(md, "point_source")
+            box.prop(md, "extra_group")
+            box.prop(md, "dm_group")
+            box.prop(md, "use_particle_birth_coordinates")
+
+            box.prop(md, "percentage")
+            box.label("Constraint Breaking Settings")
+            col = box.column(align=True)
+            row = col.row()
+            row.prop(md, "breaking_percentage", text="Percentage")
+            row.prop(md, "breaking_percentage_weighted")
+
+            row = col.row()
+            row.prop(md, "breaking_angle", text="Angle")
+            row.prop(md, "breaking_angle_weighted")
+
+            row = col.row()
+            row.prop(md, "breaking_distance", text="Distance")
+            row.prop(md, "breaking_distance_weighted")
+
+            box.prop(md, "solver_iterations_override")
+            box.prop(md, "use_mass_dependent_thresholds")
+            box.label("Threshold Vertex Group:")
+            box.prop_search(md, "thresh_vertex_group", ob, "vertex_groups", text = "")
+            box.label("Passive Vertex Group:")
+            box.prop_search(md, "ground_vertex_group", ob, "vertex_groups", text = "")
+            box.label("Inner Vertex Group:")
+            box.prop_search(md, "inner_vertex_group", ob, "vertex_groups", text = "")
+            box.prop(md, "autohide_dist")
+
+            box.prop(md, "fix_normals");
+            if not(md.refresh):
+                box.prop(md, "execute_threaded")
+            box.operator("object.rigidbody_convert_to_objects", text = "Convert To Objects")
+
+if __name__ == "__main__":  # only for live edit.
+    bpy.utils.register_module(__name__)
diff -ru --new-file blender-2.76b.old/SConstruct blender-2.76b/SConstruct
--- blender-2.76b.old/SConstruct	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/SConstruct	2016-01-27 18:45:36.835366882 +0300
@@ -265,6 +265,7 @@
     target_env_defs['WITH_BF_SMOKE'] = False
     target_env_defs['WITH_BF_BOOLEAN'] = False
     target_env_defs['WITH_BF_REMESH'] = False
+    target_env_defs['WITH_BF_VORONOI'] = False
     target_env_defs['WITH_BF_PYTHON'] = False
     target_env_defs['WITH_BF_IME'] = False
     target_env_defs['WITH_BF_3DMOUSE'] = False
diff -ru --new-file blender-2.76b.old/source/blender/blenkernel/BKE_deform.h blender-2.76b/source/blender/blenkernel/BKE_deform.h
--- blender-2.76b.old/source/blender/blenkernel/BKE_deform.h	2015-10-30 23:31:41.000000000 +0300
+++ blender-2.76b/source/blender/blenkernel/BKE_deform.h	2016-01-27 20:17:24.720055495 +0300
@@ -28,6 +28,8 @@
 #ifndef __BKE_DEFORM_H__
 #define __BKE_DEFORM_H__
 
+#include "DNA_object_types.h"
+
 /** \file BKE_deform.h
  *  \ingroup bke
  *  \since June 2001
diff -ru --new-file blender-2.76b.old/source/blender/blenkernel/BKE_fracture.h blender-2.76b/source/blender/blenkernel/BKE_fracture.h
--- blender-2.76b.old/source/blender/blenkernel/BKE_fracture.h	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/source/blender/blenkernel/BKE_fracture.h	2016-01-27 20:17:52.683845970 +0300
@@ -0,0 +1,89 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) Blender Foundation
+ * All rights reserved.
+ *
+ * The Original Code is: all of this file.
+ *
+ * Contributor(s): Martin Felke
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+/** \file blender/blenkernel/BKE_fracture.h
+ *  \ingroup blenkernel
+ */
+
+#ifndef BKE_FRACTURE_H
+#define BKE_FRACTURE_H
+
+#include "BLI_sys_types.h"
+
+struct FracMesh;
+struct Shard;
+
+struct FractureModifierData;
+struct DerivedMesh;
+struct Object;
+
+struct BoundBox;
+struct MVert;
+struct MPoly;
+struct MLoop;
+
+typedef int ShardID;
+
+typedef struct FracPoint {
+	float co[3];
+} FracPoint;
+
+typedef struct FracPointCloud {
+	struct FracPoint *points;   /* just a bunch of positions in space*/
+	int totpoints; /* number of positions */
+} FracPointCloud;
+
+/* direct access */
+struct Shard *BKE_shard_by_id(struct FracMesh *mesh, ShardID id, struct DerivedMesh *dm);
+
+/* detailed info to the particular shards */
+void BKE_get_shard_minmax(struct FracMesh *mesh, ShardID id, float min_r[3], float max_r[3], struct DerivedMesh *dm);
+
+/* container object handling functions */
+struct FracMesh *BKE_create_fracture_container(void);
+struct Shard *BKE_create_fracture_shard(struct MVert *mvert, struct MPoly *mpoly, struct MLoop *mloop, int totvert, int totpoly, int totloop, bool copy);
+struct Shard *BKE_custom_data_to_shard(struct Shard *s, struct DerivedMesh *dm);
+
+/* utility functions */
+bool BKE_fracture_shard_center_median(struct Shard *shard, float cent[3]);
+bool BKE_fracture_shard_center_centroid(struct Shard *shard, float cent[3]);
+float BKE_shard_calc_minmax(struct Shard *shard);
+
+void BKE_fracmesh_free(struct FracMesh *fm, bool doCustomData);
+void BKE_shard_free(struct Shard *s, bool doCustomData);
+
+
+/* DerivedMesh */
+void BKE_fracture_create_dm(struct FractureModifierData *fmd, bool doCustomData);
+struct DerivedMesh *BKE_shard_create_dm(struct Shard *s, bool doCustomData);
+
+/* create shards from base mesh and a liste of points */
+void BKE_fracture_shard_by_points(struct FracMesh *fmesh, ShardID id, struct FracPointCloud *points, int algorithm, struct Object *obj, struct DerivedMesh *dm,
+                                  short inner_material_index);
+
+
+#endif /* BKE_FRACTURE_H */
diff -ru --new-file blender-2.76b.old/source/blender/blenkernel/BKE_fracture_util.h blender-2.76b/source/blender/blenkernel/BKE_fracture_util.h
--- blender-2.76b.old/source/blender/blenkernel/BKE_fracture_util.h	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/source/blender/blenkernel/BKE_fracture_util.h	2016-01-27 20:18:15.411674545 +0300
@@ -0,0 +1,43 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) Blender Foundation
+ * All rights reserved.
+ *
+ * The Original Code is: all of this file.
+ *
+ * Contributor(s): Martin Felke
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+/** \file blender/blenkernel/BKE_fracture_util.h
+ *  \ingroup blenkernel
+ *  \brief CSG operations
+ */
+
+#ifndef BKE_FRACTURE_UTIL_H
+#define BKE_FRACTURE_UTIL_H
+
+#include "DNA_fracture_types.h"
+
+Shard *BKE_fracture_shard_boolean(Object *obj, DerivedMesh *dm_parent, Shard* child, short inner_material_index);
+Shard *BKE_fracture_shard_bisect(struct BMesh *bm_orig, Shard* child, float obmat[4][4], bool use_fill,
+                                 bool clear_inner, bool clear_outer, int cutlimit, float centroid[],
+                                 short inner_mat_index);
+
+#endif /* BKE_FRACTURE_UTIL_H*/
diff -ru --new-file blender-2.76b.old/source/blender/blenkernel/BKE_rigidbody.h blender-2.76b/source/blender/blenkernel/BKE_rigidbody.h
--- blender-2.76b.old/source/blender/blenkernel/BKE_rigidbody.h	2015-11-04 13:02:14.000000000 +0300
+++ blender-2.76b/source/blender/blenkernel/BKE_rigidbody.h	2016-01-27 20:20:55.305462378 +0300
@@ -36,9 +36,12 @@
 
 struct RigidBodyWorld;
 struct RigidBodyOb;
+struct RigidBodyShardCon;
 
 struct Scene;
 struct Object;
+struct MeshIsland;
+struct FractureModifierData;
 
 /* -------------- */
 /* Memory Management */
@@ -60,15 +63,25 @@
 struct RigidBodyWorld *BKE_rigidbody_create_world(struct Scene *scene);
 struct RigidBodyOb *BKE_rigidbody_create_object(struct Scene *scene, struct Object *ob, short type);
 struct RigidBodyCon *BKE_rigidbody_create_constraint(struct Scene *scene, struct Object *ob, short type);
-
+struct RigidBodyOb *BKE_rigidbody_create_shard(struct Scene *scene, struct Object *ob, struct MeshIsland *mi);
+struct RigidBodyShardCon *BKE_rigidbody_create_shard_constraint(struct Scene *scene, short type);
 /* copy */
 struct RigidBodyWorld *BKE_rigidbody_world_copy(struct RigidBodyWorld *rbw);
 void BKE_rigidbody_world_groups_relink(struct RigidBodyWorld *rbw);
 
 /* 'validate' (i.e. make new or replace old) Physics-Engine objects */
 void BKE_rigidbody_validate_sim_world(struct Scene *scene, struct RigidBodyWorld *rbw, bool rebuild);
+void BKE_rigidbody_validate_sim_object(struct RigidBodyWorld *rbw, struct Object *ob, short rebuild);
+void BKE_rigidbody_validate_sim_shape(struct Object *ob, short rebuild);
+void BKE_rigidbody_validate_sim_constraint(struct RigidBodyWorld *rbw, struct Object *ob, short rebuild);
+void BKE_rigidbody_validate_sim_shard_constraint(struct RigidBodyWorld *rbw, struct RigidBodyShardCon *rbsc, short rebuild);
+
+void BKE_rigidbody_validate_sim_shard(struct RigidBodyWorld *rbw, struct MeshIsland *mi, struct Object *ob, short rebuild);
+void BKE_rigidbody_validate_sim_shard_shape(struct MeshIsland *mi, struct Object *ob, short rebuild);
+
+/* move the islands of the visible mesh according to shard rigidbody movement */
+void BKE_rigidbody_update_cell(struct MeshIsland *mi, struct Object* ob, float loc[3], float rot[4], struct FractureModifierData *rmd);
 
-void BKE_rigidbody_calc_volume(struct Object *ob, float *r_vol);
 void BKE_rigidbody_calc_center_of_mass(struct Object *ob, float r_center[3]);
 
 /* -------------- */
@@ -77,7 +90,14 @@
 struct RigidBodyWorld *BKE_rigidbody_get_world(struct Scene *scene);
 void BKE_rigidbody_remove_object(struct Scene *scene, struct Object *ob);
 void BKE_rigidbody_remove_constraint(struct Scene *scene, struct Object *ob);
-
+float BKE_rigidbody_calc_volume(struct DerivedMesh *dm, struct RigidBodyOb *rbo);
+void BKE_rigidbody_calc_shard_mass(struct Object* ob, struct MeshIsland* mi, struct DerivedMesh* dm);
+void BKE_rigidbody_calc_threshold(float max_con_mass, struct FractureModifierData* rmd, struct RigidBodyShardCon *con);
+float BKE_rigidbody_calc_max_con_mass(struct Object* ob);
+float BKE_rigidbody_calc_min_con_dist(struct Object* ob);
+void BKE_rigidbody_start_dist_angle(struct RigidBodyShardCon* con);
+void BKE_rigidbody_remove_shard_con(struct Scene* scene, struct RigidBodyShardCon* con);
+void BKE_rigidbody_remove_shard(struct Scene* scene, struct MeshIsland *mi);
 /* -------------- */
 /* Utility Macros */
 
diff -ru --new-file blender-2.76b.old/source/blender/blenkernel/CMakeLists.txt blender-2.76b/source/blender/blenkernel/CMakeLists.txt
--- blender-2.76b.old/source/blender/blenkernel/CMakeLists.txt	2016-01-27 18:39:43.679007922 +0300
+++ blender-2.76b/source/blender/blenkernel/CMakeLists.txt	2016-01-27 20:22:30.307742538 +0300
@@ -106,6 +106,8 @@
 	intern/fluidsim.c
 	intern/fmodifier.c
 	intern/font.c
+	intern/fracture.c
+	intern/fracture_util.c
 	intern/freestyle.c
 	intern/gpencil.c
 	intern/group.c
@@ -225,6 +227,8 @@
 	BKE_fcurve.h
 	BKE_fluidsim.h
 	BKE_font.h
+	BKE_fracture.h
+	BKE_fracture_util.h
 	BKE_freestyle.h
 	BKE_global.h
 	BKE_gpencil.h
@@ -518,6 +522,14 @@
 	endif()
 endif()
 
+if(WITH_VORO)
+	add_definitions(-DWITH_VORO)
+	list(APPEND INC
+		../../../extern/voro++
+		../../../extern/carve
+	)
+endif()
+
 ## Warnings as errors, this is too strict!
 #if(MSVC)
 #	set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} /WX")
diff -ru --new-file blender-2.76b.old/source/blender/blenkernel/intern/fracture.c blender-2.76b/source/blender/blenkernel/intern/fracture.c
--- blender-2.76b.old/source/blender/blenkernel/intern/fracture.c	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/source/blender/blenkernel/intern/fracture.c	2016-01-27 20:24:02.311045683 +0300
@@ -0,0 +1,949 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) Blender Foundation
+ * All rights reserved.
+ *
+ * The Original Code is: all of this file.
+ *
+ * Contributor(s): Martin Felke
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+/** \file blender/blenkernel/intern/fracture.c
+ *  \ingroup blenkernel
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "MEM_guardedalloc.h"
+
+#include "BKE_cdderivedmesh.h"
+#include "BKE_customdata.h"
+#include "BKE_DerivedMesh.h"
+#include "BKE_fracture.h"
+#include "BKE_fracture_util.h"
+#include "BKE_global.h"
+#include "BKE_mesh.h"
+#include "BKE_object.h"
+
+#include "BLI_listbase.h"
+#include "BLI_math_vector.h"
+#include "BLI_mempool.h"
+#include "BLI_path_util.h"
+#include "BLI_rand.h"
+#include "BLI_sort.h"
+#include "BLI_utildefines.h"
+
+#include "DNA_fracture_types.h"
+#include "DNA_group_types.h"
+#include "DNA_meshdata_types.h"
+#include "DNA_modifier_types.h"
+
+#include "bmesh.h"
+
+#include "RBI_api.h"
+
+/* debug timing */
+#define USE_DEBUG_TIMER
+
+#ifdef USE_DEBUG_TIMER
+#include "PIL_time.h"
+#endif
+
+#ifdef WITH_VORO
+#include "../../../../extern/voro++/src/c_interface.hh"
+#endif
+
+/* prototypes */
+static void add_shard(FracMesh *fm, Shard *s);
+static Shard *parse_cell(cell c);
+static void parse_cell_verts(cell c, MVert *mvert, int totvert);
+static void parse_cell_polys(cell c, MPoly *mpoly, int totpoly, int *r_totloop);
+static void parse_cell_loops(cell c, MLoop *mloop, int totloop, MPoly *mpoly, int totpoly);
+static void parse_cell_neighbors(cell c, int *neighbors, int totpoly);
+
+static void add_shard(FracMesh *fm, Shard *s)
+{
+	BLI_addtail(&fm->shard_map, s);
+	s->shard_id = fm->shard_count;
+	fm->shard_count++;
+}
+
+static BMesh *shard_to_bmesh(Shard *s)
+{
+	DerivedMesh *dm_parent;
+	BMesh *bm_parent;
+	BMIter iter;
+	BMFace *f;
+
+	dm_parent = BKE_shard_create_dm(s, true);
+	bm_parent = DM_to_bmesh(dm_parent, true);
+	BM_mesh_elem_table_ensure(bm_parent, BM_FACE);
+
+	BM_ITER_MESH (f, &iter, bm_parent, BM_FACES_OF_MESH)
+	{
+		BM_elem_flag_disable(f, BM_ELEM_SELECT);
+	}
+
+	dm_parent->needsFree = 1;
+	dm_parent->release(dm_parent);
+	dm_parent = NULL;
+
+	return bm_parent;
+}
+
+static void shard_boundbox(Shard *s, float r_loc[3], float r_size[3])
+{
+	float min[3], max[3];
+	float mloc[3], msize[3];
+
+	if (!r_loc) r_loc = mloc;
+	if (!r_size) r_size = msize;
+
+	if (!BKE_shard_calc_minmax(s)) {
+		min[0] = min[1] = min[2] = -1.0f;
+		max[0] = max[1] = max[2] = 1.0f;
+	}
+
+	copy_v3_v3(max, s->max);
+	copy_v3_v3(min, s->min);
+
+	mid_v3_v3v3(r_loc, min, max);
+
+	r_size[0] = (max[0] - min[0]) / 2.0f;
+	r_size[1] = (max[1] - min[1]) / 2.0f;
+	r_size[2] = (max[2] - min[2]) / 2.0f;
+}
+
+
+static int shard_sortsize(const void *s1, const void *s2, void* UNUSED(context))
+{
+	Shard **sh1 = (Shard **)s1;
+	Shard **sh2 = (Shard **)s2;
+
+	float size1[3], size2[3], loc[3];
+	float val_a,  val_b;
+
+	if ((*sh1 == NULL) || (*sh2 == NULL)) {
+		return -1;
+	}
+
+	shard_boundbox(*sh1, loc, size1);
+	shard_boundbox(*sh2, loc, size2);
+
+	val_a = size1[0] * size1[1] * size1[2];
+	val_b = size2[0] * size2[1] * size2[2];
+
+	/* sort descending */
+	if      (val_a < val_b) return 1;
+	else if (val_a > val_b) return -1;
+	return 0;
+}
+
+Shard *BKE_custom_data_to_shard(Shard *s, DerivedMesh *dm)
+{
+	CustomData_reset(&s->vertData);
+	CustomData_reset(&s->loopData);
+	CustomData_reset(&s->polyData);
+
+	CustomData_add_layer(&s->vertData, CD_MDEFORMVERT, CD_DUPLICATE, CustomData_get_layer(&dm->vertData, CD_MDEFORMVERT), s->totvert);
+	CustomData_add_layer(&s->loopData, CD_MLOOPUV, CD_DUPLICATE, CustomData_get_layer(&dm->loopData, CD_MLOOPUV), s->totloop);
+	CustomData_add_layer(&s->polyData, CD_MTEXPOLY, CD_DUPLICATE, CustomData_get_layer(&dm->polyData, CD_MTEXPOLY), s->totpoly);
+
+	/*XXX TODO how do i use customdata PROPERLY ? */
+
+	/*CustomData_copy(&dm->vertData, &s->vertData, CD_MASK_MDEFORMVERT, CD_CALLOC, s->totvert);
+	   CustomData_copy_data(&dm->vertData, &s->vertData,
+	                     0, 0, s->totvert);
+
+	   CustomData_copy(&dm->loopData, &s->loopData, CD_MASK_MLOOPUV, CD_CALLOC, s->totloop);
+	   CustomData_copy_data(&dm->loopData, &s->loopData,
+	                     0, 0, s->totloop);
+
+	   CustomData_copy(&dm->polyData, &s->polyData, CD_MASK_MTEXPOLY, CD_CALLOC, s->totpoly);
+	   CustomData_copy_data(&dm->polyData, &s->polyData,
+	                     0, 0, s->totpoly);*/
+
+	return s;
+}
+
+/* modified from BKE_mesh_center_median */
+bool BKE_fracture_shard_center_median(Shard *shard, float cent[3])
+{
+	int i = shard->totvert;
+	MVert *mvert;
+	zero_v3(cent);
+	for (mvert = shard->mvert; i--; mvert++) {
+		add_v3_v3(cent, mvert->co);
+	}
+	/* otherwise we get NAN for 0 verts */
+	if (shard->totvert) {
+		mul_v3_fl(cent, 1.0f / (float)shard->totvert);
+	}
+
+	return (shard->totvert != 0);
+}
+
+/* modified from BKE_mesh_center_centroid */
+bool BKE_fracture_shard_center_centroid(Shard *shard, float cent[3])
+{
+	int i = shard->totpoly;
+	MPoly *mpoly;
+	float poly_area;
+	float total_area = 0.0f;
+	float poly_cent[3];
+
+	zero_v3(cent);
+
+	/* calculate a weighted average of polygon centroids */
+	for (mpoly = shard->mpoly; i--; mpoly++) {
+		BKE_mesh_calc_poly_center(mpoly, shard->mloop + mpoly->loopstart, shard->mvert, poly_cent);
+		poly_area = BKE_mesh_calc_poly_area(mpoly, shard->mloop + mpoly->loopstart, shard->mvert);
+		madd_v3_v3fl(cent, poly_cent, poly_area);
+		total_area += poly_area;
+	}
+	/* otherwise we get NAN for 0 polys */
+	if (shard->totpoly) {
+		mul_v3_fl(cent, 1.0f / total_area);
+	}
+
+	/* zero area faces cause this, fallback to median */
+	if (UNLIKELY(!is_finite_v3(cent))) {
+		return BKE_fracture_shard_center_median(shard, cent);
+	}
+	copy_v3_v3(shard->centroid, cent);
+
+	return (shard->totpoly != 0);
+}
+
+void BKE_shard_free(Shard *s, bool doCustomData)
+{
+	if (s->mvert) {
+		MEM_freeN(s->mvert);
+	}
+	if (s->mloop) {
+		MEM_freeN(s->mloop);
+	}
+	if (s->mpoly) {
+		MEM_freeN(s->mpoly);
+	}
+	if (s->neighbor_ids) {
+		MEM_freeN(s->neighbor_ids);
+	}
+	if (s->cluster_colors) {
+		MEM_freeN(s->cluster_colors);
+	}
+
+	if (doCustomData) {
+		CustomData_free(&s->vertData, s->totvert);
+		CustomData_free(&s->loopData, s->totloop);
+		CustomData_free(&s->polyData, s->totpoly);
+	}
+
+	MEM_freeN(s);
+}
+
+float BKE_shard_calc_minmax(Shard *shard)
+{
+	float min[3], max[3], diff[3];
+	int i;
+	
+	INIT_MINMAX(min, max);
+	for (i = 0; i < shard->totvert; i++) {
+		minmax_v3v3_v3(min, max, shard->mvert[i].co);
+	}
+	
+	copy_v3_v3(shard->min, min);
+	copy_v3_v3(shard->max, max);
+
+	sub_v3_v3v3(diff, max, min);
+	return len_v3(diff);
+}
+
+
+/*access shard directly by index / id*/
+Shard *BKE_shard_by_id(FracMesh *mesh, ShardID id, DerivedMesh *dm) {
+	if ((id < mesh->shard_count) && (id >= 0)) {
+		//return mesh->shard_map[id];
+		return (Shard *)BLI_findlink(&mesh->shard_map, id);
+	}
+	else if (id == -1)
+	{
+		/* create temporary shard covering the entire mesh */
+		Shard *s = BKE_create_fracture_shard(dm->getVertArray(dm), dm->getPolyArray(dm), dm->getLoopArray(dm),
+		                                     dm->numVertData, dm->numPolyData, dm->numLoopData, true);
+		s = BKE_custom_data_to_shard(s, dm);
+		s->flag = SHARD_INTACT;
+		s->shard_id = -2;
+		return s;
+	}
+	
+	return NULL;
+}
+
+void BKE_get_shard_minmax(FracMesh *mesh, ShardID id, float min_r[3], float max_r[3], DerivedMesh *dm)
+{
+	Shard *shard = BKE_shard_by_id(mesh, id, dm);
+	if (shard != NULL) {
+		copy_v3_v3(min_r, shard->min);
+		copy_v3_v3(max_r, shard->max);
+	}
+
+	if (shard->shard_id == -2)
+	{
+		BKE_shard_free(shard, true);
+	}
+}
+
+Shard *BKE_create_fracture_shard(MVert *mvert, MPoly *mpoly, MLoop *mloop, int totvert, int totpoly, int totloop, bool copy)
+{
+	Shard *shard = MEM_mallocN(sizeof(Shard), __func__);
+	shard->totvert = totvert;
+	shard->totpoly = totpoly;
+	shard->totloop = totloop;
+	shard->cluster_colors = NULL;
+	shard->neighbor_ids = NULL;
+	shard->neighbor_count = 0;
+	
+	if (copy) {
+		shard->mvert = MEM_mallocN(sizeof(MVert) * totvert, "shard vertices");
+		shard->mpoly = MEM_mallocN(sizeof(MPoly) * totpoly, "shard polys");
+		shard->mloop = MEM_mallocN(sizeof(MLoop) * totloop, "shard loops");
+		memcpy(shard->mvert, mvert, sizeof(MVert) * totvert);
+		memcpy(shard->mpoly, mpoly, sizeof(MPoly) * totpoly);
+		memcpy(shard->mloop, mloop, sizeof(MLoop) * totloop);
+	}
+	else {
+		shard->mvert = mvert;
+		shard->mpoly = mpoly;
+		shard->mloop = mloop;
+	}
+
+	shard->shard_id = -1;
+	shard->flag |= SHARD_INTACT;
+	BKE_shard_calc_minmax(shard);
+
+	BKE_fracture_shard_center_centroid(shard, shard->centroid);
+
+	return shard;
+}
+
+FracMesh *BKE_create_fracture_container(void)
+{
+	FracMesh *fmesh;
+	
+	fmesh = MEM_mallocN(sizeof(FracMesh), __func__);
+	fmesh->shard_map.first = NULL;
+	fmesh->shard_map.last = NULL;
+	fmesh->shard_count = 0;
+	fmesh->cancel = 0;
+	fmesh->running = 0;
+	fmesh->progress_counter = 0;
+	
+	return fmesh;
+}
+
+
+/* parse the voro++ cell data */
+static void parse_cells(cell *cells, int expected_shards, ShardID parent_id, FracMesh *fm, int algorithm, Object *obj, DerivedMesh *dm, short inner_material_index)
+{
+	/*Parse voronoi raw data*/
+	int i = 0;
+	Shard *s = NULL, *p = BKE_shard_by_id(fm, parent_id, dm);
+	float obmat[4][4]; /* use unit matrix for now */
+	float centroid[3];
+	BMesh *bm_parent = NULL;
+	DerivedMesh *dm_parent = NULL;
+	Shard **tempshards;
+	Shard **tempresults;
+
+	tempshards = MEM_mallocN(sizeof(Shard *) * expected_shards, "tempshards");
+	tempresults = MEM_mallocN(sizeof(Shard *) * expected_shards, "tempresults");
+
+	p->flag = 0;
+	p->flag |= SHARD_FRACTURED;
+	unit_m4(obmat);
+
+	if (algorithm == MOD_FRACTURE_BOOLEAN) {
+		MPoly *mpoly, *mp;
+		int totpoly, i;
+		dm_parent = BKE_shard_create_dm(p, true);
+		mpoly = dm_parent->getPolyArray(dm_parent);
+		totpoly = dm_parent->getNumPolys(dm_parent);
+		for (i = 0, mp = mpoly; i < totpoly; i++, mp++) {
+			mp->flag &= ~ME_FACE_SEL;
+		}
+	}
+	else if (algorithm == MOD_FRACTURE_BISECT || algorithm == MOD_FRACTURE_BISECT_FILL ||
+	         algorithm == MOD_FRACTURE_BISECT_FAST || algorithm == MOD_FRACTURE_BISECT_FAST_FILL)
+	{
+#define MYTAG (1 << 6)
+		bm_parent = shard_to_bmesh(p);
+		copy_v3_v3(centroid, p->centroid);
+	}
+
+	for (i = 0; i < expected_shards; i++) {
+		if (fm->cancel == 1) {
+			break;
+		}
+
+		printf("Parsing shard: %d\n", i);
+		s = parse_cell(cells[i]);
+		tempshards[i] = s;
+		tempresults[i] = NULL;
+		fm->progress_counter++;
+	}
+
+	if (algorithm != MOD_FRACTURE_BISECT_FAST && algorithm != MOD_FRACTURE_BISECT_FAST_FILL) {
+		for (i = 0; i < expected_shards; i++) {
+			Shard *t;
+			if (fm->cancel == 1)
+				break;
+
+			printf("Processing shard: %d\n", i);
+			t = tempshards[i];
+
+			if (t != NULL) {
+				t->parent_id = parent_id;
+				t->flag = SHARD_INTACT;
+			}
+
+			if (t == NULL || t->totvert == 0 || t->totloop == 0 || t->totpoly == 0) {
+				/* invalid shard, stop parsing */
+				break;
+			}
+
+			/* XXX TODO, need object for material as well, or atleast a material index... */
+			if (algorithm == MOD_FRACTURE_BOOLEAN) {
+				s = BKE_fracture_shard_boolean(obj, dm_parent, t, inner_material_index);
+			}
+			else if (algorithm == MOD_FRACTURE_BISECT || algorithm == MOD_FRACTURE_BISECT_FILL) {
+				float co[3] = {0, 0, 0};
+				printf("Bisecting cell %d...\n", i);
+				s = BKE_fracture_shard_bisect(bm_parent, t, obmat, algorithm == MOD_FRACTURE_BISECT_FILL, false, true, 0, co, inner_material_index);
+			}
+			else {
+				/* do not fracture case */
+				s = t;
+			}
+
+			if (s != NULL) {
+				s->parent_id = parent_id;
+				s->flag = SHARD_INTACT;
+
+				tempresults[i] = s;
+			}
+
+			fm->progress_counter++;
+		}
+	}
+	else {
+		for (i = 0; i < expected_shards; i++) {
+			Shard *s = NULL;
+			Shard *s2 = NULL;
+			Shard *t;
+			int index = 0;
+
+			if (fm->cancel == 1) {
+				break;
+			}
+
+			printf("Processing shard: %d\n", i);
+			t = tempshards[i];
+
+			if (t != NULL) {
+				t->parent_id = parent_id;
+				t->flag = SHARD_INTACT;
+			}
+
+			if (t == NULL || t->totvert == 0 || t->totloop == 0 || t->totpoly == 0) {
+				/* invalid shard, stop parsing*/
+				break;
+			}
+
+			index = (int)(BLI_frand() * (t->totpoly - 1));
+			if (index == 0) {
+				index = 1;
+			}
+
+			printf("Bisecting cell %d...\n", i);
+			printf("Bisecting cell %d...\n", i + 1);
+
+			s = BKE_fracture_shard_bisect(bm_parent, t, obmat, algorithm == MOD_FRACTURE_BISECT_FAST_FILL, false, true, index, centroid, inner_material_index);
+			s2 = BKE_fracture_shard_bisect(bm_parent, t, obmat, algorithm == MOD_FRACTURE_BISECT_FAST_FILL, true, false, index, centroid, inner_material_index);
+
+			if (s != NULL && s2 != NULL && tempresults != NULL) {
+				int j = 0;
+
+				fm->progress_counter++;
+
+				s->parent_id = parent_id;
+				s->flag = SHARD_INTACT;
+
+				s2->parent_id = parent_id;
+				s2->flag = SHARD_INTACT;
+
+				if (bm_parent != NULL) {
+					BM_mesh_free(bm_parent);
+					bm_parent = NULL;
+				}
+
+				if (dm_parent != NULL) {
+					dm_parent->needsFree = 1;
+					dm_parent->release(dm_parent);
+					dm_parent = NULL;
+				}
+				tempresults[i] = s;
+				tempresults[i + 1] = s2;
+
+				BLI_qsort_r(tempresults, i + 1, sizeof(Shard *), shard_sortsize, &i);
+
+				while (tempresults[j] == NULL && j < (i + 1)) {
+					/* ignore invalid shards */
+					j++;
+				}
+
+				/* continue splitting if not all expected shards exist yet */
+				if ((i + 2) < expected_shards) {
+					bm_parent = shard_to_bmesh(tempresults[j]);
+					copy_v3_v3(centroid, tempresults[j]->centroid);
+
+					BKE_shard_free(tempresults[j], true);
+					tempresults[j] = NULL;
+				}
+				i++;
+			}
+		}
+	}
+
+	if (bm_parent != NULL) {
+		BM_mesh_free(bm_parent);
+		bm_parent = NULL;
+	}
+
+	if (dm_parent != NULL) {
+		dm_parent->needsFree = 1;
+		dm_parent->release(dm_parent);
+		dm_parent = NULL;
+	}
+
+	if (p->shard_id == -2)
+	{
+		BKE_shard_free(p, true);
+	}
+
+	fm->shard_count = 0; /* may be not matching with expected shards, so reset... did increment this for
+	                      *progressbar only */
+
+	/*blocks are here because of deleted unnecessary if conditions, kept for convenience with declaring local variables */
+	{
+		{
+			for (i = 0; i < expected_shards; i++) {
+				Shard *s = tempresults[i];
+				if (s != NULL) {
+					add_shard(fm, s);
+				}
+
+				{
+					Shard *t = tempshards[i];
+					if (t != NULL) {
+						BKE_shard_free(t, false);
+					}
+				}
+			}
+		}
+		MEM_freeN(tempshards);
+		MEM_freeN(tempresults);
+	}
+}
+
+static Shard *parse_cell(cell c)
+{
+	Shard *s;
+	MVert *mvert = NULL;
+	MPoly *mpoly = NULL;
+	MLoop *mloop = NULL;
+	int *neighbors = NULL;
+	int totpoly = 0, totloop = 0, totvert = 0;
+	float centr[3];
+//	int shard_id;
+
+//	shard_id = c.index;
+
+	totvert = c.totvert;
+	if (totvert > 0) {
+		mvert = MEM_callocN(sizeof(MVert) * totvert, __func__);
+		parse_cell_verts(c, mvert, totvert);
+	}
+
+	totpoly = c.totpoly;
+	if (totpoly > 0) {
+		mpoly = MEM_callocN(sizeof(MPoly) * totpoly, __func__);
+		parse_cell_polys(c, mpoly, totpoly, &totloop);
+	}
+	else
+		totloop = 0;
+
+	if (totloop > 0) {
+		mloop = MEM_callocN(sizeof(MLoop) * totloop, __func__);
+		parse_cell_loops(c, mloop, totloop, mpoly, totpoly);
+	}
+
+	if (totpoly > 0) {
+		neighbors = MEM_callocN(sizeof(int) * totpoly, __func__);
+		parse_cell_neighbors(c, neighbors, totpoly);
+	}
+
+	copy_v3_v3(centr, c.centroid);
+
+	s = BKE_create_fracture_shard(mvert, mpoly, mloop, totvert, totpoly, totloop, false);
+
+	s->neighbor_ids = neighbors;
+	s->neighbor_count = totpoly;
+	copy_v3_v3(s->centroid, centr);
+
+	return s;
+}
+
+static void parse_cell_verts(cell c, MVert *mvert, int totvert)
+{
+	int i;
+
+	for (i = 0; i < totvert; i++) {
+		float *co = mvert[i].co;
+		copy_v3_v3(co, c.verts[i]);
+	}
+}
+
+static void parse_cell_polys(cell c, MPoly *mpoly, int totpoly, int *r_totloop)
+{
+	int i;
+	int totloop = 0;
+
+	for (i = 0; i < totpoly; ++i) {
+		int numloop;
+
+		numloop = c.poly_totvert[i];
+
+		mpoly[i].loopstart = totloop;
+		mpoly[i].totloop = numloop;
+
+		totloop += numloop;
+	}
+
+	*r_totloop = totloop;
+}
+
+static void parse_cell_loops(cell c, MLoop *mloop, int UNUSED(totloop), MPoly *mpoly, int totpoly)
+{
+	int i, k;
+
+	for (i = 0; i < totpoly; ++i) {
+		int loopstart = mpoly[i].loopstart;
+		int numloop = mpoly[i].totloop;
+
+		for (k = 0; k < numloop; ++k) {
+			int index;
+
+			index = c.poly_indices[i][k];
+
+			/* note: invert vertex order here,
+			 * otherwise normals are pointing inward
+			 */
+			mloop[loopstart + (numloop - 1) - k].v = index;
+		}
+	}
+}
+
+static void parse_cell_neighbors(cell c, int *neighbors, int totpoly)
+{
+	int i;
+
+	for (i = 0; i < totpoly; i++) {
+		int n;
+		n = c.neighbors[i];
+		neighbors[i] = n;
+	}
+}
+
+void BKE_fracture_shard_by_points(FracMesh *fmesh, ShardID id, FracPointCloud *pointcloud, int algorithm, Object *obj, DerivedMesh *dm, short inner_material_index) {
+	int n_size = 8;
+	
+	Shard *shard;
+	
+	float min[3], max[3];
+	float theta = 0.1f; /* TODO, container enlargement, because boundbox exact container and boolean might create artifacts */
+	int p;
+	
+	container *voro_container;
+	particle_order *voro_particle_order;
+	cell *voro_cells;
+
+#ifdef USE_DEBUG_TIMER
+	double time_start;
+#endif
+	
+	shard = BKE_shard_by_id(fmesh, id, dm);
+	if (!shard || shard->flag & SHARD_FRACTURED)
+		return;
+
+	
+	/* calculate bounding box with theta margin */
+	copy_v3_v3(min, shard->min);
+	copy_v3_v3(max, shard->max);
+
+	if (shard->shard_id == -2) {
+		BKE_shard_free(shard, true);
+	}
+
+	add_v3_fl(min, -theta);
+	add_v3_fl(max, theta);
+	
+	voro_container = container_new(min[0], max[0], min[1], max[1], min[2], max[2],
+	                               n_size, n_size, n_size, false, false, false,
+	                               pointcloud->totpoints);
+	
+	voro_particle_order = particle_order_new();
+	for (p = 0; p < pointcloud->totpoints; p++) {
+		float *co = pointcloud->points[p].co;
+		container_put(voro_container, voro_particle_order, p, co[0], co[1], co[2]);
+	}
+	
+
+
+#ifdef USE_DEBUG_TIMER
+	time_start = PIL_check_seconds_timer();
+#endif
+
+	/* we expect as many raw cells as we have particles */
+	voro_cells = cells_new(pointcloud->totpoints);
+
+	/*Compute directly...*/
+	container_compute_cells(voro_container, voro_cells);
+
+	/*Evaluate result*/
+	parse_cells(voro_cells, pointcloud->totpoints, id, fmesh, algorithm, obj, dm, inner_material_index);
+
+	/*Free structs in C++ area of memory */
+	cells_free(voro_cells, pointcloud->totpoints);
+	particle_order_free(voro_particle_order);
+	container_free(voro_container);
+
+#ifdef USE_DEBUG_TIMER
+	printf("Fracture done, %g\n", PIL_check_seconds_timer() - time_start);
+#endif
+
+}
+
+void BKE_fracmesh_free(FracMesh *fm, bool doCustomData)
+{
+	if (fm == NULL) {
+		return;
+	}
+
+	while (fm->shard_map.first) {
+		Shard* s = (Shard*)fm->shard_map.first;
+		BLI_remlink_safe(&fm->shard_map, s);
+		BKE_shard_free(s, doCustomData);
+	}
+}
+
+
+/* DerivedMesh */
+static DerivedMesh *create_dm(FractureModifierData *fmd, bool doCustomData)
+{
+	int shard_count = fmd->shards_to_islands ? BLI_countlist(&fmd->islandShards) : fmd->frac_mesh->shard_count;
+	ListBase *shardlist;
+	Shard *shard, *s;
+	
+	int num_verts, num_polys, num_loops;
+	int vertstart, polystart, loopstart;
+	DerivedMesh *result;
+	MVert *mverts;
+	MPoly *mpolys;
+	MLoop *mloops;
+	
+	num_verts = num_polys = num_loops = 0;
+
+	if (fmd->shards_to_islands) {
+		for (s = fmd->islandShards.first; s; s = s->next) {
+			num_verts += s->totvert;
+			num_polys += s->totpoly;
+			num_loops += s->totloop;
+		}
+	}
+	else {
+		for (s = fmd->frac_mesh->shard_map.first; s; s = s->next) {
+			num_verts += s->totvert;
+			num_polys += s->totpoly;
+			num_loops += s->totloop;
+		}
+	}
+	
+	result = CDDM_new(num_verts, 0, 0, num_loops, num_polys);
+	mverts = CDDM_get_verts(result);
+	mloops = CDDM_get_loops(result);
+	mpolys = CDDM_get_polys(result);
+
+	if (doCustomData && shard_count > 0) {
+		Shard *s;
+		if (fmd->shards_to_islands) {
+			s = (Shard *)fmd->islandShards.first;
+		}
+		else {
+			s = (Shard *)fmd->frac_mesh->shard_map.first;
+		}
+
+		CustomData_merge(&s->vertData, &result->vertData, CD_MASK_MDEFORMVERT, CD_CALLOC, num_verts);
+		CustomData_merge(&s->polyData, &result->polyData, CD_MASK_MTEXPOLY, CD_CALLOC, num_polys);
+		CustomData_merge(&s->loopData, &result->loopData, CD_MASK_MLOOPUV, CD_CALLOC, num_loops);
+	}
+
+	vertstart = polystart = loopstart = 0;
+	if (fmd->shards_to_islands) {
+		shardlist = &fmd->islandShards;
+	}
+	else
+	{
+		shardlist = &fmd->frac_mesh->shard_map;
+	}
+
+	for (shard = shardlist->first; shard; shard = shard->next)
+	{
+		MPoly *mp;
+		MLoop *ml;
+		int i;
+		
+		memcpy(mverts + vertstart, shard->mvert, shard->totvert * sizeof(MVert));
+		memcpy(mpolys + polystart, shard->mpoly, shard->totpoly * sizeof(MPoly));
+
+
+		for (i = 0, mp = mpolys + polystart; i < shard->totpoly; ++i, ++mp) {
+			/* adjust loopstart index */
+			mp->loopstart += loopstart;
+		}
+		
+		memcpy(mloops + loopstart, shard->mloop, shard->totloop * sizeof(MLoop));
+
+		for (i = 0, ml = mloops + loopstart; i < shard->totloop; ++i, ++ml) {
+			/* adjust vertex index */
+			ml->v += vertstart;
+		}
+
+		if (doCustomData) {
+			if (shard->totvert > 1) {
+				CustomData_copy_data(&shard->vertData, &result->vertData, 0, vertstart, shard->totvert);
+			}
+
+			if (shard->totloop > 0) {
+				CustomData_copy_data(&shard->loopData, &result->loopData, 0, loopstart, shard->totloop);
+			}
+
+			if (shard->totpoly > 0) {
+				CustomData_copy_data(&shard->polyData, &result->polyData, 0, polystart, shard->totpoly);
+			}
+		}
+
+		vertstart += shard->totvert;
+		polystart += shard->totpoly;
+		loopstart += shard->totloop;
+	}
+	
+	CustomData_free(&result->edgeData, 0);
+	CDDM_calc_edges(result);
+
+	{
+		MEdge *medge = result->getEdgeArray(result);
+		MPoly *mpoly = result->getPolyArray(result), *mp = NULL;
+		MLoop *mloop = result->getLoopArray(result);
+		MVert *mvert = result->getVertArray(result);
+		int totpoly = result->getNumPolys(result);
+		int i = 0;
+		for (i = 0, mp = mpoly; i < totpoly; i++, mp++)
+		{
+			if (mp->flag & ME_FACE_SEL)
+			{
+				int j = 0;
+				for (j = 0; j < mp->totloop; j++)
+				{
+					MLoop ml;
+					ml = mloop[mp->loopstart + j];
+					medge[ml.e].flag |= ME_SHARP;
+					mvert[ml.v].flag |= ME_VERT_TMP_TAG;
+				}
+			}
+		}
+	}
+	
+	result->dirty |= DM_DIRTY_NORMALS;
+	CDDM_calc_normals_mapping(result);
+	return result;
+}
+
+void BKE_fracture_create_dm(FractureModifierData *fmd, bool doCustomData)
+{
+	DerivedMesh *dm_final = NULL;
+	
+	if (fmd->dm) {
+		fmd->dm->needsFree = 1;
+		fmd->dm->release(fmd->dm);
+		fmd->dm = NULL;
+	}
+	
+	dm_final = create_dm(fmd, doCustomData);
+	fmd->dm = dm_final;
+}
+
+DerivedMesh *BKE_shard_create_dm(Shard *s, bool doCustomData)
+{
+	DerivedMesh *dm;
+	MVert *mverts;
+	MLoop *mloops;
+	MPoly *mpolys;
+	
+	dm  = CDDM_new(s->totvert, 0, 0, s->totloop, s->totpoly);
+
+	mverts = CDDM_get_verts(dm);
+	mloops = CDDM_get_loops(dm);
+	mpolys = CDDM_get_polys(dm);
+
+	memcpy(mverts, s->mvert, s->totvert * sizeof(MVert));
+	memcpy(mloops, s->mloop, s->totloop * sizeof(MLoop));
+	memcpy(mpolys, s->mpoly, s->totpoly * sizeof(MPoly));
+
+	CDDM_calc_edges(dm);
+
+	dm->dirty |= DM_DIRTY_NORMALS;
+	CDDM_calc_normals_mapping(dm);
+
+	if (doCustomData) {
+		if (s->totvert > 1) {
+			CustomData_add_layer(&dm->vertData, CD_MDEFORMVERT, CD_DUPLICATE, CustomData_get_layer(&s->vertData, CD_MDEFORMVERT), s->totvert);
+		}
+		if (s->totloop > 0) {
+			CustomData_add_layer(&dm->loopData, CD_MLOOPUV, CD_DUPLICATE, CustomData_get_layer(&s->loopData, CD_MLOOPUV), s->totloop);
+		}
+		if (s->totpoly > 0) {
+			CustomData_add_layer(&dm->polyData, CD_MTEXPOLY, CD_DUPLICATE, CustomData_get_layer(&s->polyData, CD_MTEXPOLY), s->totpoly);
+		}
+	}
+
+	return dm;
+}
diff -ru --new-file blender-2.76b.old/source/blender/blenkernel/intern/fracture_util.c blender-2.76b/source/blender/blenkernel/intern/fracture_util.c
--- blender-2.76b.old/source/blender/blenkernel/intern/fracture_util.c	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/source/blender/blenkernel/intern/fracture_util.c	2016-01-27 20:24:36.782784651 +0300
@@ -0,0 +1,416 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) Blender Foundation
+ * All rights reserved.
+ *
+ * The Original Code is: all of this file.
+ *
+ * Contributor(s): Martin Felke
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+/** \file blender/blenkernel/intern/fracture_util.c
+ *  \ingroup blenkernel
+ *  \brief CSG operations
+ */
+
+#include "BKE_cdderivedmesh.h"
+#include "BKE_editmesh.h"
+#include "BKE_fracture.h"
+#include "BKE_fracture_util.h"
+#include "BKE_material.h"
+
+#include "BLI_alloca.h"
+#include "BLI_boxpack2d.h"
+#include "BLI_convexhull2d.h"
+#include "BLI_ghash.h"
+#include "BLI_math.h"
+#include "BLI_rand.h"
+#include "BLI_sys_types.h"
+
+#include "DNA_fracture_types.h"
+#include "DNA_meshdata_types.h"
+#include "DNA_material_types.h"
+
+#include "MEM_guardedalloc.h"
+
+#include "bmesh.h"
+#include "../../modifiers/intern/MOD_boolean_util.h"
+
+/*prototypes*/
+void uv_bbox(float uv[][2], int num_uv, float minv[2], float maxv[2]);
+void uv_translate(float uv[][2], int num_uv, float trans[2]);
+void uv_scale(float uv[][2], int num_uv, float scale);
+void uv_transform(float uv[][2], int num_uv, float mat[2][2]);
+void unwrap_shard_dm(DerivedMesh *dm);
+
+/* UV Helpers */
+void uv_bbox(float uv[][2], int num_uv, float minv[2], float maxv[2])
+{
+	int v;
+	INIT_MINMAX2(minv, maxv);
+
+	for (v = 0; v < num_uv; v++) {
+		minmax_v2v2_v2(minv, maxv, uv[v]);
+	}
+}
+
+void uv_translate(float uv[][2], int num_uv, float trans[2])
+{
+	int v;
+	for (v = 0; v < num_uv; v++) {
+		uv[v][0] += trans[0];
+		uv[v][1] += trans[1];
+	}
+}
+
+void uv_scale(float uv[][2], int num_uv, float scale)
+{
+	int v;
+	for (v = 0; v < num_uv; v++) {
+		uv[v][0] *= scale;
+		uv[v][1] *= scale;
+	}
+}
+
+void uv_transform(float uv[][2], int num_uv, float mat[2][2])
+{
+	int v;
+	for (v = 0; v < num_uv; v++) {
+		mul_m2v2(mat, uv[v]);
+	}
+}
+
+void unwrap_shard_dm(DerivedMesh *dm)
+{
+	MPoly *mpoly, *mp;
+	MLoop *mloop;
+	MVert *mvert;
+	int totpoly, i = 0;
+	MLoopUV *mluv = MEM_callocN(sizeof(MLoopUV) * dm->numLoopData, "mluv");
+	BoxPack *boxpack = MEM_mallocN(sizeof(BoxPack) * dm->numPolyData, "boxpack");
+	float scale, tot_width, tot_height;
+
+	/* set inner material on child shard */
+	mvert = dm->getVertArray(dm);
+	mpoly = dm->getPolyArray(dm);
+	mloop = dm->getLoopArray(dm);
+	totpoly = dm->getNumPolys(dm);
+	for (i = 0, mp = mpoly; i < totpoly; i++, mp++) {
+		MLoop *ml;
+		int j = 0;
+		float (*verts)[3] = MEM_mallocN(sizeof(float[3]) * mp->totloop, "unwrap_shard_dm verts");
+		float nor[3];
+		float mat[3][3];
+		float (*uv)[2] = MEM_mallocN(sizeof(float[2]) * mp->totloop, "unwrap_shard_dm_uv");
+		BoxPack *box;
+		float uvbbox[2][2];
+		float angle;
+
+		/* uv unwrap cells, so inner faces get a uv map */
+		for (j = 0; j < mp->totloop; j++) {
+			ml = mloop + mp->loopstart + j;
+			copy_v3_v3(verts[j], (mvert + ml->v)->co);
+		}
+
+		normal_poly_v3(nor, (const float (*)[3])verts, mp->totloop);
+		normalize_v3(nor);
+		axis_dominant_v3_to_m3(mat, nor);
+
+		for (j = 0; j < mp->totloop; j++) {
+			mul_v2_m3v3(uv[j], mat, verts[j]);
+		}
+
+		/* rotate uvs for better packing */
+		angle = BLI_convexhull_aabb_fit_points_2d((const float (*)[2])uv, mp->totloop);
+
+		if (angle != 0.0f) {
+			float mat[2][2];
+			angle_to_mat2(mat, angle);
+			uv_transform((float (*)[2])uv, mp->totloop, mat);
+		}
+
+		/* prepare box packing... one poly is a box */
+		box = boxpack + i;
+		uv_bbox((float (*)[2])uv, mp->totloop, uvbbox[0], uvbbox[1]);
+
+		uvbbox[0][0] = -uvbbox[0][0];
+		uvbbox[0][1] = -uvbbox[0][1];
+
+		uv_translate((float (*)[2])uv, mp->totloop, uvbbox[0]);
+
+		box->w = uvbbox[1][0] + uvbbox[0][0];
+		box->h = uvbbox[1][1] + uvbbox[0][1];
+		box->index = i;
+
+		/* copy coords back */
+		for (j = 0; j < mp->totloop; j++) {
+			copy_v2_v2(mluv[j + mp->loopstart].uv, uv[j]);
+			mluv[j + mp->loopstart].flag = 0;
+		}
+
+		MEM_freeN(uv);
+		MEM_freeN(verts);
+	}
+
+	/* do box packing and match uvs according to it */
+	BLI_box_pack_2d(boxpack, totpoly, &tot_width, &tot_height);
+
+	if (tot_height > tot_width)
+		scale = 1.0f / tot_height;
+	else
+		scale = 1.0f / tot_width;
+
+	for (i = 0, mp = mpoly; i < totpoly; i++, mp++) {
+		float trans[2];
+		BoxPack *box;
+		int j;
+
+		box = boxpack + i;
+		trans[0] = box->x;
+		trans[1] = box->y;
+
+		for (j = 0; j < mp->totloop; j++)
+		{
+			uv_translate((float (*)[2])mluv[j + mp->loopstart].uv, 1, trans);
+			uv_scale((float (*)[2])mluv[j + mp->loopstart].uv, 1, scale);
+		}
+	}
+
+	MEM_freeN(boxpack);
+
+	CustomData_add_layer_named(&dm->loopData, CD_MLOOPUV, CD_ASSIGN, mluv, dm->numLoopData, "InnerUV");
+	CustomData_add_layer_named(&dm->polyData, CD_MTEXPOLY, CD_CALLOC, NULL, totpoly, "InnerUV");
+}
+
+Shard *BKE_fracture_shard_boolean(Object *obj, DerivedMesh *dm_parent, Shard *child, short inner_material_index)
+{
+	Shard *output_s;
+	DerivedMesh *left_dm, *right_dm, *output_dm;
+	MPoly *mpoly, *mp;
+	int totpoly, i = 0;
+
+	left_dm = BKE_shard_create_dm(child, false);
+	unwrap_shard_dm(left_dm);
+
+	/* set inner material on child shard */
+	mpoly = left_dm->getPolyArray(left_dm);
+	totpoly = left_dm->getNumPolys(left_dm);
+	for (i = 0, mp = mpoly; i < totpoly; i++, mp++) {
+		if (inner_material_index > 0) {
+			mp->mat_nr = inner_material_index;
+		}
+		mp->flag |= ME_FACE_SEL;
+	}
+
+	right_dm = dm_parent;
+	output_dm = NewBooleanDerivedMesh(right_dm, obj, left_dm, obj, 1);
+
+	left_dm->needsFree = 1;
+	left_dm->release(left_dm);
+	left_dm = NULL;
+
+	if (output_dm)
+	{
+		output_s = BKE_create_fracture_shard(output_dm->getVertArray(output_dm),
+		                                     output_dm->getPolyArray(output_dm),
+		                                     output_dm->getLoopArray(output_dm),
+		                                     output_dm->getNumVerts(output_dm),
+		                                     output_dm->getNumPolys(output_dm),
+		                                     output_dm->getNumLoops(output_dm),
+		                                     true);
+
+		output_s = BKE_custom_data_to_shard(output_s, output_dm);
+
+		/* XXX TODO this might be wrong by now ... */
+		output_s->neighbor_count = child->neighbor_count;
+		output_s->neighbor_ids = MEM_mallocN(sizeof(int) * child->neighbor_count, __func__);
+		memcpy(output_s->neighbor_ids, child->neighbor_ids, sizeof(int) * child->neighbor_count);
+		BKE_fracture_shard_center_centroid(output_s, output_s->centroid);
+
+
+		/* free the temp derivedmesh */
+		output_dm->needsFree = 1;
+		output_dm->release(output_dm);
+		output_dm = NULL;
+
+		return output_s;
+	}
+
+	return NULL;
+}
+
+
+Shard *BKE_fracture_shard_bisect(BMesh *bm_orig, Shard *child, float obmat[4][4], bool use_fill, bool clear_inner,
+                                 bool clear_outer, int cutlimit, float centroid[3], short inner_mat_index)
+{
+	#define MYTAG (1 << 6)
+
+	Shard *output_s;
+	DerivedMesh *dm_child = BKE_shard_create_dm(child, false);
+	DerivedMesh *dm_out;
+	BMesh *bm_parent = BM_mesh_copy(bm_orig);
+	BMesh *bm_child;
+	BMIter iter;
+	BMFace *f;
+
+	BMOperator bmop;
+	float plane_co[3];
+	float plane_no[3];
+	float imat[4][4];
+
+	float thresh = 0.00001f;
+	bool do_break = false;
+
+	int cut_index = 0;
+
+	unwrap_shard_dm(dm_child);
+	bm_child = DM_to_bmesh(dm_child, true);
+
+	invert_m4_m4(imat, obmat);
+
+	BM_mesh_elem_hflag_enable_all(bm_parent, BM_VERT | BM_EDGE | BM_FACE, BM_ELEM_TAG, false);
+
+	BM_ITER_MESH_INDEX (f, &iter, bm_child, BM_FACES_OF_MESH, cut_index)
+	{
+		if (do_break) {
+			break;
+		}
+
+		if (cutlimit > 0) {
+			f = BM_face_at_index_find(bm_child, cutlimit);
+			copy_v3_v3(plane_co, centroid);
+			copy_v3_v3(plane_no, f->no /*normal*/);
+			do_break = true;
+		}
+		else {
+			copy_v3_v3(plane_co, f->l_first->v->co);
+			copy_v3_v3(plane_no, f->no);
+		}
+
+		mul_m4_v3(imat, plane_co);
+		mul_mat3_m4_v3(imat, plane_no);
+
+		BM_mesh_elem_hflag_enable_all(bm_parent, BM_VERT | BM_EDGE | BM_FACE, BM_ELEM_TAG, false);
+
+		BMO_op_initf(bm_parent, &bmop, (BMO_FLAG_DEFAULTS & ~BMO_FLAG_RESPECT_HIDE),
+		             "bisect_plane geom=%hvef dist=%f plane_co=%v plane_no=%v use_snap_center=%b clear_inner=%b clear_outer=%b",
+		             BM_ELEM_TAG, thresh, plane_co, plane_no, false, clear_inner, clear_outer);
+		BMO_op_exec(bm_parent, &bmop);
+
+		BM_mesh_elem_hflag_disable_all(bm_parent, BM_VERT | BM_EDGE | BM_FACE, BM_ELEM_TAG, false);
+
+		if (use_fill) {
+			float normal_fill[3];
+			BMOperator bmop_fill;
+			BMOperator bmop_attr;
+
+			normalize_v3_v3(normal_fill, plane_no);
+			if (clear_outer == true && clear_inner == false) {
+				negate_v3(normal_fill);
+			}
+
+			/* Fill, XXX attempted different fill algorithms here, needs further thoughts because none really suited */
+#if 0
+			BMO_op_initf(bm_parent, &bmop_fill, (BMO_FLAG_DEFAULTS & ~BMO_FLAG_RESPECT_HIDE),
+			             "contextual_create geom=%S mat_nr=%i use_smooth=%b",
+			             &bmop, "geom_cut.out", 0, false);
+			BMO_op_exec(bm_parent, &bmop_fill);
+
+			BMO_op_initf(bm_parent, &bmop_attr, (BMO_FLAG_DEFAULTS & ~BMO_FLAG_RESPECT_HIDE),
+			             "face_attribute_fill faces=%S use_normals=%b use_data=%b",
+			             &bmop_fill, "faces.out", false, true);
+			BMO_op_exec(bm_parent, &bmop_attr);
+
+			BMO_op_initf(bm_parent, &bmop_del, (BMO_FLAG_DEFAULTS & ~BMO_FLAG_RESPECT_HIDE),
+			             "delete geom=%S context=%i", &bmop_fill, "edges.out", DEL_EDGESFACES);
+			BMO_op_exec(bm_parent, &bmop_del);
+
+			BMO_slot_buffer_hflag_enable(bm_parent, bmop_fill.slots_out, "faces.out", BM_FACE, BM_ELEM_TAG, true);
+#endif
+
+			if (inner_mat_index == 0) { /* dont use inner material here*/
+				BMO_op_initf(
+				    bm_parent, &bmop_fill, (BMO_FLAG_DEFAULTS & ~BMO_FLAG_RESPECT_HIDE),
+				    "triangle_fill edges=%S normal=%v use_dissolve=%b use_beauty=%b",
+				    &bmop, "geom_cut.out", normal_fill, true, true);
+				BMO_op_exec(bm_parent, &bmop_fill);
+
+				BMO_op_initf(bm_parent, &bmop_attr, (BMO_FLAG_DEFAULTS & ~BMO_FLAG_RESPECT_HIDE),
+				             "face_attribute_fill faces=%S use_normals=%b use_data=%b",
+				             &bmop_fill, "geom.out", false, true);
+				BMO_op_exec(bm_parent, &bmop_attr);
+
+				BMO_slot_buffer_hflag_enable(bm_parent, bmop_fill.slots_out, "geom.out", BM_FACE, BM_ELEM_TAG | BM_ELEM_SELECT, true);
+			}
+			else {
+				/* use edgenet fill with inner material */
+				BMO_op_initf(
+				    bm_parent, &bmop_fill, (BMO_FLAG_DEFAULTS & ~BMO_FLAG_RESPECT_HIDE),
+				    "edgenet_fill edges=%S mat_nr=%i use_smooth=%b sides=%i",
+				    &bmop, "geom_cut.out", inner_mat_index, false, 2);
+				BMO_op_exec(bm_parent, &bmop_fill);
+
+				/* Copy Attributes */
+				BMO_op_initf(bm_parent, &bmop_attr, (BMO_FLAG_DEFAULTS & ~BMO_FLAG_RESPECT_HIDE),
+				             "face_attribute_fill faces=%S use_normals=%b use_data=%b",
+				             &bmop_fill, "faces.out", true, false);
+				BMO_op_exec(bm_parent, &bmop_attr);
+
+				BMO_slot_buffer_hflag_enable(bm_parent, bmop_fill.slots_out, "faces.out", BM_FACE, BM_ELEM_TAG | BM_ELEM_SELECT, true);
+			}
+
+			BMO_op_finish(bm_parent, &bmop_attr);
+			BMO_op_finish(bm_parent, &bmop_fill);
+		}
+
+		BMO_slot_buffer_hflag_enable(bm_parent, bmop.slots_out, "geom_cut.out", BM_VERT | BM_EDGE, BM_ELEM_TAG, true);
+
+		BMO_op_finish(bm_parent, &bmop);
+	}
+
+	dm_out = CDDM_from_bmesh(bm_parent, true);
+	output_s = BKE_create_fracture_shard(dm_out->getVertArray(dm_out),
+	                                     dm_out->getPolyArray(dm_out),
+	                                     dm_out->getLoopArray(dm_out),
+	                                     dm_out->getNumVerts(dm_out),
+	                                     dm_out->getNumPolys(dm_out),
+	                                     dm_out->getNumLoops(dm_out), true);
+
+	output_s = BKE_custom_data_to_shard(output_s, dm_out);
+
+	/*XXX TODO this might be wrong by now ... */
+	output_s->neighbor_count = child->neighbor_count;
+	output_s->neighbor_ids = MEM_mallocN(sizeof(int) * child->neighbor_count, __func__);
+	memcpy(output_s->neighbor_ids, child->neighbor_ids, sizeof(int) * child->neighbor_count);
+	BKE_fracture_shard_center_centroid(output_s, output_s->centroid);
+
+	BM_mesh_free(bm_child);
+	BM_mesh_free(bm_parent);
+
+	dm_child->needsFree = 1;
+	dm_child->release(dm_child);
+	dm_child = NULL;
+
+	dm_out->needsFree = 1;
+	dm_out->release(dm_out);
+	dm_out = NULL;
+
+	return output_s;
+}
diff -ru --new-file blender-2.76b.old/source/blender/blenkernel/intern/object.c blender-2.76b/source/blender/blenkernel/intern/object.c
--- blender-2.76b.old/source/blender/blenkernel/intern/object.c	2015-11-04 13:02:14.000000000 +0300
+++ blender-2.76b/source/blender/blenkernel/intern/object.c	2016-01-27 20:29:05.851748347 +0300
@@ -3681,8 +3681,8 @@
 	     md = md->next)
 	{
 		const ModifierTypeInfo *mti = modifierType_getInfo(md->type);
-		bool can_deform = mti->type == eModifierTypeType_OnlyDeform ||
-		                  is_modifier_animated;
+        /* special case for fracture modifier, for object deformation motion blur with the shards */
+		bool can_deform = mti->type == eModifierTypeType_OnlyDeform || is_modifier_animated || md->type == eModifierType_Fracture;
 
 		if (!can_deform) {
 			can_deform = constructive_modifier_is_deform_modified(md);
diff -ru --new-file blender-2.76b.old/source/blender/blenkernel/intern/pointcache.c blender-2.76b/source/blender/blenkernel/intern/pointcache.c
--- blender-2.76b.old/source/blender/blenkernel/intern/pointcache.c	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/source/blender/blenkernel/intern/pointcache.c	2016-01-27 20:34:04.485490635 +0300
@@ -71,6 +71,7 @@
 #include "BKE_scene.h"
 #include "BKE_smoke.h"
 #include "BKE_softbody.h"
+#include "BKE_rigidbody.h"
 
 #include "BIK_api.h"
 
@@ -999,22 +1000,26 @@
 static int  ptcache_rigidbody_write(int index, void *rb_v, void **data, int UNUSED(cfra))
 {
 	RigidBodyWorld *rbw = rb_v;
-	Object *ob = NULL;
-	
-	if (rbw->objects)
-		ob = rbw->objects[index];
-	
-	if (ob && ob->rigidbody_object) {
-		RigidBodyOb *rbo = ob->rigidbody_object;
-		
-		if (rbo->type == RBO_TYPE_ACTIVE) {
+	RigidBodyOb *rbo = NULL;
+	rbo = rbw->cache_index_map[index];
+
+	if (rbo == NULL) {
+		float dummyloc[3] = {FLT_MIN, FLT_MIN, FLT_MIN};
+		float dummyrot[4] = {FLT_MIN, FLT_MIN, FLT_MIN, FLT_MIN};	
+
+		//need to write dummy data obviously... hmm
+		PTCACHE_DATA_FROM(data, BPHYS_DATA_LOCATION, dummyloc);
+		PTCACHE_DATA_FROM(data, BPHYS_DATA_ROTATION, dummyrot);
+		return 1;
+	}
+
+	if (rbo && rbo->type == RBO_TYPE_ACTIVE && rbo->physics_object) {
 #ifdef WITH_BULLET
-			RB_body_get_position(rbo->physics_object, rbo->pos);
-			RB_body_get_orientation(rbo->physics_object, rbo->orn);
+		RB_body_get_position(rbo->physics_object, rbo->pos);
+		RB_body_get_orientation(rbo->physics_object, rbo->orn);
 #endif
-			PTCACHE_DATA_FROM(data, BPHYS_DATA_LOCATION, rbo->pos);
-			PTCACHE_DATA_FROM(data, BPHYS_DATA_ROTATION, rbo->orn);
-		}
+		PTCACHE_DATA_FROM(data, BPHYS_DATA_LOCATION, rbo->pos);
+		PTCACHE_DATA_FROM(data, BPHYS_DATA_ROTATION, rbo->orn);
 	}
 
 	return 1;
@@ -1022,65 +1027,56 @@
 static void ptcache_rigidbody_read(int index, void *rb_v, void **data, float UNUSED(cfra), float *old_data)
 {
 	RigidBodyWorld *rbw = rb_v;
-	Object *ob = NULL;
+	RigidBodyOb *rbo = NULL;
 	
-	if (rbw->objects)
-		ob = rbw->objects[index];
-	
-	if (ob && ob->rigidbody_object) {
-		RigidBodyOb *rbo = ob->rigidbody_object;
-		
-		if (rbo->type == RBO_TYPE_ACTIVE) {
-			
-			if (old_data) {
-				memcpy(rbo->pos, data, 3 * sizeof(float));
-				memcpy(rbo->orn, data + 3, 4 * sizeof(float));
-			}
-			else {
-				PTCACHE_DATA_TO(data, BPHYS_DATA_LOCATION, 0, rbo->pos);
-				PTCACHE_DATA_TO(data, BPHYS_DATA_ROTATION, 0, rbo->orn);
-			}
+	rbo = rbw->cache_index_map[index];	
+	if (rbo == NULL) {
+		return;
+	}
+
+	if (rbo && rbo->type == RBO_TYPE_ACTIVE) {
+		if (old_data) {
+			memcpy(rbo->pos, data, 3 * sizeof(float));
+			memcpy(rbo->orn, data + 3, 4 * sizeof(float));
+		}
+		else {
+			PTCACHE_DATA_TO(data, BPHYS_DATA_LOCATION, 0, rbo->pos);
+			PTCACHE_DATA_TO(data, BPHYS_DATA_ROTATION, 0, rbo->orn);
 		}
 	}
 }
 static void ptcache_rigidbody_interpolate(int index, void *rb_v, void **data, float cfra, float cfra1, float cfra2, float *old_data)
 {
 	RigidBodyWorld *rbw = rb_v;
-	Object *ob = NULL;
-	
-	if (rbw->objects)
-		ob = rbw->objects[index];
+	RigidBodyOb *rbo = NULL;
 	
-	if (ob && ob->rigidbody_object) {
-		RigidBodyOb *rbo = ob->rigidbody_object;
-		
-		if (rbo->type == RBO_TYPE_ACTIVE) {
-			ParticleKey keys[4];
-			ParticleKey result;
-			float dfra;
-			
-			memset(keys, 0, sizeof(keys));
-			
-			copy_v3_v3(keys[1].co, rbo->pos);
-			copy_qt_qt(keys[1].rot, rbo->orn);
-			
-			if (old_data) {
-				memcpy(keys[2].co, data, 3 * sizeof(float));
-				memcpy(keys[2].rot, data + 3, 4 * sizeof(float));
-			}
-			else {
-				BKE_ptcache_make_particle_key(&keys[2], 0, data, cfra2);
-			}
-			
-			dfra = cfra2 - cfra1;
-		
-			/* note: keys[0] and keys[3] unused for type < 1 (crappy) */
-			psys_interpolate_particle(-1, keys, (cfra - cfra1) / dfra, &result, true);
-			interp_qt_qtqt(result.rot, keys[1].rot, keys[2].rot, (cfra - cfra1) / dfra);
-			
-			copy_v3_v3(rbo->pos, result.co);
-			copy_qt_qt(rbo->orn, result.rot);
+	rbo = rbw->cache_index_map[index];
+	if (rbo == NULL) {
+		return;
+	}
+
+	if (rbo->type == RBO_TYPE_ACTIVE) {
+
+		copy_v3_v3(keys[1].co, rbo->pos);
+		copy_qt_qt(keys[1].rot, rbo->orn);
+
+		if (old_data) {
+			memcpy(keys[2].co, data, 3 * sizeof(float));
+			memcpy(keys[2].rot, data + 3, 4 * sizeof(float));
+		}
+		else {
+			BKE_ptcache_make_particle_key(keys+2, 0, data, cfra2);	
 		}
+
+		dfra = cfra2 - cfra1;
+
+		/*psys_interpolate_particle(-1, keys, (cfra - cfra1) / dfra, keys, 1) */
+		/* XXX temporary deform motion blur fix */
+		interp_v3_v3v3(keys->co, keys[1].co, keys[2].co, (cfra - cfra1) / dfra);
+		interp_qt_qtqt(keys->rot, keys[1].rot, keys[2].rot, (cfra - cfra1) / dfra);
+
+		copy_v3_v3(rbo->pos, keys->co);
+		copy_qt_qt(rbo->orn, keys->rot);
 	}
 }
 static int ptcache_rigidbody_totpoint(void *rb_v, int UNUSED(cfra))
diff -ru --new-file blender-2.76b.old/source/blender/blenkernel/intern/rigidbody.c blender-2.76b/source/blender/blenkernel/intern/rigidbody.c
--- blender-2.76b.old/source/blender/blenkernel/intern/rigidbody.c	2015-11-04 13:02:14.000000000 +0300
+++ blender-2.76b/source/blender/blenkernel/intern/rigidbody.c	2016-01-27 21:18:01.904663139 +0300
@@ -20,7 +20,7 @@
  *
  * The Original Code is: all of this file.
  *
- * Contributor(s): Joshua Leung, Sergej Reich
+ * Contributor(s): Joshua Leung, Sergej Reich, Martin Felke
  *
  * ***** END GPL LICENSE BLOCK *****
  */
@@ -41,12 +41,14 @@
 
 #include "BLI_blenlib.h"
 #include "BLI_math.h"
+#include "BLI_kdtree.h"
 
 #ifdef WITH_BULLET
 #  include "RBI_api.h"
 #endif
 
 #include "DNA_group_types.h"
+#include "DNA_mesh_types.h"
 #include "DNA_meshdata_types.h"
 #include "DNA_object_types.h"
 #include "DNA_object_force.h"
@@ -57,15 +59,400 @@
 #include "BKE_depsgraph.h"
 #include "BKE_effect.h"
 #include "BKE_global.h"
+#include "BKE_group.h"
 #include "BKE_library.h"
 #include "BKE_mesh.h"
 #include "BKE_object.h"
 #include "BKE_pointcache.h"
 #include "BKE_rigidbody.h"
 #include "BKE_scene.h"
+#include "BKE_modifier.h"
+#include "BKE_depsgraph.h"
 
 #ifdef WITH_BULLET
 
+static bool isModifierActive(FractureModifierData *rmd) {
+	return ((rmd != NULL) && (rmd->modifier.mode & (eModifierMode_Realtime | eModifierMode_Render)) && (rmd->refresh == false));
+}
+
+static void calc_dist_angle(RigidBodyShardCon *con, float *dist, float *angle)
+{
+	float q1[4], q2[4], qdiff[4], axis[3];
+	if ((con->mi1->rigidbody == NULL) || (con->mi2->rigidbody == NULL)) {
+		*dist = 0;
+		*angle = 0;
+		return;
+	}
+	
+	sub_v3_v3v3(axis, con->mi1->rigidbody->pos, con->mi2->rigidbody->pos);
+	*dist = len_v3(axis);
+	copy_qt_qt(q1, con->mi1->rigidbody->orn);
+	copy_qt_qt(q2, con->mi2->rigidbody->orn);
+	invert_qt(q1);
+	mul_qt_qtqt(qdiff, q1, q2);
+	quat_to_axis_angle(axis, angle, qdiff);
+}
+
+void BKE_rigidbody_start_dist_angle(RigidBodyShardCon *con)
+{
+	/* store starting angle and distance per constraint*/
+	float dist, angle;
+	calc_dist_angle(con, &dist, &angle);
+	con->start_dist = dist;
+	con->start_angle = angle;
+}
+
+float BKE_rigidbody_calc_max_con_mass(Object *ob)
+{
+	FractureModifierData *rmd;
+	ModifierData *md;
+	RigidBodyShardCon *con;
+	float max_con_mass = 0, con_mass;
+
+	for (md = ob->modifiers.first; md; md = md->next) {
+		if (md->type == eModifierType_Fracture) {
+			rmd = (FractureModifierData *)md;
+			for (con = rmd->meshConstraints.first; con; con = con->next) {
+				if ((con->mi1 != NULL && con->mi1->rigidbody != NULL) &&
+				    (con->mi2 != NULL && con->mi2->rigidbody != NULL)) {
+					con_mass = con->mi1->rigidbody->mass + con->mi2->rigidbody->mass;
+					if (con_mass > max_con_mass) {
+						max_con_mass = con_mass;
+					}
+				}
+			}
+
+			return max_con_mass;
+		}
+	}
+
+	return 0;
+}
+
+float BKE_rigidbody_calc_min_con_dist(Object *ob)
+{
+	FractureModifierData *rmd;
+	ModifierData *md;
+	RigidBodyShardCon *con;
+	float min_con_dist = FLT_MAX, con_dist, con_vec[3];
+
+	for (md = ob->modifiers.first; md; md = md->next) {
+		if (md->type == eModifierType_Fracture) {
+			rmd = (FractureModifierData *)md;
+			for (con = rmd->meshConstraints.first; con; con = con->next) {
+				if ((con->mi1 != NULL && con->mi1->rigidbody != NULL) &&
+				    (con->mi2 != NULL && con->mi2->rigidbody != NULL)) {
+					sub_v3_v3v3(con_vec, con->mi1->centroid, con->mi2->centroid);
+					con_dist = len_v3(con_vec);
+					if (con_dist < min_con_dist) {
+						min_con_dist = con_dist;
+					}
+				}
+			}
+
+			return min_con_dist;
+		}
+	}
+
+	return FLT_MAX;
+}
+
+
+void BKE_rigidbody_calc_threshold(float max_con_mass, FractureModifierData *rmd, RigidBodyShardCon *con) {
+
+	float max_thresh, thresh = 0.0f, con_mass;
+	if ((max_con_mass == 0) && (rmd->use_mass_dependent_thresholds)) {
+		return;
+	}
+
+	if ((con->mi1 == NULL) || (con->mi2 == NULL)) {
+		return;
+	}
+
+	max_thresh = rmd->breaking_threshold;
+	if ((con->mi1->rigidbody != NULL) && (con->mi2->rigidbody != NULL)) {
+		con_mass = con->mi1->rigidbody->mass + con->mi2->rigidbody->mass;
+
+		if (rmd->use_mass_dependent_thresholds)
+		{
+			thresh = (con_mass / max_con_mass) * max_thresh;
+		}
+
+		con->breaking_threshold = thresh;
+	}
+}
+
+static int DM_mesh_minmax(DerivedMesh *dm, float r_min[3], float r_max[3])
+{
+	MVert *v;
+	int i = 0;
+	for (i = 0; i < dm->numVertData; i++) {
+		v = CDDM_get_vert(dm, i);
+		minmax_v3v3_v3(r_min, r_max, v->co);
+	}
+
+	return (dm->numVertData != 0);
+}
+
+static void DM_mesh_boundbox(DerivedMesh *bm, float r_loc[3], float r_size[3])
+{
+	float min[3], max[3];
+	float mloc[3], msize[3];
+
+	if (!r_loc) r_loc = mloc;
+	if (!r_size) r_size = msize;
+
+	INIT_MINMAX(min, max);
+	if (!DM_mesh_minmax(bm, min, max)) {
+		min[0] = min[1] = min[2] = -1.0f;
+		max[0] = max[1] = max[2] = 1.0f;
+	}
+
+	mid_v3_v3v3(r_loc, min, max);
+
+	r_size[0] = (max[0] - min[0]) / 2.0f;
+	r_size[1] = (max[1] - min[1]) / 2.0f;
+	r_size[2] = (max[2] - min[2]) / 2.0f;
+}
+
+/* helper function to calculate volume of rigidbody object */
+float BKE_rigidbody_calc_volume(DerivedMesh *dm, RigidBodyOb *rbo)
+{
+	float loc[3]  = {0.0f, 0.0f, 0.0f};
+	float size[3]  = {1.0f, 1.0f, 1.0f};
+	float radius = 1.0f;
+	float height = 1.0f;
+
+	float volume = 0.0f;
+
+	/* if automatically determining dimensions, use the Object's boundbox
+	 *	- assume that all quadrics are standing upright on local z-axis
+	 *	- assume even distribution of mass around the Object's pivot
+	 *	  (i.e. Object pivot is centralised in boundbox)
+	 *	- boundbox gives full width
+	 */
+	/* XXX: all dimensions are auto-determined now... later can add stored settings for this*/
+	DM_mesh_boundbox(dm, loc, size);
+
+	if (ELEM(rbo->shape, RB_SHAPE_CAPSULE, RB_SHAPE_CYLINDER, RB_SHAPE_CONE)) {
+		/* take radius as largest x/y dimension, and height as z-dimension */
+		radius = MAX2(size[0], size[1]) * 0.5f;
+		height = size[2];
+	}
+	else if (rbo->shape == RB_SHAPE_SPHERE) {
+		/* take radius to the the largest dimension to try and encompass everything */
+		radius = max_fff(size[0], size[1], size[2]) * 0.5f;
+	}
+
+	/* calculate volume as appropriate  */
+	switch (rbo->shape) {
+	
+		case RB_SHAPE_SPHERE:
+			volume = 4.0f / 3.0f * (float)M_PI * radius * radius * radius;
+			break;
+
+		/* for now, assume that capsule is close enough to a cylinder... */
+		case RB_SHAPE_CAPSULE:
+		case RB_SHAPE_CYLINDER:
+			volume = (float)M_PI * radius * radius * height;
+			break;
+
+		case RB_SHAPE_CONE:
+			volume = (float)M_PI / 3.0f * radius * radius * height;
+			break;
+
+		/* for now, all mesh shapes are just treated as boxes...
+		 * NOTE: this may overestimate the volume, but other methods are overkill
+		 */
+		case RB_SHAPE_BOX:
+		case RB_SHAPE_CONVEXH:
+		case RB_SHAPE_TRIMESH:
+			volume = size[0] * size[1] * size[2];
+			if (size[0] == 0) {
+				volume = size[1] * size[2];
+			}
+			else if (size[1] == 0) {
+				volume = size[0] * size[2];
+			}
+			else if (size[2] == 0) {
+				volume = size[0] * size[1];
+			}
+			break;
+
+#if 0 // XXX: not defined yet
+		case RB_SHAPE_COMPOUND:
+			volume = 0.0f;
+			break;
+#endif
+	}
+
+	/* return the volume calculated */
+	return volume;
+}
+
+void BKE_rigidbody_calc_shard_mass(Object *ob, MeshIsland *mi, DerivedMesh *orig_dm)
+{
+	DerivedMesh *dm_ob = orig_dm, *dm_mi;
+	float vol_mi = 0, mass_mi = 0, vol_ob = 0, mass_ob = 0;
+
+	if (dm_ob == NULL) {
+		/* fallback method */
+		if (ob->type == OB_MESH) {
+			/* if we have a mesh, determine its volume */
+			dm_ob = CDDM_from_mesh(ob->data);
+			vol_ob = BKE_rigidbody_calc_volume(dm_ob, ob->rigidbody_object);
+		}
+		else {
+			/* else get object boundbox as last resort */
+			float dim[3];
+			BKE_object_dimensions_get(ob, dim);
+			vol_ob = dim[0] * dim[1] * dim[2];
+		}
+	}
+	else
+	{
+		vol_ob = BKE_rigidbody_calc_volume(dm_ob, ob->rigidbody_object);
+	}
+
+	mass_ob = ob->rigidbody_object->mass;
+
+	if (vol_ob > 0) {
+		dm_mi = mi->physics_mesh;
+		vol_mi = BKE_rigidbody_calc_volume(dm_mi, mi->rigidbody);
+		mass_mi = (vol_mi / vol_ob) * mass_ob;
+		mi->rigidbody->mass = mass_mi;
+	}
+	
+	if (mi->rigidbody->type == RBO_TYPE_ACTIVE) {
+		if (mi->rigidbody->mass == 0)
+			mi->rigidbody->mass = 0.001;  /* set a minimum mass for active objects */
+	}
+
+	/* only active bodies need mass update */
+	if ((mi->rigidbody->physics_object) && (mi->rigidbody->type == RBO_TYPE_ACTIVE)) {
+		RB_body_set_mass(mi->rigidbody->physics_object, RBO_GET_MASS(mi->rigidbody));
+	}
+
+	if (orig_dm == NULL && dm_ob != NULL)
+	{
+		/* free temp dm, if it hasnt been passed in */
+		dm_ob->needsFree = 1;
+		dm_ob->release(dm_ob);
+	}
+}
+
+static void initNormals(struct MeshIsland *mi, Object *ob, FractureModifierData *fmd)
+{
+	/* hrm have to init Normals HERE, because we cant do this in readfile.c in case the file is loaded (have no access to the Object there) */
+	if (mi->vertno == NULL && mi->vertices_cached != NULL) {
+		KDTreeNearest n;
+		int index = 0, i = 0;
+		MVert mvrt;
+
+		DerivedMesh *dm = ob->derivedFinal;
+		if (dm == NULL) {
+			dm = CDDM_from_mesh(ob->data);
+		}
+
+		if (fmd->nor_tree == NULL) {
+			/* HRRRRRMMMM need to build the kdtree here as well if we start the sim after loading and not refreshing, again, no access to object.... */
+			int i = 0, totvert;
+			KDTree *tree;
+			MVert *mv, *mvert;
+
+			mvert = dm->getVertArray(dm);
+			totvert = dm->getNumVerts(dm);
+			tree = BLI_kdtree_new(totvert);
+
+			for (i = 0, mv = mvert; i < totvert; i++, mv++) {
+				BLI_kdtree_insert(tree, i, mv->co);
+			}
+
+			BLI_kdtree_balance(tree);
+			fmd->nor_tree = tree;
+		}
+
+		mi->vertno = MEM_callocN(sizeof(short) * 3 * mi->vertex_count, "mi->vertno");
+		for (i = 0; i < mi->vertex_count; i++) {
+			MVert *v = mi->vertices_cached[i];
+			index = BLI_kdtree_find_nearest(fmd->nor_tree, v->co, &n);
+			dm->getVert(dm, index, &mvrt);
+			mi->vertno[i * 3] = mvrt.no[0];
+			mi->vertno[i * 3 + 1] = mvrt.no[1];
+			mi->vertno[i * 3 + 2] = mvrt.no[2];
+		}
+
+		if (ob->derivedFinal == NULL) {
+			dm->needsFree = 1;
+			dm->release(dm);
+			dm = NULL;
+		}
+	}
+}
+
+void BKE_rigidbody_update_cell(struct MeshIsland *mi, Object *ob, float loc[3], float rot[4], FractureModifierData *rmd)
+{
+	float startco[3], centr[3], size[3];
+	short startno[3];
+	int j;
+	bool invalidData;
+
+	/* hrm have to init Normals HERE, because we cant do this in readfile.c in case the file is loaded (have no access to the Object there)*/
+	if (mi->vertno == NULL && rmd->fix_normals) {
+		initNormals(mi, ob, rmd);
+	}
+	
+	invalidData = (loc[0] == FLT_MIN) || (rot[0] == FLT_MIN);
+	
+	if (invalidData) {
+		return;
+	}
+
+	invert_m4_m4(ob->imat, ob->obmat);
+	mat4_to_size(size, ob->obmat);
+	
+	for (j = 0; j < mi->vertex_count; j++) {
+		struct MVert *vert;
+		float fno[3];
+		
+		if (!mi->vertices_cached) {
+			return;
+		}
+		
+		vert = mi->vertices_cached[j];
+		if (vert == NULL) continue;
+		if (vert->co == NULL) break;
+		if (rmd->refresh == true) break;
+
+		startco[0] = mi->vertco[j * 3];
+		startco[1] = mi->vertco[j * 3 + 1];
+		startco[2] = mi->vertco[j * 3 + 2];
+
+		if (rmd->fix_normals) {
+			startno[0] = mi->vertno[j * 3];
+			startno[1] = mi->vertno[j * 3 + 1];
+			startno[2] = mi->vertno[j * 3 + 2];
+
+			normal_short_to_float_v3(fno, startno);
+			mul_qt_v3(rot, fno);
+			normal_float_to_short_v3(vert->no, fno);
+		}
+
+		copy_v3_v3(vert->co, startco);
+		mul_v3_v3(vert->co, size);
+		mul_qt_v3(rot, vert->co);
+		copy_v3_v3(centr, mi->centroid);
+		mul_v3_v3(centr, size);
+		mul_qt_v3(rot, centr);
+		sub_v3_v3(vert->co, centr);
+		add_v3_v3(vert->co, loc);
+		mul_m4_v3(ob->imat, vert->co);
+
+	}
+
+	ob->recalc |= OB_RECALC_ALL;
+}
+
 /* ************************************** */
 /* Memory Management */
 
@@ -102,10 +489,31 @@
 			}
 		}
 		/* free dynamics world */
-		RB_dworld_delete(rbw->physics_world);
+		if (rbw->physics_world != NULL)
+			RB_dworld_delete(rbw->physics_world);
 	}
 	if (rbw->objects)
-		free(rbw->objects);
+		MEM_freeN(rbw->objects);
+
+	if (rbw->cache_index_map) {
+		MEM_freeN(rbw->cache_index_map);
+		rbw->cache_index_map = NULL;
+	}
+
+	if (rbw->cache_offset_map) {
+		MEM_freeN(rbw->cache_offset_map);
+		rbw->cache_offset_map = NULL;
+	}+		MEM_freeN(rbw->objects);
+
+	if (rbw->cache_index_map) {
+		MEM_freeN(rbw->cache_index_map);
+		rbw->cache_index_map = NULL;
+	}
+
+	if (rbw->cache_offset_map) {
+		MEM_freeN(rbw->cache_offset_map);
+		rbw->cache_offset_map = NULL;
+	}
 
 	/* free cache */
 	BKE_ptcache_free_list(&(rbw->ptcaches));
@@ -235,31 +643,129 @@
 }
 
 /* create collision shape of mesh - convex hull */
-static rbCollisionShape *rigidbody_get_shape_convexhull_from_mesh(Object *ob, float margin, bool *can_embed)
+static rbCollisionShape *rigidbody_get_shape_convexhull_from_mesh(Mesh *me, float margin, bool *can_embed)
 {
 	rbCollisionShape *shape = NULL;
-	DerivedMesh *dm = NULL;
-	MVert *mvert = NULL;
-	int totvert = 0;
-
-	if (ob->type == OB_MESH && ob->data) {
-		dm = rigidbody_get_mesh(ob);
-		mvert   = (dm) ? dm->getVertArray(dm) : NULL;
-		totvert = (dm) ? dm->getNumVerts(dm) : 0;
+	int totvert = me->totvert;
+	MVert *mvert = me->mvert;
+	if (me && totvert) {
+		shape = RB_shape_new_convex_hull((float *)mvert, sizeof(MVert), totvert, margin, can_embed);
 	}
 	else {
-		printf("ERROR: cannot make Convex Hull collision shape for non-Mesh object\n");
+		printf("ERROR: no vertices to define Convex Hull collision shape with\n");
 	}
 
-	if (totvert) {
+	return shape;
+}
+
+static rbCollisionShape *rigidbody_get_shape_convexhull_from_dm(DerivedMesh *dm, float margin, bool *can_embed)
+{
+	rbCollisionShape *shape = NULL;
+	int totvert = dm->getNumVerts(dm);
+	MVert *mvert = dm->getVertArray(dm);
+
+	if (dm && totvert) {	
 		shape = RB_shape_new_convex_hull((float *)mvert, sizeof(MVert), totvert, margin, can_embed);
 	}
 	else {
 		printf("ERROR: no vertices to define Convex Hull collision shape with\n");
 	}
 
-	if (dm && ob->rigidbody_object->mesh_source == RBO_MESH_BASE)
-		dm->release(dm);
+	return shape;
+}
+
+
+
+/* create collision shape of mesh - triangulated mesh
+ * returns NULL if creation fails.
+ */
+static rbCollisionShape *rigidbody_get_shape_trimesh_from_mesh_shard(DerivedMesh *dmm, Object *ob)
+{
+	rbCollisionShape *shape = NULL;
+
+	if (dmm) {
+		DerivedMesh *dm = NULL;
+		MVert *mvert;
+		MFace *mface;
+		int totvert;
+		int totface;
+		int tottris = 0;
+		int triangle_index = 0;
+
+		dm = CDDM_copy(dmm);
+
+		/* ensure mesh validity, then grab data */
+		if (dm == NULL)
+			return NULL;
+
+		DM_ensure_tessface(dm);
+
+		mvert   = (dm) ? dm->getVertArray(dm) : NULL;
+		totvert = (dm) ? dm->getNumVerts(dm) : 0;
+		mface   = (dm) ? dm->getTessFaceArray(dm) : NULL;
+		totface = (dm) ? dm->getNumTessFaces(dm) : 0;
+
+		/* sanity checking - potential case when no data will be present */
+		if ((totvert == 0) || (totface == 0)) {
+			printf("WARNING: no geometry data converted for Mesh Collision Shape (ob = %s)\n", ob->id.name + 2);
+		}
+		else {
+			rbMeshData *mdata;
+			int i;
+
+			/* count triangles */
+			for (i = 0; i < totface; i++) {
+				(mface[i].v4) ? (tottris += 2) : (tottris += 1);
+			}
+
+			/* init mesh data for collision shape */
+			mdata = RB_trimesh_data_new(tottris, totvert);
+
+			RB_trimesh_add_vertices(mdata, (float *)mvert, totvert, sizeof(MVert));
+
+			/* loop over all faces, adding them as triangles to the collision shape
+			 * (so for some faces, more than triangle will get added)
+			 */
+			for (i = 0; (i < totface) && (mface) && (mvert); i++, mface++) {
+				/* add first triangle - verts 1,2,3 */
+				RB_trimesh_add_triangle_indices(mdata, triangle_index, mface->v1, mface->v2, mface->v3);
+				triangle_index++;
+
+				/* add second triangle if needed - verts 1,3,4 */
+				if (mface->v4) {
+					RB_trimesh_add_triangle_indices(mdata, triangle_index, mface->v1, mface->v3, mface->v4);
+					triangle_index++;
+				}
+			}
+			RB_trimesh_finish(mdata);
+
+			/* construct collision shape
+			 *
+			 * These have been chosen to get better speed/accuracy tradeoffs with regards
+			 * to limitations of each:
+			 *    - BVH-Triangle Mesh: for passive objects only. Despite having greater
+			 *                         speed/accuracy, they cannot be used for moving objects.
+			 *    - GImpact Mesh:      for active objects. These are slower and less stable,
+			 *                         but are more flexible for general usage.
+			 */
+			if (ob->rigidbody_object->type == RBO_TYPE_PASSIVE) {
+				shape = RB_shape_new_trimesh(mdata);
+			}
+			else {
+				shape = RB_shape_new_gimpact_mesh(mdata);
+			}
+		}
+
+		/* cleanup temp data */
+		if (dm /*&& ob->rigidbody_object->mesh_source == RBO_MESH_BASE*/) {
+			dm->needsFree = 1;
+			dm->release(dm);
+			dm = NULL;
+		}
+	}
+	else {
+		printf("ERROR: cannot make Triangular Mesh collision shape for non-Mesh object\n");
+	}
 
 	return shape;
 }
@@ -430,9 +936,15 @@
 
 			if (!(rbo->flag & RBO_FLAG_USE_MARGIN) && has_volume)
 				hull_margin = 0.04f;
-			new_shape = rigidbody_get_shape_convexhull_from_mesh(ob, hull_margin, &can_embed);
+			if (ob->type == OB_MESH && ob->data) {
+				new_shape = rigidbody_get_shape_convexhull_from_mesh((Mesh *)ob->data, hull_margin, &can_embed);
+			}
+			else {
+				printf("ERROR: cannot make Convex Hull collision shape for non-Mesh object\n");
+			}
+
 			if (!(rbo->flag & RBO_FLAG_USE_MARGIN))
-				rbo->margin = (can_embed && has_volume) ? 0.04f : 0.0f;  /* RB_TODO ideally we shouldn't directly change the margin here */
+				rbo->margin = (can_embed && has_volume) ? 0.04f : 0.0f;      /* RB_TODO ideally we shouldn't directly change the margin here */
 			break;
 		case RB_SHAPE_TRIMESH:
 			new_shape = rigidbody_get_shape_trimesh_from_mesh(ob);
@@ -453,18 +965,30 @@
 
 /* --------------------- */
 
-/* helper function to calculate volume of rigidbody object */
-// TODO: allow a parameter to specify method used to calculate this?
-void BKE_rigidbody_calc_volume(Object *ob, float *r_vol)
+/* Create new physics sim collision shape for object and store it,
+ * or remove the existing one first and replace...
+ */
+void BKE_rigidbody_validate_sim_shard_shape(MeshIsland *mi, Object *ob, short rebuild)
 {
-	RigidBodyOb *rbo = ob->rigidbody_object;
-
-	float size[3]  = {1.0f, 1.0f, 1.0f};
+	RigidBodyOb *rbo = mi->rigidbody;
+	rbCollisionShape *new_shape = NULL;
+	float size[3] = {1.0f, 1.0f, 1.0f}, loc[3] = {0.0f, 0.0f, 0.0f};
 	float radius = 1.0f;
 	float height = 1.0f;
+	float capsule_height;
+	float hull_margin = 0.0f;
+	bool can_embed = true;
+	bool has_volume;
+	float min[3], max[3];
+	
+	/* sanity check */
+	if (rbo == NULL)
+		return;
 
-	float volume = 0.0f;
-
+	/* don't create a new shape if we already have one and don't want to rebuild it */
+	if (rbo->physics_shape && !rebuild)
+		return;
+	
 	/* if automatically determining dimensions, use the Object's boundbox
 	 *	- assume that all quadrics are standing upright on local z-axis
 	 *	- assume even distribution of mass around the Object's pivot
@@ -472,171 +996,164 @@
 	 *	- boundbox gives full width
 	 */
 	// XXX: all dimensions are auto-determined now... later can add stored settings for this
-	BKE_object_dimensions_get(ob, size);
+	/* get object dimensions without scaling */
+
+	INIT_MINMAX(min, max);
+	if (!DM_mesh_minmax(mi->physics_mesh, min, max)) {
+		min[0] = min[1] = min[2] = -1.0f;
+		max[0] = max[1] = max[2] = 1.0f;
+	}
+
+	mid_v3_v3v3(loc, min, max);
+	size[0] = (max[0] - min[0]) / 2.0f;
+	size[1] = (max[1] - min[1]) / 2.0f;
+	size[2] = (max[2] - min[2]) / 2.0f;
 
 	if (ELEM(rbo->shape, RB_SHAPE_CAPSULE, RB_SHAPE_CYLINDER, RB_SHAPE_CONE)) {
 		/* take radius as largest x/y dimension, and height as z-dimension */
-		radius = MAX2(size[0], size[1]) * 0.5f;
+		radius = MAX2(size[0], size[1]);
 		height = size[2];
 	}
 	else if (rbo->shape == RB_SHAPE_SPHERE) {
 		/* take radius to the largest dimension to try and encompass everything */
-		radius = max_fff(size[0], size[1], size[2]) * 0.5f;
+		radius = MAX3(size[0], size[1], size[2]);
 	}
-
-	/* calculate volume as appropriate  */
+	
+	/* create new shape */
 	switch (rbo->shape) {
 		case RB_SHAPE_BOX:
-			volume = size[0] * size[1] * size[2];
+			new_shape = RB_shape_new_box(size[0], size[1], size[2]);
 			break;
 
 		case RB_SHAPE_SPHERE:
-			volume = 4.0f / 3.0f * (float)M_PI * radius * radius * radius;
+			new_shape = RB_shape_new_sphere(radius);
 			break;
 
-		/* for now, assume that capsule is close enough to a cylinder... */
 		case RB_SHAPE_CAPSULE:
+			capsule_height = (height - radius) * 2.0f;
+			new_shape = RB_shape_new_capsule(radius, (capsule_height > 0.0f) ? capsule_height : 0.0f);
+			break;
+
 		case RB_SHAPE_CYLINDER:
-			volume = (float)M_PI * radius * radius * height;
+			new_shape = RB_shape_new_cylinder(radius, height);
 			break;
 
 		case RB_SHAPE_CONE:
-			volume = (float)M_PI / 3.0f * radius * radius * height;
+			new_shape = RB_shape_new_cone(radius, height * 2.0f);
 			break;
 
 		case RB_SHAPE_CONVEXH:
+			/* try to emged collision margin */
+			has_volume = (MIN3(size[0], size[1], size[2]) > 0.0f);
+
+			if (!(rbo->flag & RBO_FLAG_USE_MARGIN) && has_volume)
+				hull_margin = 0.04f;
+			new_shape = rigidbody_get_shape_convexhull_from_dm(mi->physics_mesh, hull_margin, &can_embed);
+			if (!(rbo->flag & RBO_FLAG_USE_MARGIN))
+				rbo->margin = (can_embed && has_volume) ? 0.04f : 0.0f;      /* RB_TODO ideally we shouldn't directly change the margin here */
+			break;
+
 		case RB_SHAPE_TRIMESH:
-		{
-			if (ob->type == OB_MESH) {
-				DerivedMesh *dm = rigidbody_get_mesh(ob);
-				MVert *mvert;
-				const MLoopTri *lt = NULL;
-				int totvert, tottri = 0;
-				const MLoop *mloop = NULL;
-				
-				/* ensure mesh validity, then grab data */
-				if (dm == NULL)
-					return;
-			
-				DM_ensure_looptri(dm);
-			
-				mvert   = dm->getVertArray(dm);
-				totvert = dm->getNumVerts(dm);
-				lt = dm->getLoopTriArray(dm);
-				tottri = dm->getNumLoopTri(dm);
-				mloop = dm->getLoopArray(dm);
-				
-				if (totvert > 0 && tottri > 0) {
-					BKE_mesh_calc_volume(mvert, totvert, lt, tottri, mloop, &volume, NULL);
-				}
-				
-				/* cleanup temp data */
-				if (ob->rigidbody_object->mesh_source == RBO_MESH_BASE) {
-					dm->release(dm);
-				}
-			}
-			else {
-				/* rough estimate from boundbox as fallback */
-				/* XXX could implement other types of geometry here (curves, etc.) */
-				volume = size[0] * size[1] * size[2];
-			}
+			new_shape = rigidbody_get_shape_trimesh_from_mesh_shard(mi->physics_mesh, ob);
 			break;
-		}
+	}
+	/* assign new collision shape if creation was successful */
+	if (new_shape) {
+		if (rbo->physics_shape)
+			RB_shape_delete(rbo->physics_shape);
+		rbo->physics_shape = new_shape;
+		RB_shape_set_margin(rbo->physics_shape, RBO_GET_MARGIN(rbo));
+	}
+	else { /* otherwise fall back to box shape */
+		rbo->shape = RB_SHAPE_BOX;
+		BKE_rigidbody_validate_sim_shard_shape(mi, ob, true);
+	}
+}
 
 #if 0 // XXX: not defined yet
 		case RB_SHAPE_COMPOUND:
 			volume = 0.0f;
 			break;
 #endif
-	}
 
-	/* return the volume calculated */
-	if (r_vol) *r_vol = volume;
-}
+/* --------------------- */
 
-void BKE_rigidbody_calc_center_of_mass(Object *ob, float r_center[3])
+/* Create physics sim representation of shard given RigidBody settings
+ * < rebuild: even if an instance already exists, replace it
+ */
+void BKE_rigidbody_validate_sim_shard(RigidBodyWorld *rbw, MeshIsland *mi, Object *ob, short rebuild)
 {
-	RigidBodyOb *rbo = ob->rigidbody_object;
+	RigidBodyOb *rbo = (mi) ? mi->rigidbody : NULL;
+	float loc[3];
+	float rot[4];
 
-	float size[3]  = {1.0f, 1.0f, 1.0f};
-	float height = 1.0f;
+	/* sanity checks:
+	 *	- object doesn't have RigidBody info already: then why is it here?
+	 */
+	if (rbo == NULL)
+		return;
 
-	zero_v3(r_center);
+	/* make sure collision shape exists */
+	/* FIXME we shouldn't always have to rebuild collision shapes when rebuilding objects, but it's needed for constraints to update correctly */
+	if (rbo->physics_shape == NULL || rebuild)
+		BKE_rigidbody_validate_sim_shard_shape(mi, ob, true);
+	
+	if (rbo->physics_object) {
+		if (rebuild == false)
+			RB_dworld_remove_body(rbw->physics_world, rbo->physics_object);
+	}
+	if (!rbo->physics_object || rebuild) {
+		/* remove rigid body if it already exists before creating a new one */
+		if (rbo->physics_object) {
+			RB_body_delete(rbo->physics_object);
+		}
 
-	/* if automatically determining dimensions, use the Object's boundbox
-	 *	- assume that all quadrics are standing upright on local z-axis
-	 *	- assume even distribution of mass around the Object's pivot
-	 *	  (i.e. Object pivot is centralized in boundbox)
-	 *	- boundbox gives full width
-	 */
-	// XXX: all dimensions are auto-determined now... later can add stored settings for this
-	BKE_object_dimensions_get(ob, size);
+		copy_v3_v3(loc, rbo->pos);
+		copy_v4_v4(rot, rbo->orn);
+		
+		rbo->physics_object = RB_body_new(rbo->physics_shape, loc, rot);
 
-	/* calculate volume as appropriate  */
-	switch (rbo->shape) {
-		case RB_SHAPE_BOX:
-		case RB_SHAPE_SPHERE:
-		case RB_SHAPE_CAPSULE:
-		case RB_SHAPE_CYLINDER:
-			break;
+		RB_body_set_friction(rbo->physics_object, rbo->friction);
+		RB_body_set_restitution(rbo->physics_object, rbo->restitution);
 
-		case RB_SHAPE_CONE:
-			/* take radius as largest x/y dimension, and height as z-dimension */
-			height = size[2];
-			/* cone is geometrically centered on the median,
-			 * center of mass is 1/4 up from the base
-			 */
-			r_center[2] = -0.25f * height;
-			break;
+		RB_body_set_damping(rbo->physics_object, rbo->lin_damping, rbo->ang_damping);
+		RB_body_set_sleep_thresh(rbo->physics_object, rbo->lin_sleep_thresh, rbo->ang_sleep_thresh);
+		RB_body_set_activation_state(rbo->physics_object, rbo->flag & RBO_FLAG_USE_DEACTIVATION);
 
-		case RB_SHAPE_CONVEXH:
-		case RB_SHAPE_TRIMESH:
-		{
-			if (ob->type == OB_MESH) {
-				DerivedMesh *dm = rigidbody_get_mesh(ob);
-				MVert *mvert;
-				const MLoopTri *looptri;
-				int totvert, tottri;
-				const MLoop *mloop;
-				
-				/* ensure mesh validity, then grab data */
-				if (dm == NULL)
-					return;
-			
-				DM_ensure_looptri(dm);
-			
-				mvert   = dm->getVertArray(dm);
-				totvert = dm->getNumVerts(dm);
-				looptri = dm->getLoopTriArray(dm);
-				tottri = dm->getNumLoopTri(dm);
-				mloop = dm->getLoopArray(dm);
-				
-				if (totvert > 0 && tottri > 0) {
-					BKE_mesh_calc_volume(mvert, totvert, looptri, tottri, mloop, NULL, r_center);
-				}
-				
-				/* cleanup temp data */
-				if (ob->rigidbody_object->mesh_source == RBO_MESH_BASE) {
-					dm->release(dm);
-				}
-			}
-			break;
-		}
+		if (rbo->type == RBO_TYPE_PASSIVE || rbo->flag & RBO_FLAG_START_DEACTIVATED)
+			RB_body_deactivate(rbo->physics_object);
+
+		RB_body_set_linear_factor(rbo->physics_object,
+		                          (ob->protectflag & OB_LOCK_LOCX) == 0,
+		                          (ob->protectflag & OB_LOCK_LOCY) == 0,
+		                          (ob->protectflag & OB_LOCK_LOCZ) == 0);
+		RB_body_set_angular_factor(rbo->physics_object,
+		                           (ob->protectflag & OB_LOCK_ROTX) == 0,
+		                           (ob->protectflag & OB_LOCK_ROTY) == 0,
+		                           (ob->protectflag & OB_LOCK_ROTZ) == 0);
+
+		RB_body_set_mass(rbo->physics_object, RBO_GET_MASS(rbo));
+		RB_body_set_kinematic_state(rbo->physics_object, rbo->flag & RBO_FLAG_KINEMATIC || rbo->flag & RBO_FLAG_DISABLED);
+	}
+
+	if (rbw && rbw->physics_world && rbo->physics_object)
+		RB_dworld_add_body(rbw->physics_world, rbo->physics_object, rbo->col_groups);
+
+	rbo->flag &= ~RBO_FLAG_NEEDS_VALIDATE;
+}
 
 #if 0 // XXX: not defined yet
 		case RB_SHAPE_COMPOUND:
 			volume = 0.0f;
 			break;
 #endif
-	}
-}
 
 /* --------------------- */
 
 /**
  * Create physics sim representation of object given RigidBody settings
  *
- * \param rebuild Even if an instance already exists, replace it
+ * < rebuild: even if an instance already exists, replace it
  */
 static void rigidbody_validate_sim_object(RigidBodyWorld *rbw, Object *ob, bool rebuild)
 {
@@ -804,9 +1321,191 @@
 					RB_constraint_set_damping_6dof_spring(rbc->physics_constraint, RB_LIMIT_LIN_Z, rbc->spring_damping_z);
 
 					RB_constraint_set_equilibrium_6dof_spring(rbc->physics_constraint);
-					/* fall-through */
+				/* fall-through */
 				case RBC_TYPE_6DOF:
-					if (rbc->type == RBC_TYPE_6DOF) /* a litte awkward but avoids duplicate code for limits */
+					if (rbc->type == RBC_TYPE_6DOF)     /* a litte awkward but avoids duplicate code for limits */
+						rbc->physics_constraint = RB_constraint_new_6dof(loc, rot, rb1, rb2);
+
+					if (rbc->flag & RBC_FLAG_USE_LIMIT_LIN_X)
+						RB_constraint_set_limits_6dof(rbc->physics_constraint, RB_LIMIT_LIN_X, rbc->limit_lin_x_lower, rbc->limit_lin_x_upper);
+					else
+						RB_constraint_set_limits_6dof(rbc->physics_constraint, RB_LIMIT_LIN_X, 0.0f, -1.0f);
+
+					if (rbc->flag & RBC_FLAG_USE_LIMIT_LIN_Y)
+						RB_constraint_set_limits_6dof(rbc->physics_constraint, RB_LIMIT_LIN_Y, rbc->limit_lin_y_lower, rbc->limit_lin_y_upper);
+					else
+						RB_constraint_set_limits_6dof(rbc->physics_constraint, RB_LIMIT_LIN_Y, 0.0f, -1.0f);
+
+					if (rbc->flag & RBC_FLAG_USE_LIMIT_LIN_Z)
+						RB_constraint_set_limits_6dof(rbc->physics_constraint, RB_LIMIT_LIN_Z, rbc->limit_lin_z_lower, rbc->limit_lin_z_upper);
+					else
+						RB_constraint_set_limits_6dof(rbc->physics_constraint, RB_LIMIT_LIN_Z, 0.0f, -1.0f);
+
+					if (rbc->flag & RBC_FLAG_USE_LIMIT_ANG_X)
+						RB_constraint_set_limits_6dof(rbc->physics_constraint, RB_LIMIT_ANG_X, rbc->limit_ang_x_lower, rbc->limit_ang_x_upper);
+					else
+						RB_constraint_set_limits_6dof(rbc->physics_constraint, RB_LIMIT_ANG_X, 0.0f, -1.0f);
+
+					if (rbc->flag & RBC_FLAG_USE_LIMIT_ANG_Y)
+						RB_constraint_set_limits_6dof(rbc->physics_constraint, RB_LIMIT_ANG_Y, rbc->limit_ang_y_lower, rbc->limit_ang_y_upper);
+					else
+						RB_constraint_set_limits_6dof(rbc->physics_constraint, RB_LIMIT_ANG_Y, 0.0f, -1.0f);
+
+					if (rbc->flag & RBC_FLAG_USE_LIMIT_ANG_Z)
+						RB_constraint_set_limits_6dof(rbc->physics_constraint, RB_LIMIT_ANG_Z, rbc->limit_ang_z_lower, rbc->limit_ang_z_upper);
+					else
+						RB_constraint_set_limits_6dof(rbc->physics_constraint, RB_LIMIT_ANG_Z, 0.0f, -1.0f);
+					break;
+				case RBC_TYPE_MOTOR:
+					rbc->physics_constraint = RB_constraint_new_motor(loc, rot, rb1, rb2);
+
+					RB_constraint_set_enable_motor(rbc->physics_constraint, rbc->flag & RBC_FLAG_USE_MOTOR_LIN, rbc->flag & RBC_FLAG_USE_MOTOR_ANG);
+					RB_constraint_set_max_impulse_motor(rbc->physics_constraint, rbc->motor_lin_max_impulse, rbc->motor_ang_max_impulse);
+					RB_constraint_set_target_velocity_motor(rbc->physics_constraint, rbc->motor_lin_target_velocity, rbc->motor_ang_target_velocity);
+					break;
+			}
+		}
+		else { /* can't create constraint without both rigid bodies */
+			return;
+		}
+
+		RB_constraint_set_enabled(rbc->physics_constraint, rbc->flag & RBC_FLAG_ENABLED);
+
+		if (rbc->flag & RBC_FLAG_USE_BREAKING)
+			RB_constraint_set_breaking_threshold(rbc->physics_constraint, rbc->breaking_threshold);
+		else
+			RB_constraint_set_breaking_threshold(rbc->physics_constraint, FLT_MAX);
+
+		if (rbc->flag & RBC_FLAG_OVERRIDE_SOLVER_ITERATIONS)
+			RB_constraint_set_solver_iterations(rbc->physics_constraint, rbc->num_solver_iterations);
+		else
+			RB_constraint_set_solver_iterations(rbc->physics_constraint, -1);
+	}
+
+	if (rbw && rbw->physics_world && rbc->physics_constraint) {
+		RB_dworld_add_constraint(rbw->physics_world, rbc->physics_constraint, rbc->flag & RBC_FLAG_DISABLE_COLLISIONS);
+	}
+}
+
+/* Create physics sim representation of constraint given rigid body constraint settings
+ * < rebuild: even if an instance already exists, replace it
+ */
+void BKE_rigidbody_validate_sim_shard_constraint(RigidBodyWorld *rbw, RigidBodyShardCon *rbc, short rebuild)
+{
+	float loc[3];
+	float rot[4];
+	float lin_lower;
+	float lin_upper;
+	float ang_lower;
+	float ang_upper;
+	rbRigidBody *rb1;
+	rbRigidBody *rb2;
+
+	/* sanity checks:
+	 *	- object should have a rigid body constraint
+	 *  - rigid body constraint should have at least one constrained object
+	 */
+	if (rbc == NULL) {
+		return;
+	}
+
+	if (ELEM(NULL, rbc->mi1, rbc->mi1->rigidbody, rbc->mi2, rbc->mi2->rigidbody)) {
+		if (rbc->physics_constraint) {
+			RB_dworld_remove_constraint(rbw->physics_world, rbc->physics_constraint);
+			RB_constraint_delete(rbc->physics_constraint);
+			rbc->physics_constraint = NULL;
+		}
+		return;
+	}
+	
+	if (rbc->mi1->rigidbody)
+	{
+		rb1 = rbc->mi1->rigidbody->physics_object;
+	}
+	
+	if (rbc->mi2->rigidbody)
+	{
+		rb2 = rbc->mi2->rigidbody->physics_object;
+	}
+
+	if (rbc->physics_constraint) {
+		if (rebuild == false)
+			RB_dworld_remove_constraint(rbw->physics_world, rbc->physics_constraint);
+	}
+	if (rbc->physics_constraint == NULL || rebuild) {
+
+		/* remove constraint if it already exists before creating a new one */
+		if (rbc->physics_constraint) {
+			RB_constraint_delete(rbc->physics_constraint);
+			rbc->physics_constraint = NULL;
+		}
+
+		/* do this for all constraints */
+		copy_v3_v3(loc, rbc->mi1->rigidbody->pos);
+		copy_v4_v4(rot, rbc->mi1->rigidbody->orn);
+
+		if (rb1 && rb2) {
+			switch (rbc->type) {
+				case RBC_TYPE_POINT:
+					rbc->physics_constraint = RB_constraint_new_point(loc, rb1, rb2);
+					break;
+				case RBC_TYPE_FIXED:
+					rbc->physics_constraint = RB_constraint_new_fixed(loc, rot, rb1, rb2);
+					break;
+				case RBC_TYPE_HINGE:
+					rbc->physics_constraint = RB_constraint_new_hinge(loc, rot, rb1, rb2);
+					if (rbc->flag & RBC_FLAG_USE_LIMIT_ANG_Z) {
+						RB_constraint_set_limits_hinge(rbc->physics_constraint, rbc->limit_ang_z_lower, rbc->limit_ang_z_upper);
+					}
+					else
+						RB_constraint_set_limits_hinge(rbc->physics_constraint, 0.0f, -1.0f);
+					break;
+				case RBC_TYPE_SLIDER:
+					rbc->physics_constraint = RB_constraint_new_slider(loc, rot, rb1, rb2);
+					if (rbc->flag & RBC_FLAG_USE_LIMIT_LIN_X)
+						RB_constraint_set_limits_slider(rbc->physics_constraint, rbc->limit_lin_x_lower, rbc->limit_lin_x_upper);
+					else
+						RB_constraint_set_limits_slider(rbc->physics_constraint, 0.0f, -1.0f);
+					break;
+				case RBC_TYPE_PISTON:
+					rbc->physics_constraint = RB_constraint_new_piston(loc, rot, rb1, rb2);
+					if (rbc->flag & RBC_FLAG_USE_LIMIT_LIN_X) {
+						lin_lower = rbc->limit_lin_x_lower;
+						lin_upper = rbc->limit_lin_x_upper;
+					}
+					else {
+						lin_lower = 0.0f;
+						lin_upper = -1.0f;
+					}
+					if (rbc->flag & RBC_FLAG_USE_LIMIT_ANG_X) {
+						ang_lower = rbc->limit_ang_x_lower;
+						ang_upper = rbc->limit_ang_x_upper;
+					}
+					else {
+						ang_lower = 0.0f;
+						ang_upper = -1.0f;
+					}
+					RB_constraint_set_limits_piston(rbc->physics_constraint, lin_lower, lin_upper, ang_lower, ang_upper);
+					break;
+				case RBC_TYPE_6DOF_SPRING:
+					rbc->physics_constraint = RB_constraint_new_6dof_spring(loc, rot, rb1, rb2);
+
+					RB_constraint_set_spring_6dof_spring(rbc->physics_constraint, RB_LIMIT_LIN_X, rbc->flag & RBC_FLAG_USE_SPRING_X);
+					RB_constraint_set_stiffness_6dof_spring(rbc->physics_constraint, RB_LIMIT_LIN_X, rbc->spring_stiffness_x);
+					RB_constraint_set_damping_6dof_spring(rbc->physics_constraint, RB_LIMIT_LIN_X, rbc->spring_damping_x);
+
+					RB_constraint_set_spring_6dof_spring(rbc->physics_constraint, RB_LIMIT_LIN_Y, rbc->flag & RBC_FLAG_USE_SPRING_Y);
+					RB_constraint_set_stiffness_6dof_spring(rbc->physics_constraint, RB_LIMIT_LIN_Y, rbc->spring_stiffness_y);
+					RB_constraint_set_damping_6dof_spring(rbc->physics_constraint, RB_LIMIT_LIN_Y, rbc->spring_damping_y);
+
+					RB_constraint_set_spring_6dof_spring(rbc->physics_constraint, RB_LIMIT_LIN_Z, rbc->flag & RBC_FLAG_USE_SPRING_Z);
+					RB_constraint_set_stiffness_6dof_spring(rbc->physics_constraint, RB_LIMIT_LIN_Z, rbc->spring_stiffness_z);
+					RB_constraint_set_damping_6dof_spring(rbc->physics_constraint, RB_LIMIT_LIN_Z, rbc->spring_damping_z);
+
+					RB_constraint_set_equilibrium_6dof_spring(rbc->physics_constraint);
+				/* fall through */
+				case RBC_TYPE_6DOF:
+					if (rbc->type == RBC_TYPE_6DOF)     /* a litte awkward but avoids duplicate code for limits */
 						rbc->physics_constraint = RB_constraint_new_6dof(loc, rot, rb1, rb2);
 
 					if (rbc->flag & RBC_FLAG_USE_LIMIT_LIN_X)
@@ -904,27 +1603,99 @@
 	 *	- there must be a valid scene to add world to
 	 *	- there mustn't be a sim world using this group already
 	 */
-	if (scene == NULL)
+	if (scene == NULL)
+		return NULL;
+
+	/* create a new sim world */
+	rbw = MEM_callocN(sizeof(RigidBodyWorld), "RigidBodyWorld");
+
+	/* set default settings */
+	rbw->effector_weights = BKE_add_effector_weights(NULL);
+
+	rbw->ltime = PSFRA;
+
+	rbw->time_scale = 1.0f;
+
+	rbw->steps_per_second = 60; /* Bullet default (60 Hz) */
+	rbw->num_solver_iterations = 10; /* 10 is bullet default */
+
+	rbw->pointcache = BKE_ptcache_add(&(rbw->ptcaches));
+	rbw->pointcache->step = 1;
+	rbw->object_changed = false;
+	rbw->refresh_modifiers = false;
+
+	rbw->objects = MEM_mallocN(sizeof(Object *), "objects");
+	rbw->cache_index_map = MEM_mallocN(sizeof(RigidBodyOb *), "cache_index_map");
+	rbw->cache_offset_map = MEM_mallocN(sizeof(int), "cache_offset_map");
+
+	/* return this sim world */
+	return rbw;
+}
+
+/* Add rigid body settings to the specified shard */
+RigidBodyOb *BKE_rigidbody_create_shard(Scene *scene, Object *ob, MeshIsland *mi)
+{
+	RigidBodyOb *rbo;
+	RigidBodyWorld *rbw = BKE_rigidbody_get_world(scene);
+	float centr[3], size[3];
+
+	/* sanity checks
+	 *	- rigidbody world must exist
+	 *	- shard must exist
+	 *	- cannot add rigid body if it already exists
+	 */
+	if (mi == NULL || (mi->rigidbody != NULL))
 		return NULL;
 
-	/* create a new sim world */
-	rbw = MEM_callocN(sizeof(RigidBodyWorld), "RigidBodyWorld");
+	if (ob->type != OB_MESH && ob->type != OB_FONT && ob->type != OB_CURVE && ob->type != OB_SURF) {
+		return NULL;
+	}
+	
+	if ((((Mesh *)ob->data)->totvert == 0) && (ob->type == OB_MESH)) {
+		return NULL;
+	}
 
-	/* set default settings */
-	rbw->effector_weights = BKE_add_effector_weights(NULL);
+	/* Add rigid body world and group if they don't exist for convenience */
+	if (rbw == NULL) {
+		rbw = BKE_rigidbody_create_world(scene);
+		BKE_rigidbody_validate_sim_world(scene, rbw, false);
+		scene->rigidbody_world = rbw;
+	}
+	if (rbw->group == NULL) {
+		rbw->group = BKE_group_add(G.main, "RigidBodyWorld");
+	}
 
-	rbw->ltime = PSFRA;
+	/* make rigidbody object settings */
+	if (ob->rigidbody_object == NULL) {
+		ob->rigidbody_object = BKE_rigidbody_create_object(scene, ob, mi->ground_weight > 0.5f ? RBO_TYPE_PASSIVE : RBO_TYPE_ACTIVE);
+	}
+	else {
+		ob->rigidbody_object->type = mi->ground_weight > 0.5f ? RBO_TYPE_PASSIVE : RBO_TYPE_ACTIVE;
+		ob->rigidbody_object->flag |= RBO_FLAG_NEEDS_VALIDATE;
+	}
 
-	rbw->time_scale = 1.0f;
+	if (!BKE_group_object_exists(rbw->group, ob))
+		BKE_group_object_add(rbw->group, ob, scene, NULL);
 
-	rbw->steps_per_second = 60; /* Bullet default (60 Hz) */
-	rbw->num_solver_iterations = 10; /* 10 is bullet default */
+	DAG_id_tag_update(&ob->id, OB_RECALC_OB);
 
-	rbw->pointcache = BKE_ptcache_add(&(rbw->ptcaches));
-	rbw->pointcache->step = 1;
+	/* since we are always member of an object, dupe its settings,
+	 * create new settings data, and link it up */
+	rbo = BKE_rigidbody_copy_object(ob);
+	rbo->type = mi->ground_weight > 0.5f ? RBO_TYPE_PASSIVE : RBO_TYPE_ACTIVE;
 
-	/* return this sim world */
-	return rbw;
+	/* set initial transform */
+	mat4_to_loc_quat(rbo->pos, rbo->orn, ob->obmat);
+	mat4_to_size(size, ob->obmat);
+
+	//add initial "offset" (centroid), maybe subtract ob->obmat ?? (not sure)
+	copy_v3_v3(centr, mi->centroid);
+	mul_v3_v3(centr, size);
+	mul_qt_v3(rbo->orn, centr);
+	add_v3_v3(rbo->pos, centr);
+
+	/* return this object */
+	return rbo;
 }
 
 RigidBodyWorld *BKE_rigidbody_world_copy(RigidBodyWorld *rbw)
@@ -938,11 +1709,13 @@
 	if (rbwn->constraints)
 		id_us_plus(&rbwn->constraints->id);
 
-	rbwn->pointcache = BKE_ptcache_copy_list(&rbwn->ptcaches, &rbw->ptcaches, false);
+	rbwn->pointcache = BKE_ptcache_copy_list(&rbwn->ptcaches, &rbw->ptcaches, true);
 
 	rbwn->objects = NULL;
 	rbwn->physics_world = NULL;
 	rbwn->numbodies = 0;
+	rbwn->cache_index_map = NULL;
+	rbwn->cache_offset_map = NULL;
 
 	return rbwn;
 }
@@ -1073,6 +1846,66 @@
 	return rbc;
 }
 
+/* Add rigid body constraint to the specified object */
+RigidBodyShardCon *BKE_rigidbody_create_shard_constraint(Scene *scene, short type)
+{
+	RigidBodyShardCon *rbc;
+	RigidBodyWorld *rbw = scene->rigidbody_world;
+
+	/* sanity checks
+	 *	- rigidbody world must exist
+	 *	- object must exist
+	 *	- cannot add constraint if it already exists
+	 */
+
+	/* create new settings data, and link it up */
+	rbc = MEM_callocN(sizeof(RigidBodyShardCon), "RigidBodyCon");
+
+	/* set default settings */
+	rbc->type = type;
+
+	rbc->mi1 = NULL;
+	rbc->mi2 = NULL;
+
+	rbc->flag |= RBC_FLAG_ENABLED;
+	rbc->flag &= ~RBC_FLAG_DISABLE_COLLISIONS;
+	rbc->flag |= RBC_FLAG_USE_BREAKING;
+
+	rbc->breaking_threshold = 1.0f; /* no good default here, just use 10 for now */
+	rbc->num_solver_iterations = 10; /* 10 is Bullet default */
+
+	rbc->limit_lin_x_lower = -1.0f;
+	rbc->limit_lin_x_upper = 1.0f;
+	rbc->limit_lin_y_lower = -1.0f;
+	rbc->limit_lin_y_upper = 1.0f;
+	rbc->limit_lin_z_lower = -1.0f;
+	rbc->limit_lin_z_upper = 1.0f;
+	rbc->limit_ang_x_lower = -M_PI_4;
+	rbc->limit_ang_x_upper = M_PI_4;
+	rbc->limit_ang_y_lower = -M_PI_4;
+	rbc->limit_ang_y_upper = M_PI_4;
+	rbc->limit_ang_z_lower = -M_PI_4;
+	rbc->limit_ang_z_upper = M_PI_4;
+
+	rbc->spring_damping_x = 0.5f;
+	rbc->spring_damping_y = 0.5f;
+	rbc->spring_damping_z = 0.5f;
+	rbc->spring_stiffness_x = 10.0f;
+	rbc->spring_stiffness_y = 10.0f;
+	rbc->spring_stiffness_z = 10.0f;
+
+	rbc->motor_lin_max_impulse = 1.0f;
+	rbc->motor_lin_target_velocity = 1.0f;
+	rbc->motor_ang_max_impulse = 1.0f;
+	rbc->motor_ang_target_velocity = 1.0f;
+
+	/* flag cache as outdated */
+	BKE_rigidbody_cache_reset(rbw);
+
+	/* return this object */
+	return rbc;
+}
+
 /* ************************************** */
 /* Utilities API */
 
@@ -1089,46 +1922,146 @@
 	return scene->rigidbody_world;
 }
 
+void BKE_rigidbody_remove_shard_con(Scene *scene, RigidBodyShardCon *con)
+{
+	RigidBodyWorld *rbw = scene->rigidbody_world;
+	if (rbw && rbw->physics_world && con->physics_constraint) {
+		RB_dworld_remove_constraint(rbw->physics_world, con->physics_constraint);
+		RB_constraint_delete(con->physics_constraint);
+		con->physics_constraint = NULL;
+	}
+}
+
+void BKE_rigidbody_remove_shard(Scene *scene, MeshIsland *mi)
+{
+	RigidBodyWorld *rbw = scene->rigidbody_world;
+	int i = 0;
+	
+	/* rbw can be NULL directly after linking / appending objects without their original scenes
+	 * if an attempt to refracture is done then, this would crash here with null pointer access */
+	if (mi->rigidbody != NULL && rbw != NULL) {
+		
+		RigidBodyShardCon *con;
+		for (i = 0; i < mi->participating_constraint_count; i++) {
+			con = mi->participating_constraints[i];
+			BKE_rigidbody_remove_shard_con(scene, con);
+		}
+		
+		if (rbw->physics_world && mi->rigidbody && mi->rigidbody->physics_object)
+			RB_dworld_remove_body(rbw->physics_world, mi->rigidbody->physics_object);
+
+		if (mi->rigidbody->physics_object) {
+			RB_body_delete(mi->rigidbody->physics_object);
+			mi->rigidbody->physics_object = NULL;
+		}
+
+		if (mi->rigidbody->physics_shape) {
+			RB_shape_delete(mi->rigidbody->physics_shape);
+			mi->rigidbody->physics_shape = NULL;
+		}
+		
+		/* this SHOULD be the correct global index */
+		/* need to check whether we didnt create the rigidbody world manually already, prior to fracture, in this
+		 * case cache_index_map might be not initialized ! checking numbodies here, they should be 0 in a fresh
+		 * rigidbody world */
+		if (rbw->cache_index_map != NULL && rbw->numbodies > 0)
+			rbw->cache_index_map[mi->linear_index] = NULL;
+	}
+}
+
 void BKE_rigidbody_remove_object(Scene *scene, Object *ob)
 {
 	RigidBodyWorld *rbw = scene->rigidbody_world;
 	RigidBodyOb *rbo = ob->rigidbody_object;
 	RigidBodyCon *rbc;
 	GroupObject *go;
+	ModifierData *md;
+	FractureModifierData *rmd;
+	RigidBodyShardCon *con;
+	MeshIsland *mi;
 	int i;
+	bool modFound = false;
 
 	if (rbw) {
-		/* remove from rigidbody world, free object won't do this */
-		if (rbw->physics_world && rbo->physics_object)
-			RB_dworld_remove_body(rbw->physics_world, rbo->physics_object);
+		for (md = ob->modifiers.first; md; md = md->next) {
 
-		/* remove object from array */
-		if (rbw && rbw->objects) {
-			for (i = 0; i < rbw->numbodies; i++) {
-				if (rbw->objects[i] == ob) {
-					rbw->objects[i] = NULL;
-					break;
+			if (md->type == eModifierType_Fracture)
+			{
+				rmd = (FractureModifierData *)md;
+				modFound = true;
+				for (con = rmd->meshConstraints.first; con; con = con->next) {
+					if (rbw && rbw->physics_world && con->physics_constraint) {
+						RB_dworld_remove_constraint(rbw->physics_world, con->physics_constraint);
+						RB_constraint_delete(con->physics_constraint);
+						con->physics_constraint = NULL;
+					}
+				}
+				for (mi = rmd->meshIslands.first; mi; mi = mi->next) {
+					if (mi->rigidbody != NULL) {
+						if (rbw->physics_world && mi->rigidbody && mi->rigidbody->physics_object)
+							RB_dworld_remove_body(rbw->physics_world, mi->rigidbody->physics_object);
+						if (mi->rigidbody->physics_object) {
+							RB_body_delete(mi->rigidbody->physics_object);
+							mi->rigidbody->physics_object = NULL;
+						}
+
+						if (mi->rigidbody->physics_shape) {
+							RB_shape_delete(mi->rigidbody->physics_shape);
+							mi->rigidbody->physics_shape = NULL;
+						}
+						
+						/* this SHOULD be the correct global index*/
+						if (rbw->cache_index_map)
+							rbw->cache_index_map[mi->linear_index] = NULL;
+						MEM_freeN(mi->rigidbody);
+						mi->rigidbody = NULL;
+					}
 				}
 			}
 		}
-
-		/* remove object from rigid body constraints */
-		if (rbw->constraints) {
-			for (go = rbw->constraints->gobject.first; go; go = go->next) {
-				Object *obt = go->ob;
-				if (obt && obt->rigidbody_constraint) {
-					rbc = obt->rigidbody_constraint;
-					if (ELEM(ob, rbc->ob1, rbc->ob2)) {
-						BKE_rigidbody_remove_constraint(scene, obt);
+		if (!modFound) {
+			/* remove from rigidbody world, free object won't do this */
+			if (rbw->physics_world && rbo->physics_object)
+				RB_dworld_remove_body(rbw->physics_world, rbo->physics_object);
+
+			/* remove object from array */
+			if (rbw && rbw->objects) {
+				for (i = 0; i < rbw->numbodies; i++) {
+					int index = rbw->cache_offset_map[i];
+					if (rbw->objects[index] == ob) {
+						rbw->objects[index] = NULL;
+					}
+					
+					if (rbo == rbw->cache_index_map[i]) {
+						rbw->cache_index_map[i] = NULL;
+						break;
 					}
 				}
 			}
+
+			/* remove object from rigid body constraints */
+			if (rbw->constraints) {
+				for (go = rbw->constraints->gobject.first; go; go = go->next) {
+					Object *obt = go->ob;
+					if (obt && obt->rigidbody_constraint) {
+						rbc = obt->rigidbody_constraint;
+						if (rbc->ob1 == ob) {
+							rbc->ob1 = NULL;
+							rbc->flag |= RBC_FLAG_NEEDS_VALIDATE;
+						}
+						if (rbc->ob2 == ob) {
+							rbc->ob2 = NULL;
+							rbc->flag |= RBC_FLAG_NEEDS_VALIDATE;
+						}
+					}
+				}
+			}			
+
+			/* remove object's settings */
+			BKE_rigidbody_free_object(ob);
 		}
 	}
 
-	/* remove object's settings */
-	BKE_rigidbody_free_object(ob);
-
 	/* flag cache as outdated */
 	BKE_rigidbody_cache_reset(rbw);
 }
@@ -1149,6 +2082,41 @@
 	BKE_rigidbody_cache_reset(rbw);
 }
 
+static int rigidbody_group_count_items(const ListBase *group, int *r_num_objects, int *r_num_shards)
+{
+	int num_gobjects = 0;
+	ModifierData *md;
+	FractureModifierData *rmd;
+	GroupObject *gob;
+
+	if (r_num_objects == NULL || r_num_shards == NULL)
+	{
+		return num_gobjects;
+	}
+
+	*r_num_objects = 0;
+	*r_num_shards = 0;
+
+	for (gob = group->first; gob; gob = gob->next) {
+		bool found_modifiers = false;
+		for (md = gob->ob->modifiers.first; md; md = md->next) {
+			if (md->type == eModifierType_Fracture) {
+				rmd = (FractureModifierData *)md;
+				if (isModifierActive(rmd))
+				{
+					found_modifiers = true;
+					*r_num_shards += BLI_countlist(&rmd->meshIslands);
+				}
+			}
+		}
+		if (found_modifiers == false) {
+			(*r_num_objects)++;
+		}
+		num_gobjects++;
+	}
+
+	return num_gobjects;
+}
 
 /* ************************************** */
 /* Simulation Interface - Bullet */
@@ -1157,18 +2125,64 @@
 static void rigidbody_update_ob_array(RigidBodyWorld *rbw)
 {
 	GroupObject *go;
-	int i, n;
-
-	n = BLI_listbase_count(&rbw->group->gobject);
-
-	if (rbw->numbodies != n) {
-		rbw->numbodies = n;
-		rbw->objects = realloc(rbw->objects, sizeof(Object *) * rbw->numbodies);
+	ModifierData *md;
+	FractureModifierData *rmd;
+	MeshIsland *mi;
+	int i, j, l = 0, m = 0, n = 0, counter = 0;
+	bool ismapped = false;
+	
+	if (rbw->objects != NULL) {
+		MEM_freeN(rbw->objects);
+		rbw->objects = NULL;
+	}
+	
+	if (rbw->cache_index_map != NULL) {
+		MEM_freeN(rbw->cache_index_map);
+		rbw->cache_index_map = NULL;
+	}
+	
+	if (rbw->cache_offset_map != NULL) {
+		MEM_freeN(rbw->cache_offset_map);
+		rbw->cache_offset_map = NULL;
 	}
 
+	l = rigidbody_group_count_items(&rbw->group->gobject, &m, &n);
+
+	rbw->numbodies = m + n;
+	rbw->objects = MEM_mallocN(sizeof(Object *) * l, "objects");
+	rbw->cache_index_map = MEM_mallocN(sizeof(RigidBodyOb *) * rbw->numbodies, "cache_index_map");
+	rbw->cache_offset_map = MEM_mallocN(sizeof(int) * rbw->numbodies, "cache_offset_map");
+	printf("RigidbodyCount changed: %d\n", rbw->numbodies);
+
 	for (go = rbw->group->gobject.first, i = 0; go; go = go->next, i++) {
 		Object *ob = go->ob;
 		rbw->objects[i] = ob;
+
+		for (md = ob->modifiers.first; md; md = md->next) {
+
+			if (md->type == eModifierType_Fracture) {
+				rmd = (FractureModifierData *)md;
+				if (isModifierActive(rmd)) {
+					for (mi = rmd->meshIslands.first, j = 0; mi; mi = mi->next) {
+						rbw->cache_index_map[counter] = mi->rigidbody; /* map all shards of an object to this object index*/
+						rbw->cache_offset_map[counter] = i;
+						mi->linear_index = counter;
+						counter++;
+						j++;
+					}
+					ismapped = true;
+					break;
+				}
+			}
+		}
+
+		if (!ismapped) {
+			rbw->cache_index_map[counter] = ob->rigidbody_object; /*1 object 1 index here (normal case)*/
+			rbw->cache_offset_map[counter] = i;
+			counter++;
+		}
+
+		ismapped = false;
 	}
 }
 
@@ -1192,11 +2206,11 @@
 	rigidbody_update_ob_array(rbw);
 }
 
-static void rigidbody_update_sim_ob(Scene *scene, RigidBodyWorld *rbw, Object *ob, RigidBodyOb *rbo)
+static void rigidbody_update_sim_ob(Scene *scene, RigidBodyWorld *rbw, Object *ob, RigidBodyOb *rbo, float centroid[3])
 {
 	float loc[3];
 	float rot[4];
-	float scale[3];
+	float scale[3], centr[3];
 
 	/* only update if rigid body exists */
 	if (rbo->physics_object == NULL)
@@ -1213,6 +2227,8 @@
 		}
 	}
 
+	copy_v3_v3(centr, centroid);
+
 	mat4_decompose(loc, rot, scale, ob->obmat);
 
 	/* update scale for all objects */
@@ -1229,6 +2245,9 @@
 
 	/* update rigid body location and rotation for kinematic bodies */
 	if (rbo->flag & RBO_FLAG_KINEMATIC || (ob->flag & SELECT && G.moving & G_TRANSFORM_OBJ)) {
+		mul_v3_v3(centr, scale);
+		mul_qt_v3(rot, centr);
+		add_v3_v3(loc, centr);
 		RB_body_activate(rbo->physics_object);
 		RB_body_set_loc_rot(rbo->physics_object, loc, rot);
 	}
@@ -1249,6 +2268,8 @@
 			// XXX: this can create some inaccuracies with sim position, but is probably better than using unsimulated vals?
 			RB_body_get_position(rbo->physics_object, eff_loc);
 			RB_body_get_linear_velocity(rbo->physics_object, eff_vel);
+			//mul_v3_v3(centr, scale);
+			//add_v3_v3(eff_loc, centr);
 
 			pd_point_from_loc(scene, eff_loc, eff_vel, 0, &epoint);
 
@@ -1276,84 +2297,231 @@
 	 */
 }
 
-/**
- * Updates and validates world, bodies and shapes.
- *
- * \param rebuild Rebuild entire simulation
+static void validateShard(RigidBodyWorld *rbw, MeshIsland *mi, Object *ob, int rebuild)
+{
+	if (mi == NULL || mi->rigidbody == NULL) {
+		return;
+	}
+	
+	if (rebuild) { // && (mi->rigidbody->flag & RBO_FLAG_NEEDS_VALIDATE)) {
+		/* World has been rebuilt so rebuild object */
+		BKE_rigidbody_validate_sim_shard(rbw, mi, ob, true);
+	}
+	else if (mi->rigidbody->flag & RBO_FLAG_NEEDS_VALIDATE) {
+		BKE_rigidbody_validate_sim_shard(rbw, mi, ob, false);
+	}
+	/* refresh shape... */
+	if (mi->rigidbody->flag & RBO_FLAG_NEEDS_RESHAPE) {
+		/* mesh/shape data changed, so force shape refresh */
+		BKE_rigidbody_validate_sim_shard_shape(mi, ob, true);
+		/* now tell RB sim about it */
+		// XXX: we assume that this can only get applied for active/passive shapes that will be included as rigidbodies
+		RB_body_set_collision_shape(mi->rigidbody->physics_object, mi->rigidbody->physics_shape);
+	}
+	mi->rigidbody->flag &= ~(RBO_FLAG_NEEDS_VALIDATE | RBO_FLAG_NEEDS_RESHAPE);
+}
+
+/* Updates and validates world, bodies and shapes.
+ * < rebuild: rebuild entire simulation
  */
 static void rigidbody_update_simulation(Scene *scene, RigidBodyWorld *rbw, bool rebuild)
 {
 	GroupObject *go;
+	MeshIsland *mi = NULL;
+	float centroid[3] = {0, 0, 0};
+	RigidBodyShardCon *rbsc;
 
 	/* update world */
-	if (rebuild)
+	if (rebuild) {
 		BKE_rigidbody_validate_sim_world(scene, rbw, true);
-	rigidbody_update_sim_world(scene, rbw);
-
-	/* XXX TODO For rebuild: remove all constraints first.
-	 * Otherwise we can end up deleting objects that are still
-	 * referenced by constraints, corrupting bullet's internal list.
-	 * 
-	 * Memory management needs redesign here, this is just a dirty workaround.
-	 */
-	if (rebuild && rbw->constraints) {
-		for (go = rbw->constraints->gobject.first; go; go = go->next) {
-			Object *ob = go->ob;
-			if (ob) {
-				RigidBodyCon *rbc = ob->rigidbody_constraint;
-				if (rbc && rbc->physics_constraint) {
-					RB_dworld_remove_constraint(rbw->physics_world, rbc->physics_constraint);
-					RB_constraint_delete(rbc->physics_constraint);
-					rbc->physics_constraint = NULL;
-				}
-			}
-		}
+		rigidbody_update_sim_world(scene, rbw);
 	}
 
 	/* update objects */
 	for (go = rbw->group->gobject.first; go; go = go->next) {
 		Object *ob = go->ob;
+		ModifierData *md = NULL;
+		FractureModifierData *rmd = NULL;
 
-		if (ob && ob->type == OB_MESH) {
-			/* validate that we've got valid object set up here... */
-			RigidBodyOb *rbo = ob->rigidbody_object;
-			/* update transformation matrix of the object so we don't get a frame of lag for simple animations */
-			BKE_object_where_is_calc(scene, ob);
+		if (ob && (ob->type == OB_MESH || ob->type == OB_CURVE || ob->type == OB_SURF || ob->type == OB_FONT)) {
+			/* check for fractured objects which want to participate first, then handle other normal objects*/
+			for (md = ob->modifiers.first; md; md = md->next) {
+				if (md->type == eModifierType_Fracture) {
+					rmd = (FractureModifierData *)md;
+					break;
+				}
+			}
 
-			if (rbo == NULL) {
-				/* Since this object is included in the sim group but doesn't have
-				 * rigid body settings (perhaps it was added manually), add!
-				 *	- assume object to be active? That is the default for newly added settings...
-				 */
-				ob->rigidbody_object = BKE_rigidbody_create_object(scene, ob, RBO_TYPE_ACTIVE);
-				rigidbody_validate_sim_object(rbw, ob, true);
+			if (isModifierActive(rmd)) {
+				float max_con_mass = 0;
+			
+				int count = BLI_countlist(&rmd->meshIslands);
+				for (mi = rmd->meshIslands.first; mi; mi = mi->next) {
+					if (mi->rigidbody == NULL) {
+						continue;
+					}
+					else {  /* as usual, but for each shard now, and no constraints*/
+						/* perform simulation data updates as tagged */
+						/* refresh object... */
+						int do_rebuild = rebuild;
+						float weight = mi->thresh_weight;
+						int breaking_percentage = rmd->breaking_percentage_weighted ? (rmd->breaking_percentage * weight) : rmd->breaking_percentage;
+						
+						if (rmd->breaking_percentage > 0 || (rmd->breaking_percentage_weighted && weight > 0)) {
+							int broken_cons = 0, cons = 0, i = 0;
+							RigidBodyShardCon *con;
+							
+							cons = mi->participating_constraint_count;
+							/* calc ratio of broken cons here, per MeshIsland and flag the rest to be broken too*/
+							for (i = 0; i < cons; i++) {
+								con = mi->participating_constraints[i];
+								if (con && con->physics_constraint) {
+									if (!RB_constraint_is_enabled(con->physics_constraint)) {
+										broken_cons++;
+									}
+								}
+							}
+							
+							if (cons > 0) {
+								if ((float)broken_cons / (float)cons * 100 >= breaking_percentage) {
+									/* break all cons if over percentage */
+									for (i = 0; i < cons; i++) {
+										con = mi->participating_constraints[i];
+										if (con) {
+											con->flag &= ~RBC_FLAG_ENABLED;
+											con->flag |= RBC_FLAG_NEEDS_VALIDATE;
+											
+											if (con->physics_constraint) {
+												RB_constraint_set_enabled(con->physics_constraint, false);
+											}
+										}
+									}
+								}
+							}
+						}
+						
+						validateShard(rbw, count == 0 ? NULL : mi, ob, do_rebuild);
+					}
+
+					/* update simulation object... */
+					rigidbody_update_sim_ob(scene, rbw, ob, mi->rigidbody, mi->centroid);
+				}
+
+				if (rmd->use_mass_dependent_thresholds) {
+					max_con_mass = BKE_rigidbody_calc_max_con_mass(ob);
+				}
+				for (rbsc = rmd->meshConstraints.first; rbsc; rbsc = rbsc->next) {
+					float weight = MIN2(rbsc->mi1->thresh_weight, rbsc->mi2->thresh_weight);
+					float breaking_angle = rmd->breaking_angle_weighted ? rmd->breaking_angle * weight : rmd->breaking_angle;
+					float breaking_distance = rmd->breaking_distance_weighted ? rmd->breaking_distance * weight : rmd->breaking_distance;
+					int iterations;
+
+					if (rmd->solver_iterations_override == 0) {
+						iterations = rbw->num_solver_iterations;
+					}
+					else {
+						iterations = rmd->solver_iterations_override;
+					}
+					
+					if (iterations > 0) {
+						rbsc->flag |= RBC_FLAG_OVERRIDE_SOLVER_ITERATIONS;
+						rbsc->num_solver_iterations = iterations;
+					}
+					
+					if ((rmd->use_mass_dependent_thresholds)) {
+						BKE_rigidbody_calc_threshold(max_con_mass, rmd, rbsc);
+					}
+					
+					if (((rmd->breaking_angle) > 0) || (rmd->breaking_angle_weighted && weight > 0) ||
+					    (((rmd->breaking_distance > 0) || (rmd->breaking_distance_weighted && weight > 0)) && !rebuild))
+					{
+						float dist, angle, distdiff, anglediff;
+						calc_dist_angle(rbsc, &dist, &angle);
+						
+						anglediff = fabs(angle - rbsc->start_angle);
+						distdiff = fabs(dist - rbsc->start_dist);
+						
+						if ((rmd->breaking_angle > 0 || (rmd->breaking_angle_weighted && weight > 0)) &&
+						    (anglediff > breaking_angle))
+						{
+							rbsc->flag &= ~RBC_FLAG_ENABLED;
+							rbsc->flag |= RBC_FLAG_NEEDS_VALIDATE;
+							
+							if (rbsc->physics_constraint) {
+								RB_constraint_set_enabled(rbsc->physics_constraint, false);
+							}
+						}
+						
+						if ((rmd->breaking_distance > 0 || (rmd->breaking_distance_weighted && weight > 0)) &&
+						    (distdiff > breaking_distance))
+						{
+							rbsc->flag &= ~RBC_FLAG_ENABLED;
+							rbsc->flag |= RBC_FLAG_NEEDS_VALIDATE;
+							
+							if (rbsc->physics_constraint) {
+								RB_constraint_set_enabled(rbsc->physics_constraint, false);
+							}
+						}
+					}
+
+					if (rebuild) {
+						/* World has been rebuilt so rebuild constraint */
+						BKE_rigidbody_validate_sim_shard_constraint(rbw, rbsc, true);
+						BKE_rigidbody_start_dist_angle(rbsc);
+					}
+
+					else if (rbsc->flag & RBC_FLAG_NEEDS_VALIDATE) {
+						BKE_rigidbody_validate_sim_shard_constraint(rbw, rbsc, false);
+					}
+
+					if (rbsc->physics_constraint && rbw && rbw->rebuild_comp_con) {
+						RB_constraint_set_enabled(rbsc->physics_constraint, true);
+					}
 
-				rbo = ob->rigidbody_object;
+					rbsc->flag &= ~RBC_FLAG_NEEDS_VALIDATE;
+				}
 			}
 			else {
-				/* perform simulation data updates as tagged */
-				/* refresh object... */
-				if (rebuild) {
-					/* World has been rebuilt so rebuild object */
+				/* validate that we've got valid object set up here... */
+				RigidBodyOb *rbo = ob->rigidbody_object;
+				/* update transformation matrix of the object so we don't get a frame of lag for simple animations */
+				BKE_object_where_is_calc(scene, ob);
+
+				if (rbo == NULL) {
+					/* Since this object is included in the sim group but doesn't have
+					 * rigid body settings (perhaps it was added manually), add!
+					 *	- assume object to be active? That is the default for newly added settings...
+					 */
+					ob->rigidbody_object = BKE_rigidbody_create_object(scene, ob, RBO_TYPE_ACTIVE);
 					rigidbody_validate_sim_object(rbw, ob, true);
+
+					rbo = ob->rigidbody_object;
 				}
-				else if (rbo->flag & RBO_FLAG_NEEDS_VALIDATE) {
-					rigidbody_validate_sim_object(rbw, ob, false);
-				}
-				/* refresh shape... */
-				if (rbo->flag & RBO_FLAG_NEEDS_RESHAPE) {
-					/* mesh/shape data changed, so force shape refresh */
-					rigidbody_validate_sim_shape(ob, true);
-					/* now tell RB sim about it */
-					// XXX: we assume that this can only get applied for active/passive shapes that will be included as rigidbodies
-					RB_body_set_collision_shape(rbo->physics_object, rbo->physics_shape);
+				else {
+					/* perform simulation data updates as tagged */
+					/* refresh object... */
+					if (rebuild) {
+						/* World has been rebuilt so rebuild object */
+						rigidbody_validate_sim_object(rbw, ob, true);
+					}
+					else if (rbo->flag & RBO_FLAG_NEEDS_VALIDATE) {
+						rigidbody_validate_sim_object(rbw, ob, false);
+					}
+					/* refresh shape... */
+					if (rbo->flag & RBO_FLAG_NEEDS_RESHAPE) {
+						/* mesh/shape data changed, so force shape refresh */
+						rigidbody_validate_sim_shape(ob, true);
+						/* now tell RB sim about it */
+						// XXX: we assume that this can only get applied for active/passive shapes that will be included as rigidbodies
+						RB_body_set_collision_shape(rbo->physics_object, rbo->physics_shape);
+					}
+					rbo->flag &= ~(RBO_FLAG_NEEDS_VALIDATE | RBO_FLAG_NEEDS_RESHAPE);
 				}
-				rbo->flag &= ~(RBO_FLAG_NEEDS_VALIDATE | RBO_FLAG_NEEDS_RESHAPE);
+				/* update simulation object... */
+				rigidbody_update_sim_ob(scene, rbw, ob, rbo, centroid);
 			}
-
-			/* update simulation object... */
-			rigidbody_update_sim_ob(scene, rbw, ob, rbo);
 		}
+		rbw->refresh_modifiers = false;
 	}
 	
 	/* update constraints */
@@ -1395,11 +2563,39 @@
 static void rigidbody_update_simulation_post_step(RigidBodyWorld *rbw)
 {
 	GroupObject *go;
+	ModifierData *md;
+	FractureModifierData *rmd;
+	int modFound = false;
+	RigidBodyOb *rbo;
+	MeshIsland *mi;
 
 	for (go = rbw->group->gobject.first; go; go = go->next) {
 		Object *ob = go->ob;
+		//handle fractured rigidbodies, maybe test for psys as well ?
+		for (md = ob->modifiers.first; md; md = md->next) {
+			if (md->type == eModifierType_Fracture) {
+				rmd = (FractureModifierData *)md;
+				if (isModifierActive(rmd)) {
+					for (mi = rmd->meshIslands.first; mi; mi = mi->next) {
+						rbo = mi->rigidbody;
+						if (!rbo) continue;
+						/* reset kinematic state for transformed objects */
+						if (ob->flag & SELECT && G.moving & G_TRANSFORM_OBJ) {
+							RB_body_set_kinematic_state(rbo->physics_object, rbo->flag & RBO_FLAG_KINEMATIC || rbo->flag & RBO_FLAG_DISABLED);
+							RB_body_set_mass(rbo->physics_object, RBO_GET_MASS(rbo));
+							/* deactivate passive objects so they don't interfere with deactivation of active objects */
+							if (rbo->type == RBO_TYPE_PASSIVE)
+								RB_body_deactivate(rbo->physics_object);
+						}
+					}
+					modFound = true;
+					break;
+				}
+			}
+		}
 
-		if (ob) {
+		/* handle regular rigidbodies */
+		if (ob && !modFound) {
 			RigidBodyOb *rbo = ob->rigidbody_object;
 			/* reset kinematic state for transformed objects */
 			if (rbo && (ob->flag & SELECT) && (G.moving & G_TRANSFORM_OBJ)) {
@@ -1410,6 +2606,7 @@
 					RB_body_deactivate(rbo->physics_object);
 			}
 		}
+		modFound = false;
 	}
 }
 
@@ -1421,59 +2618,186 @@
 /* Sync rigid body and object transformations */
 void BKE_rigidbody_sync_transforms(RigidBodyWorld *rbw, Object *ob, float ctime)
 {
-	RigidBodyOb *rbo = ob->rigidbody_object;
-
-	/* keep original transform for kinematic and passive objects */
-	if (ELEM(NULL, rbw, rbo) || rbo->flag & RBO_FLAG_KINEMATIC || rbo->type == RBO_TYPE_PASSIVE)
+	RigidBodyOb *rbo = NULL;
+	FractureModifierData *rmd = NULL;
+	MeshIsland *mi;
+	ModifierData *md;
+	float centr[3], size[3];
+	int modFound = false;
+	bool exploOK = false;
+	if (rbw == NULL)
 		return;
 
-	/* use rigid body transform after cache start frame if objects is not being transformed */
-	if (BKE_rigidbody_check_sim_running(rbw, ctime) && !(ob->flag & SELECT && G.moving & G_TRANSFORM_OBJ)) {
-		float mat[4][4], size_mat[4][4], size[3];
+	for (md = ob->modifiers.first; md; md = md->next) {
+		if (md->type == eModifierType_Fracture) {
+			rmd = (FractureModifierData *)md;
+			exploOK = !rmd->explo_shared || (rmd->explo_shared && rmd->frac_mesh && rmd->dm);
+			
+			if (isModifierActive(rmd) && exploOK) {
+				modFound = true;
+				
+				if ((ob->flag & SELECT && G.moving & G_TRANSFORM_OBJ) ||
+				    ((ob->rigidbody_object) && (ob->rigidbody_object->flag & RBO_FLAG_KINEMATIC)))
+				{
+					/* update "original" matrix */
+					copy_m4_m4(rmd->origmat, ob->obmat);
+					if (ob->flag & SELECT && G.moving & G_TRANSFORM_OBJ && rbw) {
+						RigidBodyShardCon *con;
+						
+						rbw->object_changed = true;
+						BKE_rigidbody_cache_reset(rbw);
+						/* re-enable all constraints as well */
+						for (con = rmd->meshConstraints.first; con; con = con->next) {
+							con->flag |= RBC_FLAG_ENABLED;
+							con->flag |= RBC_FLAG_NEEDS_VALIDATE;
+						}
+					}
+				}
 
-		normalize_qt(rbo->orn); // RB_TODO investigate why quaternion isn't normalized at this point
-		quat_to_mat4(mat, rbo->orn);
-		copy_v3_v3(mat[3], rbo->pos);
+				if (!is_zero_m4(rmd->origmat) && rbw && !rbw->object_changed) {
+					copy_m4_m4(ob->obmat, rmd->origmat);
+				}
 
-		mat4_to_size(size, ob->obmat);
-		size_to_mat4(size_mat, size);
-		mul_m4_m4m4(mat, mat, size_mat);
+				for (mi = rmd->meshIslands.first; mi; mi = mi->next) {
+					rbo = mi->rigidbody;
+					if (!rbo) {
+						continue;
+					}
+					
+					/* use rigid body transform after cache start frame if objects is not being transformed */
+					if (BKE_rigidbody_check_sim_running(rbw, ctime) && !(ob->flag & SELECT && G.moving & G_TRANSFORM_OBJ)) {
+
+						/* keep original transform when the simulation is muted */
+						if (rbw->flag & RBW_FLAG_MUTED)
+							return;
+					}
+					/* otherwise set rigid body transform to current obmat*/
+					else {
 
-		copy_m4_m4(ob->obmat, mat);
+						mat4_to_loc_quat(rbo->pos, rbo->orn, ob->obmat);
+						mat4_to_size(size, ob->obmat);
+						copy_v3_v3(centr, mi->centroid);
+						mul_v3_v3(centr, size);
+						mul_qt_v3(rbo->orn, centr);
+						add_v3_v3(rbo->pos, centr);
+					}
+					BKE_rigidbody_update_cell(mi, ob, rbo->pos, rbo->orn, rmd);
+				}
+				
+				break;
+			}
+		}
+		modFound = false;
 	}
-	/* otherwise set rigid body transform to current obmat */
-	else {
-		mat4_to_loc_quat(rbo->pos, rbo->orn, ob->obmat);
+
+	if (!modFound)
+	{
+		rbo = ob->rigidbody_object;
+
+		/* keep original transform for kinematic and passive objects */
+		if (ELEM(NULL, rbw, rbo) || rbo->flag & RBO_FLAG_KINEMATIC || rbo->type == RBO_TYPE_PASSIVE)
+			return;
+
+		/* use rigid body transform after cache start frame if objects is not being transformed */
+		if (BKE_rigidbody_check_sim_running(rbw, ctime) && !(ob->flag & SELECT && G.moving & G_TRANSFORM_OBJ)) {
+			float mat[4][4], size_mat[4][4], size[3];
+
+			normalize_qt(rbo->orn); // RB_TODO investigate why quaternion isn't normalized at this point
+			quat_to_mat4(mat, rbo->orn);
+			copy_v3_v3(mat[3], rbo->pos);
+
+			/* keep original transform when the simulation is muted */
+			if (rbw->flag & RBW_FLAG_MUTED)
+				return;
+
+			/*normalize_qt(rbo->orn); // RB_TODO investigate why quaternion isn't normalized at this point
+			   quat_to_mat4(mat, rbo->orn);
+			   copy_v3_v3(mat[3], rbo->pos);*/
+
+			mat4_to_size(size, ob->obmat);
+			size_to_mat4(size_mat, size);
+			mul_m4_m4m4(mat, mat, size_mat);
+
+			copy_m4_m4(ob->obmat, mat);
+		}
+		/* otherwise set rigid body transform to current obmat */
+		else {
+			if (ob->flag & SELECT && G.moving & G_TRANSFORM_OBJ)
+				rbw->object_changed = true;
+
+			mat4_to_loc_quat(rbo->pos, rbo->orn, ob->obmat);
+		}
 	}
 }
 
-/* Used when canceling transforms - return rigidbody and object to initial states */
+/* Used when cancelling transforms - return rigidbody and object to initial states */
 void BKE_rigidbody_aftertrans_update(Object *ob, float loc[3], float rot[3], float quat[4], float rotAxis[3], float rotAngle)
 {
-	RigidBodyOb *rbo = ob->rigidbody_object;
-
-	/* return rigid body and object to their initial states */
-	copy_v3_v3(rbo->pos, ob->loc);
-	copy_v3_v3(ob->loc, loc);
-
-	if (ob->rotmode > 0) {
-		eulO_to_quat(rbo->orn, ob->rot, ob->rotmode);
-		copy_v3_v3(ob->rot, rot);
-	}
-	else if (ob->rotmode == ROT_MODE_AXISANGLE) {
-		axis_angle_to_quat(rbo->orn, ob->rotAxis, ob->rotAngle);
-		copy_v3_v3(ob->rotAxis, rotAxis);
-		ob->rotAngle = rotAngle;
+	RigidBodyOb *rbo;
+	ModifierData *md;
+	FractureModifierData *rmd;
+	
+	md = modifiers_findByType(ob, eModifierType_Fracture);
+	if (md != NULL)
+	{
+		MeshIsland *mi;
+		rmd = (FractureModifierData *)md;
+		copy_m4_m4(rmd->origmat, ob->obmat);
+		for (mi = rmd->meshIslands.first; mi; mi = mi->next)
+		{
+			rbo = mi->rigidbody;
+			/* return rigid body and object to their initial states */
+			copy_v3_v3(rbo->pos, ob->loc);
+			add_v3_v3(rbo->pos, mi->centroid);
+			copy_v3_v3(ob->loc, loc);
+		
+			if (ob->rotmode > 0) {
+				eulO_to_quat(rbo->orn, ob->rot, ob->rotmode);
+				copy_v3_v3(ob->rot, rot);
+			}
+			else if (ob->rotmode == ROT_MODE_AXISANGLE) {
+				axis_angle_to_quat(rbo->orn, ob->rotAxis, ob->rotAngle);
+				copy_v3_v3(ob->rotAxis, rotAxis);
+				ob->rotAngle = rotAngle;
+			}
+			else {
+				copy_qt_qt(rbo->orn, ob->quat);
+				copy_qt_qt(ob->quat, quat);
+			}
+			if (rbo->physics_object) {
+				/* allow passive objects to return to original transform */
+				if (rbo->type == RBO_TYPE_PASSIVE)
+					RB_body_set_kinematic_state(rbo->physics_object, true);
+				RB_body_set_loc_rot(rbo->physics_object, rbo->pos, rbo->orn);
+			}
+		}
 	}
 	else {
-		copy_qt_qt(rbo->orn, ob->quat);
-		copy_qt_qt(ob->quat, quat);
-	}
-	if (rbo->physics_object) {
-		/* allow passive objects to return to original transform */
-		if (rbo->type == RBO_TYPE_PASSIVE)
-			RB_body_set_kinematic_state(rbo->physics_object, true);
-		RB_body_set_loc_rot(rbo->physics_object, rbo->pos, rbo->orn);
+		rbo = ob->rigidbody_object;
+		/* return rigid body and object to their initial states */
+		copy_v3_v3(rbo->pos, ob->loc);
+		copy_v3_v3(ob->loc, loc);
+	
+		if (ob->rotmode > 0) {
+			eulO_to_quat(rbo->orn, ob->rot, ob->rotmode);
+			copy_v3_v3(ob->rot, rot);
+		}
+		else if (ob->rotmode == ROT_MODE_AXISANGLE) {
+			axis_angle_to_quat(rbo->orn, ob->rotAxis, ob->rotAngle);
+			copy_v3_v3(ob->rotAxis, rotAxis);
+			ob->rotAngle = rotAngle;
+		}
+		else {
+			copy_qt_qt(rbo->orn, ob->quat);
+			copy_qt_qt(ob->quat, quat);
+		}
+		if (rbo->physics_object) {
+			/* allow passive objects to return to original transform */
+			if (rbo->type == RBO_TYPE_PASSIVE)
+				RB_body_set_kinematic_state(rbo->physics_object, true);
+			RB_body_set_loc_rot(rbo->physics_object, rbo->pos, rbo->orn);
+		}
+		// RB_TODO update rigid body physics object's loc/rot for dynamic objects here as well (needs to be done outside bullet's update loop)
 	}
 	// RB_TODO update rigid body physics object's loc/rot for dynamic objects here as well (needs to be done outside bullet's update loop)
 }
@@ -1494,13 +2818,15 @@
 	PointCache *cache;
 	PTCacheID pid;
 	int startframe, endframe;
+	int shards = 0, objects = 0;
 
 	BKE_ptcache_id_from_rigidbody(&pid, NULL, rbw);
 	BKE_ptcache_id_time(&pid, scene, ctime, &startframe, &endframe, NULL);
 	cache = rbw->pointcache;
 
 	/* flag cache as outdated if we don't have a world or number of objects in the simulation has changed */
-	if (rbw->physics_world == NULL || rbw->numbodies != BLI_listbase_count(&rbw->group->gobject)) {
+	rigidbody_group_count_items(&rbw->group->gobject, &shards, &objects);
+	if (rbw->physics_world == NULL || rbw->numbodies != (shards + objects)) {
 		cache->flag |= PTCACHE_OUTDATED;
 	}
 
@@ -1529,7 +2855,16 @@
 	cache = rbw->pointcache;
 
 	if (ctime <= startframe) {
+		/* rebuild constraints */
+		rbw->rebuild_comp_con = true;
+
 		rbw->ltime = startframe;
+		if ((rbw->object_changed))
+		{       /* flag modifier refresh at their next execution XXX TODO -> still used ? */
+			rbw->refresh_modifiers = true;
+			rbw->object_changed = false;
+			rigidbody_update_simulation(scene, rbw, true);
+		}
 		return;
 	}
 	/* make sure we don't go out of cache frame range */
@@ -1540,7 +2875,7 @@
 	/* don't try to run the simulation if we don't have a world yet but allow reading baked cache */
 	if (rbw->physics_world == NULL && !(cache->flag & PTCACHE_BAKED))
 		return;
-	else if (rbw->objects == NULL)
+	else if ((rbw->objects == NULL) || (rbw->cache_index_map == NULL))
 		rigidbody_update_ob_array(rbw);
 
 	/* try to read from cache */
@@ -1558,6 +2893,10 @@
 			BKE_ptcache_write(&pid, startframe);
 		}
 
+		if (rbw->ltime > startframe) {
+			rbw->rebuild_comp_con = false;
+		}
+
 		/* update and validate simulation */
 		rigidbody_update_simulation(scene, rbw, false);
 
diff -ru --new-file blender-2.76b.old/source/blender/blenkernel/SConscript blender-2.76b/source/blender/blenkernel/SConscript
--- blender-2.76b.old/source/blender/blenkernel/SConscript	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/source/blender/blenkernel/SConscript	2016-01-27 20:23:16.063395942 +0300
@@ -165,7 +165,7 @@
 
 if env['WITH_BF_FFTW3']:
     defs.append('FFTW3=1')
-    incs += ' ' + env['BF_FFTW3_INC'] 
+    incs += ' ' + env['BF_FFTW3_INC']
 
 if env['WITH_BF_INTERNATIONAL']:
     defs.append('WITH_INTERNATIONAL')
@@ -173,6 +173,10 @@
 if env['WITH_BF_FREESTYLE']:
     defs.append('WITH_FREESTYLE')
 
+if env['WITH_BF_VORONOI']:
+    incs += ' #/extern/voro++'
+    defs.append('WITH_VORO')
+
 if env['WITH_BF_OPENSUBDIV']:
     defs.append('WITH_OPENSUBDIV')
     incs += ' #intern/opensubdiv'
diff -ru --new-file blender-2.76b.old/source/blender/blenlib/BLI_edgehash.h blender-2.76b/source/blender/blenlib/BLI_edgehash.h
--- blender-2.76b.old/source/blender/blenlib/BLI_edgehash.h	2015-10-30 23:31:41.000000000 +0300
+++ blender-2.76b/source/blender/blenlib/BLI_edgehash.h	2016-01-27 21:18:25.242490693 +0300
@@ -29,6 +29,7 @@
  */
 
 #include "BLI_compiler_attrs.h"
+#include "BLI_utildefines.h"
 
 struct EdgeHash;
 typedef struct EdgeHash EdgeHash;
diff -ru --new-file blender-2.76b.old/source/blender/blenloader/intern/readfile.c blender-2.76b/source/blender/blenloader/intern/readfile.c
--- blender-2.76b.old/source/blender/blenloader/intern/readfile.c	2015-11-04 13:02:14.000000000 +0300
+++ blender-2.76b/source/blender/blenloader/intern/readfile.c	2016-01-27 21:24:01.105007567 +0300
@@ -65,6 +65,7 @@
 #include "DNA_dynamicpaint_types.h"
 #include "DNA_effect_types.h"
 #include "DNA_fileglobal_types.h"
+#include "DNA_fracture_types.h"
 #include "DNA_genfile.h"
 #include "DNA_group_types.h"
 #include "DNA_gpencil_types.h"
@@ -121,6 +122,7 @@
 #include "BKE_depsgraph.h"
 #include "BKE_effect.h"
 #include "BKE_fcurve.h"
+#include "BKE_fracture.h"
 #include "BKE_global.h" // for G
 #include "BKE_group.h"
 #include "BKE_library.h" // for which_libbase
@@ -158,6 +160,8 @@
 
 #include <errno.h>
 
+#include "BKE_cdderivedmesh.h"  //for fracture meshisland handling
+
 /*
  * Remark: still a weak point is the newaddress() function, that doesnt solve reading from
  * multiple files at the same time
@@ -4418,6 +4422,51 @@
 	}
 }
 
+/* used with fracture modifier */
+static void direct_link_customdata_fracture(FileData *fd, CustomData *data, int count)
+{
+	/*need to load the dverts here for fracture, so handle this in a special function, normally
+	 *the dverts arent loaded here, for what reason ever.... */
+
+	int i = 0;
+
+	data->layers = newdataadr(fd, data->layers);
+
+	/* annoying workaround for bug [#31079] loading legacy files with
+	 * no polygons _but_ have stale customdata */
+	if (UNLIKELY(count == 0 && data->layers == NULL && data->totlayer != 0)) {
+		CustomData_reset(data);
+		return;
+	}
+
+	data->external = newdataadr(fd, data->external);
+
+	while (i < data->totlayer) {
+		CustomDataLayer *layer = &data->layers[i];
+
+		if (layer->flag & CD_FLAG_EXTERNAL)
+			layer->flag &= ~CD_FLAG_IN_MEMORY;
+
+		layer->flag &= ~CD_FLAG_NOFREE;
+
+		if (CustomData_verify_versions(data, i)) {
+			layer->data = newdataadr(fd, layer->data);
+			if (layer->type == CD_MDISPS)
+				direct_link_mdisps(fd, count, layer->data, layer->flag & CD_FLAG_EXTERNAL);
+			else if (layer->type == CD_GRID_PAINT_MASK)
+				direct_link_grid_paint_mask(fd, count, layer->data);
+			else if (layer->type == CD_MDEFORMVERT) {
+				/* layer types that allocate own memory need special handling */
+				direct_link_dverts(fd, count, layer->data);
+			}
+			i++;
+		}
+	}
+
+	CustomData_update_typemap(data);
+}
+
+
 /*this isn't really a public api function, so prototyped here*/
 static void direct_link_customdata(FileData *fd, CustomData *data, int count)
 {
@@ -4904,6 +4953,74 @@
 	}
 }
 
+/* used with fracture modifier*/
+void direct_link_customdata_mtpoly_shard(FileData *fd, CustomData *pdata, int totface);
+void direct_link_customdata_mtpoly_shard(FileData *fd, CustomData *pdata, int totface)
+{
+	int i;
+
+	for (i=0; i < pdata->totlayer; i++) {
+		CustomDataLayer *layer = &pdata->layers[i];
+
+		if (layer->type == CD_MTEXPOLY) {
+			MTexPoly *tf= layer->data;
+			int j;
+
+			for (j = 0; j < totface; j++, tf++) {
+				tf->tpage = newdataadr(fd, tf->tpage);
+				if (tf->tpage && tf->tpage->id.us == 0) {
+					tf->tpage->id.us = 1;
+				}
+			}
+		}
+	}
+}
+
+static void read_shard(FileData *fd, Shard **address )
+{
+	Shard* s = *address;
+	s->mvert = newdataadr(fd, s->mvert);
+	s->mpoly = newdataadr(fd, s->mpoly);
+	s->mloop = newdataadr(fd, s->mloop);
+
+	direct_link_customdata_fracture(fd, &s->vertData, s->totvert);
+	direct_link_customdata_fracture(fd, &s->loopData, s->totloop);
+	direct_link_customdata_fracture(fd, &s->polyData, s->totpoly);
+
+	s->neighbor_ids = newdataadr(fd, s->neighbor_ids);
+	s->cluster_colors = newdataadr(fd, s->cluster_colors);
+}
+
+static void read_meshIsland(FileData *fd, MeshIsland **address)
+{
+	MeshIsland* mi;
+
+	mi = *address;
+	mi->vertices = NULL;
+	mi->vertices_cached = NULL;
+	mi->vertco = newdataadr(fd, mi->vertco);
+	mi->temp = newdataadr(fd, mi->temp);
+	read_shard(fd, &(mi->temp));
+	mi->physics_mesh = BKE_shard_create_dm(mi->temp, true);
+	BKE_shard_free(mi->temp, true);
+	mi->temp = NULL;
+	mi->vertno = newdataadr(fd, mi->vertno);
+
+	mi->rigidbody = newdataadr(fd, mi->rigidbody);
+	mi->rigidbody->physics_object = newdataadr(fd, mi->rigidbody->physics_object);
+	mi->rigidbody->physics_shape = newdataadr(fd, mi->rigidbody->physics_shape);
+	mi->rigidbody->flag |= RBO_FLAG_NEEDS_VALIDATE;
+	mi->rigidbody->flag |= RBO_FLAG_NEEDS_RESHAPE;
+
+	mi->neighbor_ids = newdataadr(fd, mi->neighbor_ids );
+	mi->bb = newdataadr(fd, mi->bb);
+	mi->vertex_indices = newdataadr(fd, mi->vertex_indices);
+
+	/* will be refreshed on the fly */
+	mi->participating_constraint_count = 0;
+	mi->participating_constraints = NULL;
+}
+
 static void direct_link_modifiers(FileData *fd, ListBase *lb)
 {
 	ModifierData *md;
@@ -5173,6 +5290,116 @@
 			}
 			lmd->cache_system = NULL;
 		}
+		else if (md->type == eModifierType_Fracture) {
+			FractureModifierData *fmd = (FractureModifierData *)md;
+			FracMesh* fm;
+
+			fm = fmd->frac_mesh = newdataadr(fd, fmd->frac_mesh);
+
+			fmd->refresh = false;  /* do not execute modifier here yet*/
+			fmd->refresh_constraints = false;
+			fmd->nor_tree = NULL;
+			fmd->face_pairs = NULL;
+
+			if (fm == NULL) {
+
+				fmd->dm = NULL;
+				fmd->meshIslands.first = NULL;
+				fmd->meshIslands.last = NULL;
+				fmd->visible_mesh = NULL;
+				fmd->visible_mesh_cached = NULL;
+				zero_m4(fmd->origmat);
+				fmd->meshConstraints.first = NULL;
+				fmd->meshConstraints.last = NULL;
+				fmd->explo_shared = false;
+				fmd->refresh = false;  /* do not execute modifier */
+				fmd->refresh_constraints = false;
+				fmd->max_vol = 0;
+				fmd->refresh_images = false;
+			}
+			else {
+				MeshIsland *mi;
+				MVert *mverts;
+				int vertstart = 0;
+				Shard *s;
+				int count = 0;
+
+				link_list(fd, &fmd->frac_mesh->shard_map);
+				for (s = fmd->frac_mesh->shard_map.first; s; s = s->next) {
+					read_shard(fd, &s);
+				}
+
+				fmd->dm = NULL;
+				fmd->visible_mesh = NULL;
+
+				link_list(fd, &fmd->islandShards);
+				for (s = fmd->islandShards.first; s; s = s->next) {
+					read_shard(fd, &s);
+				}
+
+				link_list(fd, &fmd->meshIslands);
+				count = BLI_countlist(&fmd->islandShards);
+
+				if ((fmd->islandShards.first == NULL || count == 0) && fm->shard_count > 0) {
+					/* oops, a refresh was missing, so disable this flag here better, otherwise
+					 * we attempt to load non existing data */
+					fmd->shards_to_islands = false;
+				}
+				else if (fm->shard_count == 0) {
+					fmd->shards_to_islands = true;
+				}
+
+				/* ugly ugly, need only the shard... the rest is to be generated on demand... */
+				BKE_fracture_create_dm(fmd, true);
+
+				if (fm->shard_count == 0) {
+					fmd->shards_to_islands = false;
+				}
+
+				fmd->visible_mesh_cached = CDDM_copy(fmd->dm);
+				if (fmd->visible_mesh == NULL) {
+					fmd->visible_mesh = DM_to_bmesh(fmd->visible_mesh_cached, true);
+				}
+
+				DM_ensure_tessface(fmd->visible_mesh_cached);
+				DM_ensure_normals(fmd->visible_mesh_cached);
+				DM_update_tessface_data(fmd->visible_mesh_cached);
+
+				/* re-init cached verts here... */
+				mverts = CDDM_get_verts(fmd->visible_mesh_cached);
+
+				for (mi = fmd->meshIslands.first; mi; mi = mi->next) {
+					int k = 0;
+					read_meshIsland(fd, &mi);
+					mi->vertices_cached = MEM_mallocN(sizeof(MVert*) * mi->vertex_count, "mi->vertices_cached readfile");
+
+					for (k = 0; k < mi->vertex_count; k++) {
+						MVert* v = mverts + vertstart + k ;
+						mi->vertices_cached[k] = v;
+						mi->vertco[k*3] = v->co[0];
+						mi->vertco[k*3+1] = v->co[1];
+						mi->vertco[k*3+2] = v->co[2];
+
+						if (mi->vertno != NULL && fmd->fix_normals) {
+							float no[3];
+							short sno[3];
+							no[0] = mi->vertno[k*3];
+							no[1] = mi->vertno[k*3+1];
+							no[2] = mi->vertno[k*3+2];
+							normal_float_to_short_v3(sno, no);
+							copy_v3_v3_short(mi->vertices_cached[k]->no, sno);
+						}
+					}
+					vertstart += mi->vertex_count;
+				}
+
+				fmd->refresh_constraints = true;
+				fmd->meshConstraints.first = NULL;
+				fmd->meshConstraints.last = NULL;
+
+				fmd->refresh_images = true;
+			}
+		}
 		else if (md->type == eModifierType_CorrectiveSmooth) {
 			CorrectiveSmoothModifierData *csmd = (CorrectiveSmoothModifierData*)md;
 
@@ -5976,6 +6203,8 @@
 		rbw->physics_world = NULL;
 		rbw->objects = NULL;
 		rbw->numbodies = 0;
+		rbw->cache_index_map = NULL;
+		rbw->cache_offset_map = NULL;
 
 		/* set effector weights */
 		rbw->effector_weights = newdataadr(fd, rbw->effector_weights);
diff -ru --new-file blender-2.76b.old/source/blender/blenloader/intern/writefile.c blender-2.76b/source/blender/blenloader/intern/writefile.c
--- blender-2.76b.old/source/blender/blenloader/intern/writefile.c	2015-11-04 13:02:14.000000000 +0300
+++ blender-2.76b/source/blender/blenloader/intern/writefile.c	2016-01-27 21:26:50.796752028 +0300
@@ -106,6 +106,7 @@
 #include "DNA_group_types.h"
 #include "DNA_gpencil_types.h"
 #include "DNA_fileglobal_types.h"
+#include "DNA_fracture_types.h"
 #include "DNA_key_types.h"
 #include "DNA_lattice_types.h"
 #include "DNA_lamp_types.h"
@@ -149,6 +150,7 @@
 #include "BKE_bpath.h"
 #include "BKE_curve.h"
 #include "BKE_constraint.h"
+#include "BKE_fracture.h" // for writing a derivedmesh as shard
 #include "BKE_global.h" // for G
 #include "BKE_library.h" // for  set_listbasepointers
 #include "BKE_main.h"
@@ -1526,6 +1528,50 @@
 		writestruct(wd, DATA, "bDeformGroup", 1, defgroup);
 }
 
+/* need a prototype of that here...*/
+static void write_customdata(WriteData *wd, ID *id, int count, CustomData *data, int partial_type, int partial_count);
+
+static void write_shard(WriteData* wd, Shard* s)
+{
+	writestruct(wd, DATA, "Shard", 1, s);
+	writestruct(wd, DATA, "MVert", s->totvert, s->mvert);
+	writestruct(wd, DATA, "MPoly", s->totpoly, s->mpoly);
+	writestruct(wd, DATA, "MLoop", s->totloop, s->mloop);
+
+	write_customdata(wd, NULL, s->totvert, &s->vertData, -1, s->totvert);
+	write_customdata(wd, NULL, s->totloop, &s->loopData, -1, s->totloop);
+	write_customdata(wd, NULL, s->totpoly, &s->polyData, -1, s->totpoly);
+
+	writedata(wd, DATA, sizeof(int)*s->neighbor_count, s->neighbor_ids);
+	writedata(wd, DATA, sizeof(int), s->cluster_colors);
+}
+
+static void write_meshIsland(WriteData* wd, MeshIsland* mi)
+{
+	DerivedMesh *dm = mi->physics_mesh;
+	mi->temp = BKE_create_fracture_shard(dm->getVertArray(dm), dm->getPolyArray(dm), dm->getLoopArray(dm),
+	                                        dm->getNumVerts(dm), dm->getNumPolys(dm), dm->getNumLoops(dm), true);
+	mi->temp = BKE_custom_data_to_shard(mi->temp, dm);
+
+	writestruct(wd, DATA, "MeshIsland", 1, mi);
+	writedata(wd, DATA, sizeof(struct BMVert*) * mi->vertex_count, mi->vertices);
+	writedata(wd, DATA, sizeof(MVert*) * mi->vertex_count, mi->vertices_cached);
+	writedata(wd, DATA, sizeof(float) * 3 * mi->vertex_count, mi->vertco);
+	/* write derivedmesh as shard... */
+	mi->temp->next = NULL;
+	mi->temp->prev = NULL;
+	write_shard(wd, mi->temp);
+	BKE_shard_free(mi->temp, true);
+	mi->temp = NULL;
+
+	writedata(wd, DATA, sizeof(short) * 3 * mi->vertex_count, mi->vertno);
+
+	writestruct(wd, DATA, "RigidBodyOb", 1, mi->rigidbody);
+	writedata(wd, DATA, sizeof(int) * mi->neighbor_count, mi->neighbor_ids);
+	writestruct(wd, DATA, "BoundBox", 1, mi->bb);
+	writedata(wd, DATA, sizeof(int) * mi->vertex_count, mi->vertex_indices);
+}
+
 static void write_modifiers(WriteData *wd, ListBase *modbase)
 {
 	ModifierData *md;
@@ -1652,6 +1698,33 @@
 
 			writedata(wd, DATA, sizeof(float)*lmd->total_verts * 3, lmd->vertexco);
 		}
+		else if (md->type==eModifierType_Fracture) {
+			FractureModifierData *fmd = (FractureModifierData*)md;
+			FracMesh* fm = fmd->frac_mesh;
+
+			if (fm)
+			{
+				MeshIsland *mi;
+				Shard *s;
+
+				if (fm->running == 0)
+				{
+					writestruct(wd, DATA, "FracMesh", 1, fm);
+
+					for (s = fm->shard_map.first; s; s = s->next) {
+						write_shard(wd, s);
+					}
+
+					for (s = fmd->islandShards.first; s; s = s->next) {
+						write_shard(wd, s);
+					}
+
+					for (mi = fmd->meshIslands.first; mi; mi = mi->next) {
+						write_meshIsland(wd, mi);
+					}
+				}
+			}
+		}
 		else if (md->type == eModifierType_CorrectiveSmooth) {
 			CorrectiveSmoothModifierData *csmd = (CorrectiveSmoothModifierData *)md;
 
diff -ru --new-file blender-2.76b.old/source/blender/bmesh/tools/bmesh_decimate_dissolve.c blender-2.76b/source/blender/bmesh/tools/bmesh_decimate_dissolve.c
--- blender-2.76b.old/source/blender/bmesh/tools/bmesh_decimate_dissolve.c	2015-10-30 23:31:41.000000000 +0300
+++ blender-2.76b/source/blender/bmesh/tools/bmesh_decimate_dissolve.c	2016-01-27 21:27:42.241371271 +0300
@@ -380,6 +380,10 @@
 	BMVert **vinput_arr = BM_iter_as_arrayN(bm, BM_VERTS_OF_MESH, NULL, &vinput_len, NULL, 0);
 	BMEdge **einput_arr = BM_iter_as_arrayN(bm, BM_EDGES_OF_MESH, NULL, &einput_len, NULL, 0);
 
+	/* caused crashes in conjunction with fracture modifier when using limited dissolve operator from there,
+	 * so added a sanity check here as crash prevention */
+	if (vinput_arr == NULL || einput_arr == NULL)
+		return;
 
 	BM_mesh_decimate_dissolve_ex(bm, angle_limit, do_dissolve_boundaries,
 	                             delimit,
diff -ru --new-file blender-2.76b.old/source/blender/editors/interface/interface_templates.c blender-2.76b/source/blender/editors/interface/interface_templates.c
--- blender-2.76b.old/source/blender/editors/interface/interface_templates.c	2015-11-04 13:02:14.000000000 +0300
+++ blender-2.76b/source/blender/editors/interface/interface_templates.c	2016-01-27 21:28:54.321837689 +0300
@@ -790,7 +790,7 @@
 {
 	/* Physic Tab */
 	if (ELEM(md->type, eModifierType_Cloth, eModifierType_Collision, eModifierType_Fluidsim, eModifierType_Smoke,
-	          eModifierType_Softbody, eModifierType_Surface, eModifierType_DynamicPaint))
+	          eModifierType_Softbody, eModifierType_Surface, eModifierType_DynamicPaint, eModifierType_Fracture))
 	{
 		return 1;
 	}
@@ -966,7 +966,7 @@
 			UI_block_lock_set(block, ob && ob->id.lib, ERROR_LIBDATA_MESSAGE);
 			
 			if (!ELEM(md->type, eModifierType_Fluidsim, eModifierType_Softbody, eModifierType_ParticleSystem,
-			           eModifierType_Cloth, eModifierType_Smoke))
+			           eModifierType_Cloth, eModifierType_Smoke, eModifierType_Fracture))
 			{
 				uiItemO(row, CTX_IFACE_(BLT_I18NCONTEXT_OPERATOR_DEFAULT, "Copy"), ICON_NONE,
 				        "OBJECT_OT_modifier_copy");
diff -ru --new-file blender-2.76b.old/source/blender/editors/object/object_intern.h blender-2.76b/source/blender/editors/object/object_intern.h
--- blender-2.76b.old/source/blender/editors/object/object_intern.h	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/source/blender/editors/object/object_intern.h	2016-01-27 21:29:54.993388481 +0300
@@ -179,6 +179,9 @@
 void OBJECT_OT_meshdeform_bind(struct wmOperatorType *ot);
 void OBJECT_OT_explode_refresh(struct wmOperatorType *ot);
 void OBJECT_OT_ocean_bake(struct wmOperatorType *ot);
+void OBJECT_OT_fracture_refresh(struct wmOperatorType *ot);
+void OBJECT_OT_rigidbody_constraints_refresh(struct wmOperatorType *ot);
+void OBJECT_OT_rigidbody_convert_to_objects(struct wmOperatorType *ot);
 void OBJECT_OT_skin_root_mark(struct wmOperatorType *ot);
 void OBJECT_OT_skin_loose_mark_clear(struct wmOperatorType *ot);
 void OBJECT_OT_skin_radii_equalize(struct wmOperatorType *ot);
diff -ru --new-file blender-2.76b.old/source/blender/editors/object/object_modifier.c blender-2.76b/source/blender/editors/object/object_modifier.c
--- blender-2.76b.old/source/blender/editors/object/object_modifier.c	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/source/blender/editors/object/object_modifier.c	2016-01-27 21:32:56.679042848 +0300
@@ -42,6 +42,8 @@
 #include "DNA_meshdata_types.h"
 #include "DNA_object_force.h"
 #include "DNA_scene_types.h"
+#include "DNA_rigidbody_types.h"
+#include "DNA_fracture_types.h"
 
 #include "BLI_bitmap.h"
 #include "BLI_math.h"
@@ -50,6 +52,7 @@
 #include "BLI_string_utf8.h"
 #include "BLI_path_util.h"
 #include "BLI_utildefines.h"
+#include "BLI_kdtree.h"
 
 #include "BKE_animsys.h"
 #include "BKE_curve.h"
@@ -74,6 +77,11 @@
 #include "BKE_particle.h"
 #include "BKE_softbody.h"
 #include "BKE_editmesh.h"
+#include "BKE_scene.h"
+#include "BKE_material.h"
+#include "BKE_library.h"
+#include "BKE_rigidbody.h"
+#include "BKE_group.h"
 
 #include "RNA_access.h"
 #include "RNA_define.h"
@@ -83,6 +91,7 @@
 #include "ED_object.h"
 #include "ED_screen.h"
 #include "ED_mesh.h"
+#include "ED_physics.h"
 
 #include "WM_api.h"
 #include "WM_types.h"
@@ -873,6 +882,16 @@
 	Object *ob = ED_object_active_context(C);
 	ModifierData *md = edit_modifier_property_get(op, ob, 0);
 	int mode_orig = ob->mode;
+
+	//if we have a running fracture job, dont remove the modifier
+	if (md && md->type == eModifierType_Fracture)
+	{
+		FractureModifierData* fmd = (FractureModifierData*)md;
+		if (fmd->execute_threaded && fmd->frac_mesh && fmd->frac_mesh->running == 1)
+		{
+			return OPERATOR_CANCELLED;
+		}
+	}
 	
 	if (!md || !ED_object_modifier_remove(op->reports, bmain, ob, md))
 		return OPERATOR_CANCELLED;
@@ -2246,6 +2265,431 @@
 	RNA_def_boolean(ot->srna, "free", false, "Free", "Free the bake, rather than generating it");
 }
 
+/****************** rigidbody modifier refresh operator *********************/
+
+typedef struct FractureJob {
+	/* from wmJob */
+	void *owner;
+	short *stop, *do_update;
+	float *progress;
+	int current_frame, total_progress;
+	struct FractureModifierData *fmd;
+	struct Object* ob;
+	struct Scene* scene;
+} FractureJob;
+
+
+static void fracture_free(void *customdata)
+{
+	FractureJob *fj = customdata;
+	MEM_freeN(fj);
+}
+
+static int fracture_breakjob(void *customdata)
+{
+	/* FractureJob *fj = (FractureJob *)customdata;
+	 * return *(fj->stop); */
+	return G.is_break; /* a workaround solution */
+}
+
+static float fracture_update(void *customdata)
+{
+	FractureJob *fj = customdata;
+	float progress;
+
+	if (fj->fmd->frac_mesh == NULL)
+		return 0.0f;
+
+	if (fracture_breakjob(fj))
+		fj->fmd->frac_mesh->cancel = 1;
+
+	/* *(fj->do_update) = true;  useless here...*/
+	progress = (float)(fj->fmd->frac_mesh->progress_counter) / (float)(fj->total_progress);
+	return progress;
+}
+
+static void fracture_startjob(void *customdata, short *stop, short *do_update, float *progress)
+{
+	FractureJob *fj = customdata;
+	FractureModifierData *fmd = fj->fmd;
+	Object *ob = fj->ob;
+	Scene* scene = fj->scene;
+
+	fj->stop = stop;
+	fj->do_update = do_update;
+	fj->progress = progress;
+	*(fj->stop) = 0; /*false*/
+
+	G.is_break = false;   /* XXX shared with render - replace with job 'stop' switch */
+
+	/* arm the modifier... */
+	fmd->refresh = true;
+	*(fj->do_update) = true;
+	*do_update = true;
+	*stop = 0;
+
+	/*...and trigger modifier execution HERE*/
+	makeDerivedMesh(scene, ob, NULL, scene->customdata_mask | CD_MASK_BAREMESH, 0);
+}
+
+static void fracture_endjob(void *customdata)
+{
+	FractureJob *fj = customdata;
+	FractureModifierData *fmd = fj->fmd;
+	fmd->refresh = false;
+}
+
+static bool fracture_poll(bContext *C)
+{
+	return edit_modifier_poll_generic(C, &RNA_FractureModifier, 0);
+}
+
+static int fracture_refresh_exec(bContext *C, wmOperator *op)
+{
+	Object *obact = ED_object_active_context(C);
+	Scene *scene = CTX_data_scene(C);
+	float cfra = BKE_scene_frame_get(scene);
+	FractureModifierData *rmd;
+	FractureJob *fj;
+	wmJob* wm_job;
+
+	rmd = (FractureModifierData *)modifiers_findByType(obact, eModifierType_Fracture);
+	if (!rmd || (rmd && rmd->refresh) || (scene->rigidbody_world && cfra != scene->rigidbody_world->pointcache->startframe))
+		return OPERATOR_CANCELLED;
+	
+	if (!rmd->execute_threaded) {
+		rmd->refresh = true;
+		DAG_id_tag_update(&obact->id, OB_RECALC_DATA);
+		WM_event_add_notifier(C, NC_OBJECT | ND_MODIFIER, obact);
+	}
+	else {
+		/* job stuff */
+		int factor, verts, shardprogress, halvingprogress, totalprogress;
+		scene->r.cfra = cfra;
+
+		/* setup job */
+		wm_job = WM_jobs_get(CTX_wm_manager(C), CTX_wm_window(C), scene, "Fracture",
+							 WM_JOB_PROGRESS, WM_JOB_TYPE_OBJECT_FRACTURE);
+		fj = MEM_callocN(sizeof(FractureJob), "object fracture job");
+		fj->fmd = rmd;
+		fj->ob = obact;
+		fj->scene = scene;
+
+		/* if we have shards, totalprogress = shards + islands
+		 * if we dont have shards, then calculate number of processed halving steps
+		 * if we split island to shards, add both */
+		factor = (fj->fmd->frac_algorithm == MOD_FRACTURE_BISECT_FAST) ? 4 : 2;
+		shardprogress = fj->fmd->shard_count * (factor+1); /* +1 for the meshisland creation */
+
+		if (obact->derivedFinal) {
+			verts = obact->derivedFinal->getNumVerts(obact->derivedFinal);
+		}
+		else {
+			verts = ((Mesh*)obact->data)->totvert;
+		}
+
+		halvingprogress = (int)(verts / 1000) + (fj->fmd->shard_count * factor); /*-> 1000 size of each partitioned separate loose*/
+		totalprogress = (rmd->shards_to_islands || rmd->point_source != MOD_FRACTURE_UNIFORM) ? shardprogress + halvingprogress : shardprogress;
+		fj->total_progress = totalprogress;
+
+		WM_jobs_customdata_set(wm_job, fj, fracture_free);
+		WM_jobs_timer(wm_job, 0.1, NC_WM | ND_JOB, NC_OBJECT | ND_MODIFIER);
+		WM_jobs_callbacks(wm_job, fracture_startjob, NULL, fracture_update, fracture_endjob);
+
+		WM_jobs_start(CTX_wm_manager(C), wm_job);
+	}
+
+	return OPERATOR_FINISHED;
+}
+
+static int fracture_refresh_invoke(bContext *C, wmOperator *op, wmEvent *UNUSED(event))
+{
+	if (WM_jobs_test(CTX_wm_manager(C), CTX_data_scene(C), WM_JOB_TYPE_OBJECT_FRACTURE))
+		return OPERATOR_CANCELLED;
+
+	return fracture_refresh_exec(C, op);
+}
+
+
+void OBJECT_OT_fracture_refresh(wmOperatorType *ot)
+{
+	ot->name = "Fracture Refresh";
+	ot->description = "Refresh data in the Fracture modifier";
+	ot->idname = "OBJECT_OT_fracture_refresh";
+
+	ot->poll = fracture_poll;
+	ot->invoke = fracture_refresh_invoke;
+	ot->exec = fracture_refresh_exec;
+
+	/* flags */
+	ot->flag = OPTYPE_REGISTER | OPTYPE_UNDO | OPTYPE_INTERNAL;
+	edit_modifier_properties(ot);
+}
+
+/****************** rigidbody constraint refresh operator *********************/
+
+static int rigidbody_refresh_constraints_exec(bContext *C, wmOperator *op)
+{
+	Object *obact = ED_object_active_context(C);
+	FractureModifierData *rmd;
+	Scene *scene = CTX_data_scene(C);
+	float cfra = BKE_scene_frame_get(scene);
+	
+	rmd = (FractureModifierData *)modifiers_findByType(obact, eModifierType_Fracture);
+
+	if (!rmd || (rmd && rmd->refresh) || (scene->rigidbody_world && cfra != scene->rigidbody_world->pointcache->startframe))
+		return OPERATOR_CANCELLED;
+
+	rmd->refresh_constraints = true;
+
+	DAG_id_tag_update(&obact->id, OB_RECALC_DATA);
+	WM_event_add_notifier(C, NC_OBJECT | ND_MODIFIER, obact);
+
+	return OPERATOR_FINISHED;
+}
+
+static int rigidbody_refresh_constraints_invoke(bContext *C, wmOperator *op, wmEvent *UNUSED(event))
+{
+	if (edit_modifier_invoke_properties(C, op) || true)
+		return rigidbody_refresh_constraints_exec(C, op);
+	else
+		return OPERATOR_CANCELLED;
+}
+
+
+void OBJECT_OT_rigidbody_constraints_refresh(wmOperatorType *ot)
+{
+	ot->name = "RigidBody Constraints Refresh";
+	ot->description = "Refresh constraints in the Rigid Body modifier";
+	ot->idname = "OBJECT_OT_rigidbody_constraints_refresh";
+
+	ot->poll = fracture_poll;
+	ot->invoke = rigidbody_refresh_constraints_invoke;
+	ot->exec = rigidbody_refresh_constraints_exec;
+
+	/* flags */
+	ot->flag = OPTYPE_REGISTER | OPTYPE_UNDO | OPTYPE_INTERNAL;
+	edit_modifier_properties(ot);
+}
+
+void convert_modifier_to_objects(ReportList *reports, Scene* scene, Object* ob, FractureModifierData *rmd)
+{
+	Base *base_new, *base_old = BKE_scene_base_find(scene, ob);
+	Object *ob_new = NULL;
+	MeshIsland *mi;
+	RigidBodyShardCon* con;
+	int i = 0;
+
+	int count = BLI_countlist(&rmd->meshIslands);
+	KDTree* objtree = BLI_kdtree_new(count);
+	Object** objs = MEM_callocN(sizeof(Object*) * count, "convert_objs");
+	float max_con_mass = 0;
+	float min_con_dist = FLT_MAX;
+	rmd->refresh = false;
+
+	for (mi = rmd->meshIslands.first; mi; mi = mi->next) {
+		float cent[3];
+		Mesh* me;
+		ModifierData *md;
+		bool foundFracture = false;
+
+		/* create separate objects for meshislands */
+		if (ob->type == OB_MESH) {
+			base_new = ED_object_add_duplicate(G.main, scene, base_old, USER_DUP_MESH);
+			ob_new = base_new->object;
+		}
+		else {
+			RigidBodyWorld *rbw = NULL;
+
+			ob_new = BKE_object_add(G.main, scene, OB_MESH);
+
+			rbw = scene->rigidbody_world;
+
+			if (rbw) {
+				/* make rigidbody object settings */
+				if (ob_new->rigidbody_object == NULL) {
+					ob_new->rigidbody_object = BKE_rigidbody_create_object(scene, ob_new, RBO_TYPE_ACTIVE);
+				}
+				ob_new->rigidbody_object->type = RBO_TYPE_ACTIVE;
+				ob_new->rigidbody_object->flag |= RBO_FLAG_NEEDS_VALIDATE;
+
+				/* add object to rigid body group */
+				BKE_group_object_add(rbw->group, ob_new, scene, NULL);
+
+				DAG_id_tag_update(&ob_new->id, OB_RECALC_OB);
+			}
+		}
+
+		/* throw away all modifiers before fracture, result is stored inside it */
+		while (ob_new->modifiers.first != NULL) {
+			md = ob_new->modifiers.first;
+			if (md->type == eModifierType_Fracture) {
+				/*remove fracture itself too*/
+				foundFracture = true;
+				BLI_remlink(&ob_new->modifiers, md);
+				modifier_free(md);
+				md = NULL;
+			}
+			else if (!foundFracture) {
+				BLI_remlink(&ob_new->modifiers, md);
+				modifier_free(md);
+				md = NULL;
+			}
+			/* XXX else keep following modifiers, or apply them ? */
+		}
+
+		assign_matarar(ob_new, give_matarar(ob), *give_totcolp(ob));
+
+		me = (Mesh*)ob_new->data;
+		me->edit_btmesh = NULL;
+
+		DM_to_mesh(mi->physics_mesh, me, ob_new, CD_MASK_MESH);
+
+		/*set origin to centroid*/
+		copy_v3_v3(cent, mi->centroid);
+		mul_m4_v3(ob_new->obmat, cent);
+		copy_v3_v3(ob_new->loc, cent);
+
+		/*set mass*/
+		ob_new->rigidbody_object->mass = mi->rigidbody->mass;
+
+		/*store obj indexes in kdtree and objs in array*/
+		BLI_kdtree_insert(objtree, i, mi->centroid);
+		objs[i] = ob_new;
+		i++;
+
+		BKE_rigidbody_remove_shard(scene, mi);
+	}
+
+	BLI_kdtree_balance(objtree);
+
+	/* go through constraints and find objects by position
+	 * constrain them with regular constraints */
+
+	if (rmd->use_mass_dependent_thresholds) {
+		max_con_mass = BKE_rigidbody_calc_max_con_mass(ob);
+	}
+
+	for (con = rmd->meshConstraints.first; con; con = con->next) {
+		int index1 = BLI_kdtree_find_nearest(objtree, con->mi1->centroid, NULL);
+		int index2 =  BLI_kdtree_find_nearest(objtree, con->mi2->centroid, NULL);
+		Object* ob1 = objs[index1];
+		Object* ob2 = objs[index2];
+		Object* rbcon = BKE_object_add(G.main, scene, OB_EMPTY);
+		int iterations;
+
+		if (rmd->solver_iterations_override == 0) {
+			iterations = rmd->modifier.scene->rigidbody_world->num_solver_iterations;
+		}
+		else {
+			iterations = rmd->solver_iterations_override;
+		}
+
+		if (iterations > 0) {
+			con->flag |= RBC_FLAG_OVERRIDE_SOLVER_ITERATIONS;
+			con->num_solver_iterations = iterations;
+		}
+
+		if ((rmd->use_mass_dependent_thresholds)) {
+			BKE_rigidbody_calc_threshold(max_con_mass, rmd, con);
+		}
+
+		copy_v3_v3(rbcon->loc, ob1->loc); /*use same settings as in modifier*/
+		ED_rigidbody_constraint_add(scene, rbcon, con->type, reports);
+
+		rbcon->rigidbody_constraint->ob1 = ob1;
+		rbcon->rigidbody_constraint->ob2 = ob2;
+		rbcon->rigidbody_constraint->breaking_threshold = con->breaking_threshold;
+		rbcon->rigidbody_constraint->flag |= RBC_FLAG_USE_BREAKING;
+
+		if (con->flag & RBC_FLAG_OVERRIDE_SOLVER_ITERATIONS) {
+			rbcon->rigidbody_constraint->flag |= RBC_FLAG_OVERRIDE_SOLVER_ITERATIONS;
+			rbcon->rigidbody_constraint->num_solver_iterations = iterations;
+		}
+
+		BKE_rigidbody_remove_shard_con(scene, con);
+	}
+
+	/* free array and kdtree*/
+	MEM_freeN(objs);
+	BLI_kdtree_free(objtree);
+}
+
+static int rigidbody_convert_exec(bContext *C, wmOperator *op)
+{
+	Object *obact = ED_object_active_context(C);
+	Scene *scene = CTX_data_scene(C);
+	Main* bmain = CTX_data_main(C);
+	float cfra = BKE_scene_frame_get(scene);
+	FractureModifierData *rmd;
+	RigidBodyWorld *rbw = scene->rigidbody_world;
+	Object* par = NULL;
+	
+	rmd = (FractureModifierData *)modifiers_findByType(obact, eModifierType_Fracture);
+	if (rmd && rmd->refresh) {
+		return OPERATOR_CANCELLED;
+	}
+
+	if (rmd && scene->rigidbody_world && cfra == scene->rigidbody_world->pointcache->startframe) {
+		convert_modifier_to_objects(op->reports, scene, obact, rmd);
+	}
+
+	if (rbw) {
+		/* flatten the cache and throw away all traces of the modifiers */
+		short steps_per_second = rbw->steps_per_second;
+		short num_solver_iterations = rbw->num_solver_iterations;
+		int flag = rbw->flag;
+		float time_scale = rbw->time_scale;
+		struct Group* constraints = rbw->constraints;
+		struct Group* group = rbw->group;
+		RigidBodyWorld *rbwn = NULL;
+		
+		BKE_rigidbody_cache_reset(rbw);
+		BKE_rigidbody_free_world(rbw);
+		scene->rigidbody_world = NULL;
+		rbwn = BKE_rigidbody_create_world(scene);
+		rbwn->time_scale = time_scale;
+		rbwn->flag = flag | RBW_FLAG_NEEDS_REBUILD;
+		rbwn->num_solver_iterations = num_solver_iterations;
+		rbwn->steps_per_second = steps_per_second;
+		rbwn->group = group;
+		rbwn->constraints = constraints;
+		
+		scene->rigidbody_world = rbwn;
+	}
+	
+	DAG_relations_tag_update(bmain);
+	WM_event_add_notifier(C, NC_SCENE | ND_OB_ACTIVE, scene);
+	WM_event_add_notifier(C, NC_SCENE | ND_LAYER_CONTENT, scene);
+	
+	return OPERATOR_FINISHED;
+}
+
+static int rigidbody_convert_invoke(bContext *C, wmOperator *op, wmEvent *UNUSED(event))
+{
+	
+	if (edit_modifier_invoke_properties(C, op) || true)
+		return rigidbody_convert_exec(C, op);
+	else
+		return OPERATOR_CANCELLED;
+}
+
+
+void OBJECT_OT_rigidbody_convert_to_objects(wmOperatorType *ot)
+{
+	ot->name = "RigidBody Convert To Objects";
+	ot->description = "Convert the Rigid Body modifier shards to real objects";
+	ot->idname = "OBJECT_OT_rigidbody_convert_to_objects";
+
+	ot->poll = fracture_poll;
+	ot->invoke = rigidbody_convert_invoke;
+	ot->exec = rigidbody_convert_exec;
+
+	/* flags */
+	ot->flag = OPTYPE_REGISTER | OPTYPE_UNDO | OPTYPE_INTERNAL;
+	edit_modifier_properties(ot);
+}
+
 /************************ LaplacianDeform bind operator *********************/
 
 static int laplaciandeform_poll(bContext *C)
diff -ru --new-file blender-2.76b.old/source/blender/editors/object/object_ops.c blender-2.76b/source/blender/editors/object/object_ops.c
--- blender-2.76b.old/source/blender/editors/object/object_ops.c	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/source/blender/editors/object/object_ops.c	2016-01-27 21:33:37.602739663 +0300
@@ -148,6 +148,9 @@
 	WM_operatortype_append(OBJECT_OT_meshdeform_bind);
 	WM_operatortype_append(OBJECT_OT_explode_refresh);
 	WM_operatortype_append(OBJECT_OT_ocean_bake);
+	WM_operatortype_append(OBJECT_OT_fracture_refresh);
+	WM_operatortype_append(OBJECT_OT_rigidbody_constraints_refresh);
+	WM_operatortype_append(OBJECT_OT_rigidbody_convert_to_objects);
 	
 	WM_operatortype_append(OBJECT_OT_constraint_add);
 	WM_operatortype_append(OBJECT_OT_constraint_add_with_targets);
diff -ru --new-file blender-2.76b.old/source/blender/editors/object/object_relations.c blender-2.76b/source/blender/editors/object/object_relations.c
--- blender-2.76b.old/source/blender/editors/object/object_relations.c	2015-11-04 13:02:14.000000000 +0300
+++ blender-2.76b/source/blender/editors/object/object_relations.c	2016-01-27 21:35:00.781123333 +0300
@@ -87,6 +87,7 @@
 #include "BKE_speaker.h"
 #include "BKE_texture.h"
 #include "BKE_editmesh.h"
+#include "BKE_rigidbody.h"
 
 #include "WM_api.h"
 #include "WM_types.h"
@@ -1453,6 +1454,7 @@
 static int make_links_scene_exec(bContext *C, wmOperator *op)
 {
 	Scene *scene_to = BLI_findlink(&CTX_data_main(C)->scene, RNA_enum_get(op->ptr, "scene"));
+	Scene *scene_from = CTX_data_scene(C);
 
 	if (scene_to == NULL) {
 		BKE_report(op->reports, RPT_ERROR, "Could not find scene");
@@ -1471,6 +1473,10 @@
 
 	CTX_DATA_BEGIN (C, Base *, base, selected_bases)
 	{
+		/* in case we link rigidbodies, copy the world of them as well (or we experience a crash if we try to access it */
+		if (scene_from->rigidbody_world != NULL && scene_to->rigidbody_world == NULL) {
+			scene_to->rigidbody_world = BKE_rigidbody_world_copy(scene_from->rigidbody_world);
+		}
 		ED_object_scene_link(scene_to, base->object);
 	}
 	CTX_DATA_END;
diff -ru --new-file blender-2.76b.old/source/blender/editors/physics/physics_intern.h blender-2.76b/source/blender/editors/physics/physics_intern.h
--- blender-2.76b.old/source/blender/editors/physics/physics_intern.h	2015-10-30 23:31:41.000000000 +0300
+++ blender-2.76b/source/blender/editors/physics/physics_intern.h	2016-01-27 21:35:49.316763636 +0300
@@ -122,6 +122,7 @@
 /* rigidbody_constraint.c */
 void RIGIDBODY_OT_constraint_add(struct wmOperatorType *ot);
 void RIGIDBODY_OT_constraint_remove(struct wmOperatorType *ot);
+void RIGIDBODY_OT_constraints_remove(struct wmOperatorType *ot);
 
 /*rigidbody_world.c */
 void RIGIDBODY_OT_world_add(struct wmOperatorType *ot);
diff -ru --new-file blender-2.76b.old/source/blender/editors/physics/physics_ops.c blender-2.76b/source/blender/editors/physics/physics_ops.c
--- blender-2.76b.old/source/blender/editors/physics/physics_ops.c	2015-10-30 23:31:41.000000000 +0300
+++ blender-2.76b/source/blender/editors/physics/physics_ops.c	2016-01-27 21:36:12.652590679 +0300
@@ -98,6 +98,7 @@
 
 	WM_operatortype_append(RIGIDBODY_OT_constraint_add);
 	WM_operatortype_append(RIGIDBODY_OT_constraint_remove);
+	WM_operatortype_append(RIGIDBODY_OT_constraints_remove);
 
 	WM_operatortype_append(RIGIDBODY_OT_world_add);
 	WM_operatortype_append(RIGIDBODY_OT_world_remove);
diff -ru --new-file blender-2.76b.old/source/blender/editors/physics/rigidbody_constraint.c blender-2.76b/source/blender/editors/physics/rigidbody_constraint.c
--- blender-2.76b.old/source/blender/editors/physics/rigidbody_constraint.c	2015-10-30 23:31:41.000000000 +0300
+++ blender-2.76b/source/blender/editors/physics/rigidbody_constraint.c	2016-01-27 21:37:34.713982390 +0300
@@ -36,6 +36,7 @@
 #include "DNA_object_types.h"
 #include "DNA_rigidbody_types.h"
 #include "DNA_scene_types.h"
+#include "BLI_listbase.h"
 
 #include "BKE_context.h"
 #include "BKE_depsgraph.h"
@@ -196,4 +197,49 @@
 
 	/* flags */
 	ot->flag = OPTYPE_REGISTER | OPTYPE_UNDO;
+}
+
+/* ************ Remove Rigid Body Constraints ************** */
+
+static int rigidbody_constraints_remove_exec(bContext *C, wmOperator *UNUSED(op))
+{
+	Scene *scene = CTX_data_scene(C);
+	bool change = false;
+
+	/* apply this to all selected objects... */
+	CTX_DATA_BEGIN(C, Object *, ob, selected_objects)
+	{
+		if (ob->rigidbody_constraint) {
+			ED_rigidbody_constraint_remove(scene, ob);
+			change = true;
+		}
+	}
+	CTX_DATA_END;
+
+	if (change) {
+		/* send updates */
+		WM_event_add_notifier(C, NC_OBJECT | ND_TRANSFORM, NULL);
+		WM_event_add_notifier(C, NC_OBJECT | ND_POINTCACHE, NULL);
+
+		/* done */
+		return OPERATOR_FINISHED;
+	}
+	else {
+		return OPERATOR_CANCELLED;
+	}
+}
+
+void RIGIDBODY_OT_constraints_remove(wmOperatorType *ot)
+{
+	/* identifiers */
+	ot->idname = "RIGIDBODY_OT_constraints_remove";
+	ot->name = "Remove Rigid Body Constraints";
+	ot->description = "Remove selected constraints from Rigid Body simulation";
+
+	/* callbacks */
+	ot->exec = rigidbody_constraints_remove_exec;
+	ot->poll = ED_operator_scene_editable;
+
+	/* flags */
+	ot->flag = OPTYPE_REGISTER | OPTYPE_UNDO;
 }
diff -ru --new-file blender-2.76b.old/source/blender/editors/physics/rigidbody_object.c blender-2.76b/source/blender/editors/physics/rigidbody_object.c
--- blender-2.76b.old/source/blender/editors/physics/rigidbody_object.c	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/source/blender/editors/physics/rigidbody_object.c	2016-01-27 21:38:56.659374839 +0300
@@ -20,7 +20,7 @@
  *
  * The Original Code is: all of this file.
  *
- * Contributor(s): Joshua Leung, Sergej Reich
+ * Contributor(s): Joshua Leung, Sergej Reich, Martin Felke
  *
  * ***** END GPL LICENSE BLOCK *****
  */
@@ -48,6 +48,8 @@
 #include "BKE_group.h"
 #include "BKE_report.h"
 #include "BKE_rigidbody.h"
+#include "BKE_DerivedMesh.h"
+#include "BKE_cdderivedmesh.h"
 
 #include "RNA_access.h"
 #include "RNA_define.h"
@@ -506,6 +508,7 @@
 	{
 		if (ob->rigidbody_object) {
 			PointerRNA ptr;
+			DerivedMesh* dm_ob;
 
 			float volume; /* m^3 */
 			float mass;   /* kg */
@@ -513,7 +516,21 @@
 			/* mass is calculated from the approximate volume of the object,
 			 * and the density of the material we're simulating
 			 */
-			BKE_rigidbody_calc_volume(ob, &volume);
+
+			if (ob->type == OB_MESH) {
+				/* if we have a mesh, determine its volume */
+				dm_ob = CDDM_from_mesh(ob->data);
+				volume = BKE_rigidbody_calc_volume(dm_ob, ob->rigidbody_object);
+			}
+			else {
+				float dim[3];
+				/* else get object boundbox as last resort,
+				 * because fracture modifier can operate on non-mesh objects too
+				 * and there we need a fallback volume of the "whole" object as well*/
+				BKE_object_dimensions_get(ob, dim);
+				volume = dim[0] * dim[1] * dim[2];
+			}
+
 			mass = volume * density;
 
 			/* use RNA-system to change the property and perform all necessary changes */
diff -ru --new-file blender-2.76b.old/source/blender/editors/space_buttons/buttons_context.c blender-2.76b/source/blender/editors/space_buttons/buttons_context.c
--- blender-2.76b.old/source/blender/editors/space_buttons/buttons_context.c	2015-11-02 16:25:37.000000000 +0300
+++ blender-2.76b/source/blender/editors/space_buttons/buttons_context.c	2016-01-27 21:39:34.626093309 +0300
@@ -1060,6 +1060,16 @@
 			return 1;
 		}
 	}
+	else if (CTX_data_equals(member, "fracture")) {
+		PointerRNA *ptr = get_pointer_type(path, &RNA_Object);
+
+		if (ptr && ptr->data) {
+			Object *ob = ptr->data;
+			ModifierData *md = modifiers_findByType(ob, eModifierType_Fracture);
+			CTX_data_pointer_set(result, &ob->id, &RNA_FractureModifier, md);
+			return 1;
+		}
+	}
 	else if (CTX_data_equals(member, "line_style")) {
 		set_pointer_type(path, result, &RNA_FreestyleLineStyle);
 		return 1;
diff -ru --new-file blender-2.76b.old/source/blender/editors/space_outliner/outliner_draw.c blender-2.76b/source/blender/editors/space_outliner/outliner_draw.c
--- blender-2.76b.old/source/blender/editors/space_outliner/outliner_draw.c	2015-11-04 13:02:14.000000000 +0300
+++ blender-2.76b/source/blender/editors/space_outliner/outliner_draw.c	2016-01-27 21:40:41.373598305 +0300
@@ -1173,6 +1173,8 @@
 						UI_icon_draw(x, y, ICON_MOD_DATA_TRANSFER); break;
 					case eModifierType_NormalEdit:
 						UI_icon_draw(x, y, ICON_MOD_NORMALEDIT); break;
+					case eModifierType_Fracture:
+						UI_icon_draw(x, y, ICON_MOD_EXPLODE); break;
 					/* Default */
 					case eModifierType_None:
 					case eModifierType_ShapeKey:
diff -ru --new-file blender-2.76b.old/source/blender/editors/transform/transform_conversions.c blender-2.76b/source/blender/editors/transform/transform_conversions.c
--- blender-2.76b.old/source/blender/editors/transform/transform_conversions.c	2015-11-04 13:02:15.000000000 +0300
+++ blender-2.76b/source/blender/editors/transform/transform_conversions.c	2016-01-27 21:41:47.663106620 +0300
@@ -6350,8 +6350,16 @@
 			/* restore rigid body transform */
 			if (ob->rigidbody_object && canceled) {
 				float ctime = BKE_scene_frame_get(t->scene);
+				ModifierData* md = modifiers_findByType(ob, eModifierType_Fracture);
+				FractureModifierData *fmd;
 				if (BKE_rigidbody_check_sim_running(t->scene->rigidbody_world, ctime))
 					BKE_rigidbody_aftertrans_update(ob, td->ext->oloc, td->ext->orot, td->ext->oquat, td->ext->orotAxis, td->ext->orotAngle);
+				
+				if (md != NULL) {
+					//reset original matrix of modifier
+					fmd = (FractureModifierData*)md;
+					copy_m4_m4(fmd->origmat, td->ext->obmat);
+				}
 			}
 		}
 	}
diff -ru --new-file blender-2.76b.old/source/blender/makesdna/DNA_fracture_types.h blender-2.76b/source/blender/makesdna/DNA_fracture_types.h
--- blender-2.76b.old/source/blender/makesdna/DNA_fracture_types.h	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/source/blender/makesdna/DNA_fracture_types.h	2016-01-27 21:42:13.254916780 +0300
@@ -0,0 +1,87 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software  Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) Blender Foundation
+ * All rights reserved.
+ *
+ * The Original Code is: all of this file.
+ *
+ * Contributor(s): Martin Felke
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+/** \file DNA_fracture_types.h
+ *  \ingroup DNA
+ */
+ 
+#ifndef DNA_FRACTURE_TYPES_H
+#define DNA_FRACTURE_TYPES_H
+
+#include "BLI_utildefines.h"
+#include "DNA_mesh_types.h"
+#include "DNA_object_types.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct DerivedMesh;
+
+enum {
+	SHARD_INTACT   = 1 << 0,
+	SHARD_FRACTURED = 1 << 1,
+};
+
+typedef struct Shard {
+	struct Shard *next, *prev;
+	struct MVert *mvert;
+	struct MPoly *mpoly;
+	struct MLoop *mloop;
+
+	struct CustomData vertData;
+	struct CustomData polyData;
+	struct CustomData loopData;
+
+	int totvert, totpoly, totloop;
+	int pad;
+	
+	int *cluster_colors;
+	float min[3], max[3];
+	float centroid[3];  /* centroid of shard, calculated during fracture */
+	float start_co[3];  /* this was necessary for simulation itself, storing the restposition of the centroid */
+	int *neighbor_ids;  /* neighbors of me... might be necessary for easier compounding or fracture, dont need to iterate over all */
+	int shard_id;       /* the identifier */
+	int neighbor_count; /* counts of neighbor islands */
+	int parent_id;      /* the shard from which this shard originates, we keep all shards in the shardmap */
+	int flag;           /* flag for fracture state (INTACT, FRACTURED)*/
+} Shard;
+
+typedef struct FracMesh {
+	ListBase shard_map;     /* groups mesh elements to islands, generated by fracture itself */
+	int shard_count;        /* how many islands we have */
+	short cancel;           /* whether the process is cancelled (from the job, ugly, but this way we dont need the entire modifier) */
+	short running;          /* whether the process is currently in progress, so the modifier wont be touched from the main thread */
+	int progress_counter;   /* counts progress */
+	char pad[4];
+} FracMesh;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* DNA_FRACTURE_TYPES_H */
diff -ru --new-file blender-2.76b.old/source/blender/makesdna/DNA_modifier_types.h blender-2.76b/source/blender/makesdna/DNA_modifier_types.h
--- blender-2.76b.old/source/blender/makesdna/DNA_modifier_types.h	2015-11-02 16:25:38.000000000 +0300
+++ blender-2.76b/source/blender/makesdna/DNA_modifier_types.h	2016-01-27 21:44:28.312914736 +0300
@@ -85,6 +85,7 @@
 	eModifierType_DataTransfer      = 49,
 	eModifierType_NormalEdit        = 50,
 	eModifierType_CorrectiveSmooth  = 51,
+	eModifierType_Fracture          = 52,
 	NUM_MODIFIER_TYPES
 } ModifierType;
 
@@ -1407,6 +1408,34 @@
 	MOD_MESHCACHE_PLAY_EVAL = 1,
 };
 
+typedef struct MeshIsland {
+	struct MeshIsland *next, *prev;
+	struct BMVert **vertices;
+	struct MVert **vertices_cached;
+	float *vertco;
+	short *vertno;
+	struct DerivedMesh *physics_mesh;
+	struct Shard *temp; /* storage for physics mesh, better omit derivedmesh here...*/
+	struct RigidBodyOb *rigidbody;
+	int *neighbor_ids;
+	int *vertex_indices;
+	struct BoundBox *bb;
+	struct RigidBodyShardCon **participating_constraints;
+	int participating_constraint_count;
+	int vertex_count, id, neighbor_count;
+	float centroid[3], start_co[3];
+	float rot[4]; /*hrm, need this for constraints probably */
+	float thresh_weight, ground_weight;
+	int linear_index;  /* index in rigidbody world */
+	int particle_index;
+	//char pad[4];
+} MeshIsland;
+
+
+enum {
+	MOD_RIGIDBODY_CENTROIDS = 0,
+	MOD_RIGIDBODY_VERTICES = 1,
+};
 
 typedef struct LaplacianDeformModifierData {
 	ModifierData modifier;
@@ -1444,6 +1473,87 @@
 	MOD_WIREFRAME_CREASE        = (1 << 5),
 };
 
+enum {
+	MOD_FRACTURE_BISECT_FAST      = (1 << 0),
+	MOD_FRACTURE_BISECT_FAST_FILL = (1 << 1),
+	MOD_FRACTURE_BOOLEAN          = (1 << 2),
+	MOD_FRACTURE_BISECT_FILL      = (1 << 3),
+	MOD_FRACTURE_BISECT           = (1 << 4),
+};
+
+enum {
+	MOD_FRACTURE_OWN_VERTS       = (1 << 0),
+	MOD_FRACTURE_OWN_PARTICLES   = (1 << 1),
+	MOD_FRACTURE_EXTRA_VERTS     = (1 << 2),
+	MOD_FRACTURE_EXTRA_PARTICLES = (1 << 3),
+	MOD_FRACTURE_GREASEPENCIL    = (1 << 4),
+	MOD_FRACTURE_UNIFORM         = (1 << 5),
+};
+
+typedef struct FractureModifierData {
+	ModifierData modifier;
+	struct FracMesh *frac_mesh; /* store only the current fracmesh here first, later maybe an entire history...*/
+	struct DerivedMesh *dm;
+	struct Group *extra_group;
+	struct Group *dm_group;
+	struct BMesh *visible_mesh;
+	struct DerivedMesh *visible_mesh_cached;
+	ListBase meshIslands, meshConstraints;
+	ListBase islandShards;
+	char thresh_defgrp_name[64];  /* MAX_VGROUP_NAME */
+	char ground_defgrp_name[64];  /* MAX_VGROUP_NAME */
+	char inner_defgrp_name[64];  /* MAX_VGROUP_NAME */
+	struct KDTree *nor_tree; /* store original vertices here (coords), to find them later and reuse their normals */
+	struct Material *inner_material;
+	struct GHash *face_pairs;
+
+	/* values */
+	int frac_algorithm;
+	int shard_count;
+	int shard_id;
+	int point_source;
+	int point_seed;
+	int percentage;
+	int cluster_count;
+
+	int constraint_limit;
+	int solver_iterations_override;
+	int breaking_percentage;
+
+	float breaking_angle;
+	float breaking_distance;
+	float origmat[4][4];
+	float breaking_threshold;
+	float cluster_breaking_threshold;
+	float contact_dist, autohide_dist;
+
+	/* flags */
+	int refresh;
+	int refresh_constraints;
+
+	int use_constraints;
+	int use_mass_dependent_thresholds;
+	int use_particle_birth_coordinates;
+
+	int shards_to_islands;
+	int execute_threaded;
+	int fix_normals;
+	int auto_execute;
+
+	int breaking_distance_weighted;
+	int breaking_angle_weighted;
+	int breaking_percentage_weighted;
+
+	/* internal flags */
+	int use_experimental;
+	int explo_shared;
+	int refresh_images;
+
+	/* internal values */
+	float max_vol;
+
+	//char pad[4];
+} FractureModifierData;
 
 typedef struct DataTransferModifierData {
 	ModifierData modifier;
diff -ru --new-file blender-2.76b.old/source/blender/makesdna/DNA_rigidbody_types.h blender-2.76b/source/blender/makesdna/DNA_rigidbody_types.h
--- blender-2.76b.old/source/blender/makesdna/DNA_rigidbody_types.h	2015-10-30 23:31:41.000000000 +0300
+++ blender-2.76b/source/blender/makesdna/DNA_rigidbody_types.h	2016-01-27 21:46:19.555096345 +0300
@@ -46,6 +46,8 @@
  *
  * Represents a "simulation scene" existing within the parent scene.
  */
+typedef struct RigidBodyOb RigidBodyOb;
+
 typedef struct RigidBodyWorld {
 	/* Sim World Settings ------------------------------------------------------------- */
 	struct EffectorWeights *effector_weights; /* effectors info */
@@ -71,6 +73,12 @@
 	
 	/* References to Physics Sim objects. Exist at runtime only ---------------------- */
 	void *physics_world;		/* Physics sim world (i.e. btDiscreteDynamicsWorld) */
+	RigidBodyOb **cache_index_map;		/* Maps the linear RigidbodyOb index to the nested Object(Modifier) Index, at runtime*/
+	int *cache_offset_map;		/* Maps the linear RigidbodyOb index to the nested Object(Modifier) cell offset, at runtime, so it does not need to be calced in cache*/
+	int refresh_modifiers;		/* If we have rigidbody modifiers, time to refresh them if flag is set*/
+	int object_changed;			/* Flag changes to objects (especially those with modifiers)*/
+	int rebuild_comp_con;
+	char pad2[4];
 } RigidBodyWorld;
 
 /* Flags for RigidBodyWorld */
@@ -241,6 +249,62 @@
 	void *physics_constraint;	/* Physics object representation (i.e. btTypedConstraint) */
 } RigidBodyCon;
 
+/* RigidBodyConstraint (rbc)
+ *
+ * Represents an constraint connecting two shard rigid bodies.
+ */
+typedef struct RigidBodyShardCon {
+
+	struct RigidBodyShardCon *next, *prev;
+	struct MeshIsland *mi1;			/* First meshisland influenced by the constraint */
+	struct MeshIsland *mi2;			/* Second meshisland influenced by the constraint */
+
+	/* General Settings for this RigidBodyCon */
+	short type;					/* (eRigidBodyCon_Type) role of RigidBody in sim  */
+	short num_solver_iterations;/* number of constraint solver iterations made per simulation step */
+
+	int flag;					/* (eRigidBodyCon_Flag) */
+
+	float breaking_threshold;	/* breaking impulse threshold */
+	float start_angle;			//needed for breaking by angle and dist
+	float start_dist;
+	float pad;
+
+	/* limits */
+	/* translation limits */
+	float limit_lin_x_lower;
+	float limit_lin_x_upper;
+	float limit_lin_y_lower;
+	float limit_lin_y_upper;
+	float limit_lin_z_lower;
+	float limit_lin_z_upper;
+	/* rotation limits */
+	float limit_ang_x_lower;
+	float limit_ang_x_upper;
+	float limit_ang_y_lower;
+	float limit_ang_y_upper;
+	float limit_ang_z_lower;
+	float limit_ang_z_upper;
+
+	/* spring settings */
+	/* resistance to deformation */
+	float spring_stiffness_x;
+	float spring_stiffness_y;
+	float spring_stiffness_z;
+	/* amount of velocity lost over time */
+	float spring_damping_x;
+	float spring_damping_y;
+	float spring_damping_z;
+
+	/* motor settings */
+	float motor_lin_target_velocity;	/* linear velocity the motor tries to hold */
+	float motor_ang_target_velocity;	/* angular velocity the motor tries to hold */
+	float motor_lin_max_impulse;		/* maximum force used to reach linear target velocity */
+	float motor_ang_max_impulse;		/* maximum force used to reach angular target velocity */
+
+	/* References to Physics Sim object. Exist at runtime only */
+	void *physics_constraint;	/* Physics object representation (i.e. btTypedConstraint) */
+} RigidBodyShardCon;
 
 /* Participation types for RigidBodyOb */
 typedef enum eRigidBodyCon_Type {
diff -ru --new-file blender-2.76b.old/source/blender/makesdna/intern/makesdna.c blender-2.76b/source/blender/makesdna/intern/makesdna.c
--- blender-2.76b.old/source/blender/makesdna/intern/makesdna.c	2015-11-02 16:25:38.000000000 +0300
+++ blender-2.76b/source/blender/makesdna/intern/makesdna.c	2016-01-27 21:47:19.349667428 +0300
@@ -136,6 +136,7 @@
 	"DNA_rigidbody_types.h",
 	"DNA_freestyle_types.h",
 	"DNA_linestyle_types.h",
+	"DNA_fracture_types.h",
 
 	/* empty string to indicate end of includefiles */
 	""
@@ -1292,4 +1293,5 @@
 #include "DNA_rigidbody_types.h"
 #include "DNA_freestyle_types.h"
 #include "DNA_linestyle_types.h"
+#include "DNA_fracture_types.h"
 /* end of list */
diff -ru --new-file blender-2.76b.old/source/blender/makesrna/intern/rna_modifier.c blender-2.76b/source/blender/makesrna/intern/rna_modifier.c
--- blender-2.76b.old/source/blender/makesrna/intern/rna_modifier.c	2015-11-02 16:25:38.000000000 +0300
+++ blender-2.76b/source/blender/makesrna/intern/rna_modifier.c	2016-01-27 21:56:41.420627154 +0300
@@ -35,6 +35,7 @@
 #include "DNA_object_types.h"
 #include "DNA_object_force.h"
 #include "DNA_scene_types.h"
+#include "DNA_rigidbody_types.h"
 
 #include "MEM_guardedalloc.h"
 
@@ -51,6 +52,7 @@
 #include "BKE_mesh_remap.h"
 #include "BKE_multires.h"
 #include "BKE_smoke.h" /* For smokeModifier_free & smokeModifier_createType */
+#include "BKE_rigidbody.h"
 
 #include "RNA_access.h"
 #include "RNA_define.h"
@@ -111,6 +113,7 @@
 	{eModifierType_DynamicPaint, "DYNAMIC_PAINT", ICON_MOD_DYNAMICPAINT, "Dynamic Paint", ""},
 	{eModifierType_Explode, "EXPLODE", ICON_MOD_EXPLODE, "Explode", ""},
 	{eModifierType_Fluidsim, "FLUID_SIMULATION", ICON_MOD_FLUIDSIM, "Fluid Simulation", ""},
+	{eModifierType_Fracture, "FRACTURE", ICON_MOD_EXPLODE, "Fracture", ""},
 	{eModifierType_Ocean, "OCEAN", ICON_MOD_OCEAN, "Ocean", ""},
 	{eModifierType_ParticleInstance, "PARTICLE_INSTANCE", ICON_MOD_PARTICLES, "Particle Instance", ""},
 	{eModifierType_ParticleSystem, "PARTICLE_SYSTEM", ICON_MOD_PARTICLES, "Particle System", ""},
@@ -268,6 +271,8 @@
 #include "BKE_modifier.h"
 #include "BKE_object.h"
 #include "BKE_particle.h"
+#include "BKE_deform.h"
+#include "BKE_DerivedMesh.h"
 
 static void rna_UVProject_projectors_begin(CollectionPropertyIterator *iter, PointerRNA *ptr)
 {
@@ -374,6 +379,8 @@
 			return &RNA_LaplacianDeformModifier;
 		case eModifierType_Wireframe:
 			return &RNA_WireframeModifier;
+		case eModifierType_Fracture:
+			return &RNA_FractureModifier;
 		case eModifierType_DataTransfer:
 			return &RNA_DataTransferModifier;
 		case eModifierType_NormalEdit:
@@ -422,6 +429,17 @@
 
 static void rna_Modifier_update(Main *UNUSED(bmain), Scene *UNUSED(scene), PointerRNA *ptr)
 {
+	ModifierData* md = ptr->data;
+
+	if (md && md->type == eModifierType_Fracture)
+	{
+		FractureModifierData *fmd = (FractureModifierData*)md;
+		if (fmd->refresh)
+		{
+			return;
+		}
+	}
+
 	DAG_id_tag_update(ptr->id.data, OB_RECALC_DATA);
 	WM_main_add_notifier(NC_OBJECT | ND_MODIFIER, ptr->id.data);
 }
@@ -1069,6 +1087,318 @@
 	return (csmd->bind_coords != NULL);
 }
 
+static float rna_EdgeSplitModifier_split_angle_get(PointerRNA *ptr)
+{
+	EdgeSplitModifierData *md = (EdgeSplitModifierData *)ptr->data;
+	return DEG2RADF(md->split_angle);
+}
+
+static void rna_EdgeSplitModifier_split_angle_set(PointerRNA *ptr, float value)
+{
+	EdgeSplitModifierData *md = (EdgeSplitModifierData *)ptr->data;
+	value = RAD2DEGF(value);
+	CLAMP(value, 0.0f, 180.0f);
+	md->split_angle = (int)value;
+}
+
+static float rna_BevelModifier_angle_limit_get(PointerRNA *ptr)
+{
+	BevelModifierData *md = (BevelModifierData *)ptr->data;
+	return DEG2RADF(md->bevel_angle);
+}
+
+static void rna_BevelModifier_angle_limit_set(PointerRNA *ptr, float value)
+{
+	BevelModifierData *md = (BevelModifierData *)ptr->data;
+	value = RAD2DEGF(value);
+	CLAMP(value, 0.0f, 180.0f);
+	md->bevel_angle = (int)value;
+}
+
+/*static void rna_BevelModifier_defgrp_name_set(PointerRNA *ptr, const char *value)
+{
+	BevelModifierData *md = (BevelModifierData *)ptr->data;
+	rna_object_vgroup_name_set(ptr, value, md->defgrp_name, sizeof(md->defgrp_name));
+}*/
+
+static void rna_UVWarpModifier_vgroup_set(PointerRNA *ptr, const char *value)
+{
+	UVWarpModifierData *umd = (UVWarpModifierData *)ptr->data;
+	rna_object_vgroup_name_set(ptr, value, umd->vgroup_name, sizeof(umd->vgroup_name));
+}
+
+static void rna_UVWarpModifier_uvlayer_set(PointerRNA *ptr, const char *value)
+{
+	UVWarpModifierData *umd = (UVWarpModifierData *)ptr->data;
+	rna_object_uvlayer_name_set(ptr, value, umd->uvlayer_name, sizeof(umd->uvlayer_name));
+}
+
+static void updateShards(FractureModifierData *fmd, Object *ob)
+{
+	MeshIsland *mi;
+	int vertstart = 0;
+	const int thresh_defgrp_index = defgroup_name_index(ob, fmd->thresh_defgrp_name);
+	const int ground_defgrp_index = defgroup_name_index(ob, fmd->ground_defgrp_name);
+	DerivedMesh *dm = ob->derivedFinal;
+	MDeformVert *dvert;
+
+	if (dm == NULL)
+		return;
+
+	dvert = dm->getVertDataArray(dm, CD_MDEFORMVERT);
+
+	for (mi = fmd->meshIslands.first; mi; mi = mi->next)
+	{
+		int i = 0;
+
+		mi->ground_weight = 0.0f;
+
+		if (fmd->dm != NULL && !fmd->shards_to_islands)
+		{
+			for (i = 0; i < mi->vertex_count; i++)
+			{
+				//sum up vertexweights and divide by vertcount to get islandweight
+				if (dvert && dvert->dw && fmd->thresh_defgrp_name[0]) {
+					float vweight = defvert_find_weight(dvert + vertstart + i, thresh_defgrp_index);
+					mi->thresh_weight += vweight;
+				}
+
+				if (dvert && dvert->dw && fmd->ground_defgrp_name[0]) {
+					float gweight = defvert_find_weight(dvert + vertstart + i, ground_defgrp_index);
+					mi->ground_weight += gweight;
+				}
+			}
+
+			vertstart += mi->vertex_count;
+		}
+		else
+		{
+			for (i = 0; i < mi->vertex_count; i++)
+			{
+				int index = mi->vertex_indices[i];
+
+				if (dvert && dvert->dw && fmd->thresh_defgrp_name[0]) {
+					float vweight = defvert_find_weight(dvert + index, thresh_defgrp_index);
+					mi->thresh_weight += vweight;
+				}
+
+				if (dvert && dvert->dw && fmd->ground_defgrp_name[0]) {
+					float gweight = defvert_find_weight(dvert + index, ground_defgrp_index);
+					mi->ground_weight += gweight;
+				}
+			}
+		}
+
+		if (mi->vertex_count > 0)
+		{
+			mi->thresh_weight /= mi->vertex_count;
+			mi->ground_weight /= mi->vertex_count;
+		}
+
+		if (mi->rigidbody)
+		{
+			mi->rigidbody->type = mi->ground_weight > 0.5f ? RBO_TYPE_PASSIVE : RBO_TYPE_ACTIVE;
+			mi->rigidbody->flag |= RBO_FLAG_NEEDS_VALIDATE;
+		}
+	}
+}
+
+static void updateConstraints(FractureModifierData *rmd, Object* ob) {
+	RigidBodyShardCon *rbsc;
+	int index1, index2;
+	float max_con_mass = 0;
+	int iterations;
+
+	if (rmd->use_mass_dependent_thresholds) {
+		max_con_mass = BKE_rigidbody_calc_max_con_mass(ob);
+	}
+
+	for (rbsc = rmd->meshConstraints.first; rbsc; rbsc = rbsc->next) {
+		/*index1 = BLI_findindex(&rmd->meshIslands, rbsc->mi1);
+		index2 = BLI_findindex(&rmd->meshIslands, rbsc->mi2);
+		if ((index1 == -1) || (index2 == -1)) {
+			rbsc->breaking_threshold = rmd->group_breaking_threshold;
+		}
+		else*/
+		{
+			rbsc->breaking_threshold = rmd->breaking_threshold;
+		}
+		
+		if (rbsc->breaking_threshold == 0)
+		{
+			rbsc->flag &= ~RBC_FLAG_USE_BREAKING;
+		}
+		else
+		{
+			rbsc->flag |= RBC_FLAG_USE_BREAKING;
+		}
+
+		if (((rmd->use_mass_dependent_thresholds)) && (rbsc->breaking_threshold > 0)) {
+			BKE_rigidbody_calc_threshold(max_con_mass, rmd, rbsc);
+		}
+
+		if (rmd->thresh_defgrp_name[0])
+		{
+			rbsc->breaking_threshold *= ((rbsc->mi1->thresh_weight + rbsc->mi2->thresh_weight) * 0.5f);
+		}
+		
+		if (rmd->solver_iterations_override == 0)
+		{
+			iterations = rmd->modifier.scene->rigidbody_world->num_solver_iterations;
+		}
+		else
+		{
+			iterations = rmd->solver_iterations_override;
+		}
+		
+		if (iterations > 0)
+		{
+			rbsc->flag |= RBC_FLAG_OVERRIDE_SOLVER_ITERATIONS;
+			rbsc->num_solver_iterations = iterations;
+		}
+
+		//reenable all
+		rbsc->flag |= RBC_FLAG_ENABLED;
+		rbsc->flag |= RBC_FLAG_NEEDS_VALIDATE;
+	}
+	
+	//if (rmd->use_cellbased_sim)
+	{
+		rmd->refresh_constraints = true;
+	}
+}
+
+static void rna_FractureModifier_thresh_defgrp_name_set(PointerRNA *ptr, const char *value)
+{
+	FractureModifierData *tmd = (FractureModifierData *)ptr->data;
+	Object* ob = ptr->id.data;
+	rna_object_vgroup_name_set(ptr, value, tmd->thresh_defgrp_name, sizeof(tmd->thresh_defgrp_name));
+	//updateShards(tmd, ob); //deactivate for now, since we need a real re-fracture to re-apply interpolation
+	//updateConstraints(tmd, ob);
+	tmd->refresh_constraints = true;
+}
+
+static void rna_FractureModifier_ground_defgrp_name_set(PointerRNA *ptr, const char *value)
+{
+	FractureModifierData *tmd = (FractureModifierData *)ptr->data;
+	Object* ob = ptr->id.data;
+	rna_object_vgroup_name_set(ptr, value, tmd->ground_defgrp_name, sizeof(tmd->ground_defgrp_name));
+	//updateShards(tmd, ob); //deactivate for now, since we need a real re-fracture to re-apply interpolation
+	tmd->refresh_constraints = true;
+}
+
+static void rna_FractureModifier_inner_defgrp_name_set(PointerRNA *ptr, const char *value)
+{
+	FractureModifierData *tmd = (FractureModifierData *)ptr->data;
+	Object* ob = ptr->id.data;
+	rna_object_vgroup_name_set(ptr, value, tmd->inner_defgrp_name, sizeof(tmd->inner_defgrp_name));
+	//updateShards(tmd, ob); //deactivate for now, since we need a real re-fracture to re-apply interpolation
+	tmd->refresh_constraints = true;
+}
+
+static void rna_RigidBodyModifier_threshold_set(PointerRNA *ptr, float value)
+{
+	FractureModifierData *rmd = (FractureModifierData*)ptr->data;
+	Object* ob = ptr->id.data;
+	rmd->breaking_threshold = value;
+	//updateConstraints(rmd, ob);
+	rmd->refresh_constraints = true;
+}
+
+static void rna_RigidBodyModifier_contact_dist_set(PointerRNA *ptr, float value)
+{
+	FractureModifierData *rmd = (FractureModifierData*)ptr->data;
+	Object* ob = ptr->id.data;
+	rmd->contact_dist = value;
+	//updateConstraints(rmd, ob);
+	rmd->refresh_constraints = true;
+}
+
+static void rna_RigidBodyModifier_use_constraints_set(PointerRNA* ptr, int value)
+{
+	FractureModifierData *rmd = (FractureModifierData *)ptr->data;
+	rmd->use_constraints = value;
+	/*if (rmd->use_cellbased_sim)
+	{
+		rmd->refresh_constraints = true;
+	}*/
+	rmd->refresh_constraints = true;
+}
+
+static void rna_RigidBodyModifier_mass_dependent_thresholds_set(PointerRNA* ptr, int value)
+{
+	FractureModifierData *rmd = (FractureModifierData *)ptr->data;
+	Object* ob = ptr->id.data;
+	rmd->use_mass_dependent_thresholds = value;
+	//updateConstraints(rmd, ob);
+	rmd->refresh_constraints = true;
+}
+
+static void rna_RigidBodyModifier_constraint_limit_set(PointerRNA *ptr, int value)
+{
+	FractureModifierData *rmd = (FractureModifierData*)ptr->data;
+	rmd->constraint_limit = value;
+	/*if (rmd->use_cellbased_sim)
+	{
+		rmd->refresh_constraints = true;
+	}*/
+	rmd->refresh_constraints = true;
+}
+
+static void rna_RigidBodyModifier_breaking_percentage_set(PointerRNA *ptr, int value)
+{
+	FractureModifierData *rmd = (FractureModifierData*)ptr->data;
+	Object* ob = ptr->id.data;
+	rmd->breaking_percentage = value;
+	//updateConstraints(rmd, ob);
+	rmd->refresh_constraints = true;
+}
+
+static void rna_RigidBodyModifier_breaking_angle_set(PointerRNA *ptr, float value)
+{
+	FractureModifierData *rmd = (FractureModifierData*)ptr->data;
+	Object* ob = ptr->id.data;
+	rmd->breaking_angle = value;
+	//updateConstraints(rmd, ob);
+	rmd->refresh_constraints = true;
+}
+
+static void rna_RigidBodyModifier_breaking_distance_set(PointerRNA *ptr, float value)
+{
+	FractureModifierData *rmd = (FractureModifierData*)ptr->data;
+	Object* ob = ptr->id.data;
+	rmd->breaking_distance = value;
+	//updateConstraints(rmd, ob);
+	rmd->refresh_constraints = true;
+}
+
+static void rna_RigidBodyModifier_cluster_threshold_set(PointerRNA *ptr, float value)
+{
+	FractureModifierData *rmd = (FractureModifierData*)ptr->data;
+	Object* ob = ptr->id.data;
+	rmd->cluster_breaking_threshold = value;
+	//updateConstraints(rmd, ob);
+	rmd->refresh_constraints = true;
+}
+
+static void rna_RigidBodyModifier_solver_iterations_override_set(PointerRNA *ptr, float value)
+{
+	FractureModifierData *rmd = (FractureModifierData*)ptr->data;
+	Object* ob = ptr->id.data;
+	rmd->solver_iterations_override = value;
+	//updateConstraints(rmd, ob);
+	rmd->refresh_constraints = true;
+}
+
+static void rna_RigidBodyModifier_autohide_dist_set(PointerRNA *ptr, float value)
+{
+	FractureModifierData *rmd = (FractureModifierData*)ptr->data;
+	Object* ob = ptr->id.data;
+	rmd->autohide_dist = value;
+	//updateConstraints(rmd, ob);
+	rmd->refresh_constraints = true;
+}
+
 #else
 
 static PropertyRNA *rna_def_property_subdivision_common(StructRNA *srna, const char type[])
@@ -4577,6 +4907,226 @@
 	RNA_def_property_update(prop, 0, "rna_Modifier_update");
 }
 
+static void rna_def_modifier_fracture(BlenderRNA *brna)
+{
+	StructRNA *srna;
+	PropertyRNA *prop;
+
+	static EnumPropertyItem prop_fracture_algorithm[] = {
+		{MOD_FRACTURE_BISECT_FAST, "BISECT_FAST", 0, "Fast Bisect", "Use a faster but more inaccurate bisection algorithm, also creates uglier shards."},
+		{MOD_FRACTURE_BISECT_FAST_FILL, "BISECT_FAST_FILL", 0, "Fast Bisect + Fill ", "Use the faster but different bisection algorithm and fill cut faces"},
+		{MOD_FRACTURE_BOOLEAN, "BOOLEAN", 0, "Voronoi + Boolean", "Use voronoi and boolean intersection as fracture algorithm"},
+		{MOD_FRACTURE_BISECT_FILL, "BISECT_FILL", 0, "Voronoi + Bisect + Fill", "Use voronoi and mesh bisect as fracture algorithm, fill cut faces"},
+		{MOD_FRACTURE_BISECT, "BISECT", 0, "Voronoi + Bisect", "Use voronoi and mesh bisect as fracture algorithm, don't fill cut faces"},
+		{0, NULL, 0, NULL, NULL}
+	};
+
+	static EnumPropertyItem prop_point_source_items[] = {
+		{MOD_FRACTURE_OWN_PARTICLES, "OWN_PARTICLES", 0, "Own Particles", "Use own particles as point cloud"},
+		{MOD_FRACTURE_OWN_VERTS, "OWN_VERTS", 0, "Own Vertices", "Use own vertices as point cloud"},
+		{MOD_FRACTURE_EXTRA_PARTICLES, "EXTRA_PARTICLES", 0, "Extra Particles", "Use particles of group objects as point cloud"},
+		{MOD_FRACTURE_EXTRA_VERTS, "EXTRA_VERTS", 0, "Extra Vertices", "Use vertices of group objects as point cloud"},
+		{MOD_FRACTURE_GREASEPENCIL, "GREASE_PENCIL", 0, "Grease Pencil", "Use grease pencil points as point cloud"},
+		{MOD_FRACTURE_UNIFORM, "UNIFORM", 0, "Uniform", "Use a random uniform pointcloud generated over the bounding box"},
+		{0, NULL, 0, NULL, NULL}
+	};
+
+	srna = RNA_def_struct(brna, "FractureModifier", "Modifier");
+	RNA_def_struct_ui_text(srna, "Fracture Modifier", "Add a fracture container to this object");
+	RNA_def_struct_sdna(srna, "FractureModifierData");
+	RNA_def_struct_ui_icon(srna, ICON_MOD_EXPLODE);
+
+	prop = RNA_def_property(srna, "cluster_count", PROP_INT, PROP_NONE);
+	RNA_def_property_range(prop, 0, 100000);
+	RNA_def_property_ui_text(prop, "Cluster Count", "Amount of clusters built from existing shards, 0 for none");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	//simulation stuff...
+	prop = RNA_def_property(srna, "breaking_threshold", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "breaking_threshold");
+	RNA_def_property_range(prop, 0.0f, FLT_MAX);
+	RNA_def_property_float_funcs(prop, NULL, "rna_RigidBodyModifier_threshold_set", NULL);
+	RNA_def_property_ui_text(prop, "Inner Breaking threshold", "Threshold to break constraints between shards in the same object");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "use_constraints", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_funcs(prop, NULL, "rna_RigidBodyModifier_use_constraints_set");
+	RNA_def_property_ui_text(prop, "Use Constraints", "Create constraints between all shards");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "contact_dist", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "contact_dist");
+	RNA_def_property_range(prop, 0.0f, FLT_MAX);
+	RNA_def_property_float_default(prop, 1.0f);
+	RNA_def_property_float_funcs(prop, NULL, "rna_RigidBodyModifier_contact_dist_set", NULL);
+	RNA_def_property_ui_text(prop, "Contact distance", "Limit distance up to which two mesh islands are considered to have contact, 0 for entire boundingbox");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "use_mass_dependent_thresholds", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_funcs(prop, NULL, "rna_RigidBodyModifier_mass_dependent_thresholds_set");
+	RNA_def_property_ui_text(prop, "Use Mass Dependent Thresholds", "Match the breaking threshold according to the masses of the constrained shards");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "constraint_limit", PROP_INT, PROP_NONE);
+	RNA_def_property_int_sdna(prop, NULL, "constraint_limit");
+	RNA_def_property_range(prop, 0, INT_MAX);
+	RNA_def_property_int_funcs(prop, NULL, "rna_RigidBodyModifier_constraint_limit_set", NULL);
+	RNA_def_property_ui_text(prop, "Constraint Search Limit", "Maximum number of neighbors being searched per mesh island during constraint creation, 0 for unlimited");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "breaking_percentage", PROP_INT, PROP_NONE);
+	RNA_def_property_int_sdna(prop, NULL, "breaking_percentage");
+	RNA_def_property_range(prop, 0, 100);
+	RNA_def_property_int_funcs(prop, NULL, "rna_RigidBodyModifier_breaking_percentage_set", NULL);
+	RNA_def_property_ui_text(prop, "Breaking Percentage", "Percentage of broken constraints per island which leads to breaking of all others");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "breaking_angle", PROP_FLOAT, PROP_ANGLE);
+	RNA_def_property_float_sdna(prop, NULL, "breaking_angle");
+	RNA_def_property_range(prop, 0, DEG2RADF(360.0));
+	RNA_def_property_float_funcs(prop, NULL, "rna_RigidBodyModifier_breaking_angle_set", NULL);
+	RNA_def_property_ui_text(prop, "Breaking Angle", "Angle in degrees above which constraint should break");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "breaking_distance", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "breaking_distance");
+	RNA_def_property_range(prop, 0, FLT_MAX);
+	RNA_def_property_float_funcs(prop, NULL, "rna_RigidBodyModifier_breaking_distance_set", NULL);
+	RNA_def_property_ui_text(prop, "Breaking Distance", "Distance above which constraint should break");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "use_experimental", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "use_experimental", false);
+	RNA_def_property_ui_text(prop, "Use Experimental", "Experimental features, work in progress. Use at own risk!");
+
+	prop = RNA_def_property(srna, "cluster_breaking_threshold", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "cluster_breaking_threshold");
+	RNA_def_property_range(prop, 0.0f, FLT_MAX);
+	RNA_def_property_float_funcs(prop, NULL, "rna_RigidBodyModifier_cluster_threshold_set", NULL);
+	RNA_def_property_ui_text(prop, "Cluster Breaking threshold", "Threshold to break constraints INSIDE a cluster of shards");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "solver_iterations_override", PROP_INT, PROP_NONE);
+	RNA_def_property_int_sdna(prop, NULL, "solver_iterations_override");
+	RNA_def_property_range(prop, 0, INT_MAX);
+	RNA_def_property_int_funcs(prop, NULL, "rna_RigidBodyModifier_solver_iterations_override_set", NULL);
+	RNA_def_property_ui_text(prop, "Solver Iterations Override", "Override the world constraint solver iteration value with this value, 0 means no override");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "frac_algorithm", PROP_ENUM, PROP_NONE);
+	RNA_def_property_enum_items(prop, prop_fracture_algorithm);
+	RNA_def_property_ui_text(prop, "Fracture Algorithm", "Select type of fracture algorithm");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "shard_count", PROP_INT, PROP_NONE);
+	RNA_def_property_range(prop, 1, 100000);
+	RNA_def_property_int_default(prop, 10);
+	RNA_def_property_ui_text(prop, "Shard Count", "How many sub-shards should be generated from the current shard");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "point_source", PROP_ENUM, PROP_NONE);
+	RNA_def_property_enum_items(prop, prop_point_source_items);
+	RNA_def_property_flag(prop, PROP_ENUM_FLAG);
+	RNA_def_property_enum_default(prop, MOD_FRACTURE_UNIFORM);
+	RNA_def_property_ui_text(prop, "Point Source", "Source of point cloud");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "point_seed", PROP_INT, PROP_NONE);
+	RNA_def_property_range(prop, 0, 100000);
+	RNA_def_property_ui_text(prop, "Seed", "Seed for uniform pointcloud");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "percentage", PROP_INT, PROP_NONE);
+	RNA_def_property_range(prop, 0, 100);
+	RNA_def_property_ui_text(prop, "Percentage", "Percentage of the sum of points of all selected pointsources to actually use for fracture");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "extra_group", PROP_POINTER, PROP_NONE);
+	RNA_def_property_ui_text(prop, "Extra Group", "");
+	RNA_def_property_flag(prop, PROP_EDITABLE);
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "shards_to_islands", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "shards_to_islands", false);
+	RNA_def_property_ui_text(prop, "Split Shards to Islands", "Split each shard to separate mesh islands");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "execute_threaded", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "execute_threaded", false);
+	RNA_def_property_ui_text(prop, "Execute as threaded job (WIP)", "Execute the fracture as threaded job, Warning: WIP, still may crash");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+
+	//expose this to RNA to be able to let py checkbox disappear while job is running, otherwise crash
+	prop = RNA_def_property(srna, "refresh", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "refresh", false);
+	RNA_def_property_ui_text(prop, "Refresh", "Refresh");
+
+	prop = RNA_def_property(srna, "thresh_vertex_group", PROP_STRING, PROP_NONE);
+	RNA_def_property_string_sdna(prop, NULL, "thresh_defgrp_name");
+	RNA_def_property_ui_text(prop, "Threshold Vertex Group", "Vertex group name for defining weighted thresholds on different mesh parts");
+	RNA_def_property_string_funcs(prop, NULL, NULL, "rna_FractureModifier_thresh_defgrp_name_set");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "ground_vertex_group", PROP_STRING, PROP_NONE);
+	RNA_def_property_string_sdna(prop, NULL, "ground_defgrp_name");
+	RNA_def_property_ui_text(prop, "Passive Vertex Group", "Vertex group name for defining passive mesh parts (will remain static during rigidbody simulation");
+	RNA_def_property_string_funcs(prop, NULL, NULL, "rna_FractureModifier_ground_defgrp_name_set");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "fix_normals", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "fix_normals", false);
+	RNA_def_property_ui_text(prop, "Fix normals (WIP)", "Fix normals of fractured smooth objects, to let cracks nearly disappear");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "inner_material", PROP_POINTER, PROP_NONE);
+	RNA_def_property_ui_text(prop, "Inner Material", "");
+	RNA_def_property_flag(prop, PROP_EDITABLE);
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "inner_vertex_group", PROP_STRING, PROP_NONE);
+	RNA_def_property_string_sdna(prop, NULL, "inner_defgrp_name");
+	RNA_def_property_ui_text(prop, "Inner Vertex Group", "Vertex group name for defining inner vertices (will contain vertices of inner faces (Boolean, Bisect + Fill only) ");
+	RNA_def_property_string_funcs(prop, NULL, NULL, "rna_FractureModifier_inner_defgrp_name_set");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "auto_execute", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "auto_execute", false);
+	RNA_def_property_ui_text(prop, "Auto Execute", "Automatic execution of fracturing, CAUTION: this can be slow and buggy");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "dm_group", PROP_POINTER, PROP_NONE);
+	RNA_def_property_ui_text(prop, "Sub Object Group", "");
+	RNA_def_property_flag(prop, PROP_EDITABLE);
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "autohide_dist", PROP_FLOAT, PROP_NONE);
+	RNA_def_property_float_sdna(prop, NULL, "autohide_dist");
+	RNA_def_property_float_funcs(prop, NULL, "rna_RigidBodyModifier_autohide_dist_set", NULL);
+	RNA_def_property_ui_text(prop, "Autohide Distance", "Distance between faces below which both faces should be hidden");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "breaking_percentage_weighted", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "breaking_percentage_weighted", false);
+	RNA_def_property_ui_text(prop, "Weighted Percentage", "Modify breaking percentage by threshold weights");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "breaking_angle_weighted", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "breaking_angle_weighted", false);
+	RNA_def_property_ui_text(prop, "Weighted Angle", "Modify breaking angle by threshold weights");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "breaking_distance_weighted", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "breaking_distance_weighted", false);
+	RNA_def_property_ui_text(prop, "Weighted Distance", "Modify breaking distance by threshold weights");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+
+	prop = RNA_def_property(srna, "use_particle_birth_coordinates", PROP_BOOLEAN, PROP_NONE);
+	RNA_def_property_boolean_sdna(prop, NULL, "use_particle_birth_coordinates", false);
+	RNA_def_property_ui_text(prop, "Use Initial Particle Coordinates", "Use initial or simulated state particle coordinates");
+	RNA_def_property_update(prop, 0, "rna_Modifier_update");
+}
+
 void RNA_def_modifier(BlenderRNA *brna)
 {
 	StructRNA *srna;
@@ -4693,6 +5243,7 @@
 	rna_def_modifier_wireframe(brna);
 	rna_def_modifier_datatransfer(brna);
 	rna_def_modifier_normaledit(brna);
+	rna_def_modifier_fracture(brna);
 }
 
 #endif
diff -ru --new-file blender-2.76b.old/source/blender/makesrna/intern/rna_rigidbody.c blender-2.76b/source/blender/makesrna/intern/rna_rigidbody.c
--- blender-2.76b.old/source/blender/makesrna/intern/rna_rigidbody.c	2015-11-04 13:02:15.000000000 +0300
+++ blender-2.76b/source/blender/makesrna/intern/rna_rigidbody.c	2016-01-27 22:11:22.524320900 +0300
@@ -37,6 +37,7 @@
 #include "DNA_object_types.h"
 #include "DNA_rigidbody_types.h"
 #include "DNA_scene_types.h"
+#include "DNA_modifier_types.h"
 
 #include "BLI_utildefines.h"
 #include "BLI_math.h"
@@ -146,9 +147,109 @@
 
 /* ******************************** */
 
-static void rna_RigidBodyOb_reset(Main *UNUSED(bmain), Scene *scene, PointerRNA *UNUSED(ptr))
+
+/* ------------------------------------------ */
+
+void foreach_shard_float(Object* ob, float value, void (*func)(RigidBodyOb *rbo, float value))
+{
+	ModifierData *md;
+	FractureModifierData* rmd;
+	MeshIsland* mi;
+	for (md = ob->modifiers.first; md; md = md->next) {
+		if (md->type == eModifierType_Fracture) {
+			rmd = (FractureModifierData*)md;
+			for (mi = rmd->meshIslands.first; mi; mi = mi->next) {
+				if (mi->rigidbody != NULL) {
+					func(mi->rigidbody, value);
+				}
+			}
+		}
+	}
+}
+
+void foreach_shard_mass(Object *ob)
+{
+	ModifierData *md;
+	FractureModifierData* rmd;
+	MeshIsland* mi;
+
+	for (md = ob->modifiers.first; md; md = md->next) {
+		if (md->type == eModifierType_Fracture) {
+			rmd = (FractureModifierData*)md;
+			for (mi = rmd->meshIslands.first; mi; mi = mi->next) {
+				if (mi->rigidbody != NULL) {
+					BKE_rigidbody_calc_shard_mass(ob, mi, NULL);
+				}
+			}
+		}
+	}
+}
+
+void foreach_shard_int(Object *ob, int value, void (*func)(RigidBodyOb *rbo, int value))
+{
+	ModifierData *md;
+	FractureModifierData* rmd;
+	MeshIsland* mi;
+	for (md = ob->modifiers.first; md; md = md->next) {
+		if (md->type == eModifierType_Fracture) {
+			rmd = (FractureModifierData*)md;
+			for (mi = rmd->meshIslands.first; mi; mi = mi->next) {
+				if (mi->rigidbody != NULL) {
+					func(mi->rigidbody, value);
+				}
+			}
+		}
+	}
+}
+
+void foreach_shard_ints(Object *ob, const int *value, void (*func)(RigidBodyOb *rbo, const int *value))
+{
+	ModifierData *md;
+	FractureModifierData* rmd;
+	MeshIsland *mi;
+
+	for (md = ob->modifiers.first; md; md = md->next) {
+		if (md->type == eModifierType_Fracture) {
+			rmd = (FractureModifierData*)md;
+			for (mi = rmd->meshIslands.first; mi; mi = mi->next) {
+				if (mi->rigidbody != NULL) {
+					func(mi->rigidbody, value);
+				}
+			}
+		}
+	}
+}
+
+void foreach_shard_flag_shape(Object *ob, int flag, short shape, bool reset)
+{
+	ModifierData *md;
+	FractureModifierData *rmd;
+	MeshIsland *mi;
+
+	for (md = ob->modifiers.first; md; md = md->next) {
+		if (md->type == eModifierType_Fracture) {
+			rmd = (FractureModifierData*)md;
+			for (mi = rmd->meshIslands.first; mi; mi = mi->next) {
+				if (mi->rigidbody != NULL) {
+					mi->rigidbody->flag = flag;
+					mi->rigidbody->shape = shape;
+					if (reset) {
+						if (mi->rigidbody->physics_shape)
+							mi->rigidbody->flag |= RBO_FLAG_NEEDS_RESHAPE;
+					}
+				}
+			}
+		}
+	}
+}
+
+
+static void rna_RigidBodyOb_reset(Main *bmain, Scene *scene, PointerRNA *ptr)
 {
 	RigidBodyWorld *rbw = scene->rigidbody_world;
+	Object *ob = ptr->id.data;
+	RigidBodyOb* rbo = ptr->data;
+	foreach_shard_flag_shape(ob, rbo->flag, rbo->shape, false);
 	
 	BKE_rigidbody_cache_reset(rbw);
 }
@@ -162,11 +263,13 @@
 	WM_main_add_notifier(NC_OBJECT | ND_DRAW, ob);
 }
 
-static void rna_RigidBodyOb_shape_reset(Main *UNUSED(bmain), Scene *scene, PointerRNA *ptr)
+static void rna_RigidBodyOb_shape_reset(Main *bmain, Scene *scene, PointerRNA *ptr)
 {
 	RigidBodyWorld *rbw = scene->rigidbody_world;
 	RigidBodyOb *rbo = (RigidBodyOb *)ptr->data;
-	
+	Object *ob = ptr->id.data;
+
+	foreach_shard_flag_shape(ob, rbo->flag, rbo->shape, true);	
 	BKE_rigidbody_cache_reset(rbw);
 	if (rbo->physics_shape)
 		rbo->flag |= RBO_FLAG_NEEDS_RESHAPE;
@@ -178,42 +281,46 @@
 	return BLI_sprintfN("rigid_body");
 }
 
-static void rna_RigidBodyOb_type_set(PointerRNA *ptr, int value)
-{
-	RigidBodyOb *rbo = (RigidBodyOb *)ptr->data;
-	
+static void set_type(RigidBodyOb* rbo, int value) {	
 	rbo->type = value;
 	rbo->flag |= RBO_FLAG_NEEDS_VALIDATE;
 }
 
-static void rna_RigidBodyOb_shape_set(PointerRNA *ptr, int value)
+static void rna_RigidBodyOb_type_set(PointerRNA *ptr, int value)
 {
 	RigidBodyOb *rbo = (RigidBodyOb *)ptr->data;
-
-	rbo->shape = value;
-	rbo->flag |= RBO_FLAG_NEEDS_VALIDATE;
+	Object* ob = ptr->id.data;
+	set_type(rbo, value);
+	foreach_shard_int(ob, value, set_type);
 }
 
-static void rna_RigidBodyOb_disabled_set(PointerRNA *ptr, int value)
-{
-	RigidBodyOb *rbo = (RigidBodyOb *)ptr->data;
-	
-	RB_FLAG_SET(rbo->flag, !value, RBO_FLAG_DISABLED);
+static void set_disabled(RigidBodyOb* rbo, int value) {
+
+	int flag = value;
+	flag = !flag;
 
+	RB_FLAG_SET(rbo->flag, flag, RBO_FLAG_DISABLED);
 #ifdef WITH_BULLET
 	/* update kinematic state if necessary - only needed for active bodies */
 	if ((rbo->physics_object) && (rbo->type == RBO_TYPE_ACTIVE)) {
 		RB_body_set_mass(rbo->physics_object, RBO_GET_MASS(rbo));
-		RB_body_set_kinematic_state(rbo->physics_object, !value);
+		RB_body_set_kinematic_state(rbo->physics_object, flag);
 		rbo->flag |= RBO_FLAG_NEEDS_VALIDATE;
 	}
 #endif
 }
 
-static void rna_RigidBodyOb_mass_set(PointerRNA *ptr, float value)
+static void rna_RigidBodyOb_disabled_set(PointerRNA *ptr, int value)
 {
 	RigidBodyOb *rbo = (RigidBodyOb *)ptr->data;
-	
+	Object *ob = ptr->id.data;
+	set_disabled(rbo, value);
+	foreach_shard_int(ob, value, set_disabled);
+}
+
+
+void set_mass(RigidBodyOb* rbo, float value)
+{	
 	rbo->mass = value;
 
 #ifdef WITH_BULLET
@@ -224,10 +331,17 @@
 #endif
 }
 
-static void rna_RigidBodyOb_friction_set(PointerRNA *ptr, float value)
+static void rna_RigidBodyOb_mass_set(PointerRNA *ptr, float value)
 {
 	RigidBodyOb *rbo = (RigidBodyOb *)ptr->data;
-	
+	Object* ob = ptr->id.data;
+	set_mass(rbo, value);
+	//foreach_shard_float(ob, value, set_mass);
+	foreach_shard_mass(ob);
+}
+
+void set_friction(RigidBodyOb* rbo, float value)
+{	
 	rbo->friction = value;
 
 #ifdef WITH_BULLET
@@ -237,10 +351,16 @@
 #endif
 }
 
-static void rna_RigidBodyOb_restitution_set(PointerRNA *ptr, float value)
+static void rna_RigidBodyOb_friction_set(PointerRNA *ptr, float value)
 {
 	RigidBodyOb *rbo = (RigidBodyOb *)ptr->data;
-	
+	Object* ob = ptr->id.data;
+	set_friction(rbo, value);
+	foreach_shard_float(ob, value, set_friction);
+}
+
+void set_restitution(RigidBodyOb *rbo, float value)
+{	
 	rbo->restitution = value;
 #ifdef WITH_BULLET
 	if (rbo->physics_object) {
@@ -252,7 +372,13 @@
 static void rna_RigidBodyOb_collision_margin_set(PointerRNA *ptr, float value)
 {
 	RigidBodyOb *rbo = (RigidBodyOb *)ptr->data;
-	
+	Object* ob = ptr->id.data;
+	set_restitution(rbo, value);
+	foreach_shard_float(ob, value, set_restitution);
+}
+
+void set_collision_margin(RigidBodyOb* rbo, float value)
+{	
 	rbo->margin = value;
 
 #ifdef WITH_BULLET
@@ -262,9 +388,16 @@
 #endif
 }
 
-static void rna_RigidBodyOb_collision_groups_set(PointerRNA *ptr, const int *values)
+static void rna_RigidBodyOb_collision_margin_set(PointerRNA *ptr, float value)
 {
 	RigidBodyOb *rbo = (RigidBodyOb *)ptr->data;
+	Object *ob = ptr->id.data;
+	set_collision_margin(rbo, value);
+	foreach_shard_float(ob, value, set_collision_margin);
+}
+
+void set_collision_groups(RigidBodyOb* rbo, const int *values)
+{
 	int i;
 
 	for (i = 0; i < 20; i++) {
@@ -276,26 +409,41 @@
 	rbo->flag |= RBO_FLAG_NEEDS_VALIDATE;
 }
 
-static void rna_RigidBodyOb_kinematic_state_set(PointerRNA *ptr, int value)
+static void rna_RigidBodyOb_collision_groups_set(PointerRNA *ptr, const int *values)
 {
 	RigidBodyOb *rbo = (RigidBodyOb *)ptr->data;
 	
-	RB_FLAG_SET(rbo->flag, value, RBO_FLAG_KINEMATIC);
+	Object *ob = ptr->id.data;
+
+	set_collision_groups(rbo, values);
+	foreach_shard_ints(ob, values, set_collision_groups);
+}
+
+void set_kinematic(RigidBodyOb *rbo, int value)
+{
+	int flag = value;
+	RB_FLAG_SET(rbo->flag, flag, RBO_FLAG_KINEMATIC);
 
 #ifdef WITH_BULLET
 	/* update kinematic state if necessary */
 	if (rbo->physics_object) {
 		RB_body_set_mass(rbo->physics_object, RBO_GET_MASS(rbo));
-		RB_body_set_kinematic_state(rbo->physics_object, value);
+		RB_body_set_kinematic_state(rbo->physics_object, flag);
 		rbo->flag |= RBO_FLAG_NEEDS_VALIDATE;
 	}
 #endif
 }
 
-static void rna_RigidBodyOb_activation_state_set(PointerRNA *ptr, int value)
+static void rna_RigidBodyOb_kinematic_state_set(PointerRNA *ptr, int value)
 {
 	RigidBodyOb *rbo = (RigidBodyOb *)ptr->data;
-	
+	Object* ob = ptr->id.data;
+	set_kinematic(rbo, value); //stupid casting but need only 1 function...
+	foreach_shard_int(ob, value, set_kinematic);
+}
+
+void set_activation(RigidBodyOb* rbo, int value)
+{	
 	RB_FLAG_SET(rbo->flag, value, RBO_FLAG_USE_DEACTIVATION);
 
 #ifdef WITH_BULLET
@@ -306,10 +454,16 @@
 #endif
 }
 
-static void rna_RigidBodyOb_linear_sleepThresh_set(PointerRNA *ptr, float value)
+static void rna_RigidBodyOb_activation_state_set(PointerRNA *ptr, int value)
 {
 	RigidBodyOb *rbo = (RigidBodyOb *)ptr->data;
-	
+	Object *ob = ptr->id.data;
+	set_activation(rbo, value);
+	foreach_shard_int(ob, value, set_activation);
+}
+
+void set_linear_sleepThresh(RigidBodyOb *rbo, float value)
+{	
 	rbo->lin_sleep_thresh = value;
 
 #ifdef WITH_BULLET
@@ -334,10 +488,16 @@
 #endif
 }
 
-static void rna_RigidBodyOb_linear_damping_set(PointerRNA *ptr, float value)
+static void rna_RigidBodyOb_angular_sleepThresh_set(PointerRNA *ptr, float value)
 {
 	RigidBodyOb *rbo = (RigidBodyOb *)ptr->data;
-	
+	Object *ob = ptr->id.data;
+	set_angular_sleepThresh(rbo, value);
+	foreach_shard_float(ob, value, set_angular_sleepThresh);
+}
+
+void set_linear_damping(RigidBodyOb *rbo, float value)
+{	
 	rbo->lin_damping = value;
 
 #ifdef WITH_BULLET
@@ -348,10 +508,16 @@
 #endif
 }
 
-static void rna_RigidBodyOb_angular_damping_set(PointerRNA *ptr, float value)
+static void rna_RigidBodyOb_linear_damping_set(PointerRNA *ptr, float value)
 {
 	RigidBodyOb *rbo = (RigidBodyOb *)ptr->data;
-	
+	Object *ob = ptr->id.data;
+	set_linear_damping(rbo, value);
+	foreach_shard_float(ob, value, set_linear_damping);
+}
+
+void set_angular_damping(RigidBodyOb *rbo, float value)
+{	
 	rbo->ang_damping = value;
 
 #ifdef WITH_BULLET
@@ -362,7 +528,15 @@
 #endif
 }
 
-static char *rna_RigidBodyCon_path(PointerRNA *UNUSED(ptr))
+static void rna_RigidBodyOb_angular_damping_set(PointerRNA *ptr, float value)
+{
+	RigidBodyOb *rbo = (RigidBodyOb *)ptr->data;
+	Object *ob = ptr->id.data;
+	set_angular_damping(rbo, value);
+	foreach_shard_float(ob, value, set_angular_damping);
+}
+
+static char *rna_RigidBodyCon_path(PointerRNA *ptr)
 {
 	/* NOTE: this hardcoded path should work as long as only Objects have this */
 	return BLI_sprintfN("rigid_body_constraint");
@@ -693,7 +867,7 @@
 	prop = RNA_def_property(srna, "steps_per_second", PROP_INT, PROP_NONE);
 	RNA_def_property_int_sdna(prop, NULL, "steps_per_second");
 	RNA_def_property_range(prop, 1, SHRT_MAX);
-	RNA_def_property_ui_range(prop, 60, 1000, 1, -1);
+	RNA_def_property_ui_range(prop, 60, 1000, 1, 0);
 	RNA_def_property_int_default(prop, 60);
 	RNA_def_property_ui_text(prop, "Steps Per Second",
 	                         "Number of simulation steps taken per second (higher values are more accurate "
@@ -704,7 +878,7 @@
 	prop = RNA_def_property(srna, "solver_iterations", PROP_INT, PROP_NONE);
 	RNA_def_property_int_sdna(prop, NULL, "num_solver_iterations");
 	RNA_def_property_range(prop, 1, 1000);
-	RNA_def_property_ui_range(prop, 10, 100, 1, -1);
+	RNA_def_property_ui_range(prop, 10, 100, 1, 0);
 	RNA_def_property_int_default(prop, 10);
 	RNA_def_property_int_funcs(prop, NULL, "rna_RigidBodyWorld_num_solver_iterations_set", NULL);
 	RNA_def_property_ui_text(prop, "Solver Iterations",
@@ -804,7 +978,6 @@
 	prop = RNA_def_property(srna, "collision_shape", PROP_ENUM, PROP_NONE);
 	RNA_def_property_enum_sdna(prop, NULL, "shape");
 	RNA_def_property_enum_items(prop, rigidbody_object_shape_items);
-	RNA_def_property_enum_funcs(prop, NULL, "rna_RigidBodyOb_shape_set", NULL);
 	RNA_def_property_ui_text(prop, "Collision Shape", "Collision Shape of object in Rigid Body Simulations");
 	RNA_def_property_clear_flag(prop, PROP_ANIMATABLE);
 	RNA_def_property_update(prop, NC_OBJECT | ND_POINTCACHE, "rna_RigidBodyOb_shape_update");
@@ -1007,7 +1180,7 @@
 	prop = RNA_def_property(srna, "solver_iterations", PROP_INT, PROP_NONE);
 	RNA_def_property_int_sdna(prop, NULL, "num_solver_iterations");
 	RNA_def_property_range(prop, 1, 1000);
-	RNA_def_property_ui_range(prop, 1, 100, 1, -1);
+	RNA_def_property_ui_range(prop, 1, 100, 1, 0);
 	RNA_def_property_int_default(prop, 10);
 	RNA_def_property_int_funcs(prop, NULL, "rna_RigidBodyCon_num_solver_iterations_set", NULL);
 	RNA_def_property_ui_text(prop, "Solver Iterations",
diff -ru --new-file blender-2.76b.old/source/blender/makesrna/RNA_access.h blender-2.76b/source/blender/makesrna/RNA_access.h
--- blender-2.76b.old/source/blender/makesrna/RNA_access.h	2015-11-02 16:25:38.000000000 +0300
+++ blender-2.76b/source/blender/makesrna/RNA_access.h	2016-01-27 21:50:01.657502265 +0300
@@ -250,6 +250,7 @@
 extern StructRNA RNA_FluidSettings;
 extern StructRNA RNA_FluidSimulationModifier;
 extern StructRNA RNA_FollowPathConstraint;
+extern StructRNA RNA_FractureModifier;
 extern StructRNA RNA_FreestyleLineStyle;
 extern StructRNA RNA_FreestyleLineSet;
 extern StructRNA RNA_FreestyleModuleSettings;
diff -ru --new-file blender-2.76b.old/source/blender/modifiers/CMakeLists.txt blender-2.76b/source/blender/modifiers/CMakeLists.txt
--- blender-2.76b.old/source/blender/modifiers/CMakeLists.txt	2016-01-27 18:39:43.683007892 +0300
+++ blender-2.76b/source/blender/modifiers/CMakeLists.txt	2016-01-27 22:12:05.903011801 +0300
@@ -62,6 +62,7 @@
 	intern/MOD_explode.c
 	intern/MOD_fluidsim.c
 	intern/MOD_fluidsim_util.c
+	intern/MOD_fracture.c
 	intern/MOD_hook.c
 	intern/MOD_laplaciandeform.c
 	intern/MOD_laplaciansmooth.c
diff -ru --new-file blender-2.76b.old/source/blender/modifiers/intern/MOD_boolean_util.c blender-2.76b/source/blender/modifiers/intern/MOD_boolean_util.c
--- blender-2.76b.old/source/blender/modifiers/intern/MOD_boolean_util.c	2015-10-30 23:31:41.000000000 +0300
+++ blender-2.76b/source/blender/modifiers/intern/MOD_boolean_util.c	2016-01-27 22:25:29.359293488 +0300
@@ -65,6 +65,7 @@
 {
 	float (*cos_3d)[3] = BLI_array_alloca(cos_3d, source_poly->totloop);
 	int *source_indices = BLI_array_alloca(source_indices, source_poly->totloop);
+	int *source_vert_indices = BLI_array_alloca(source_vert_indices, source_poly->totloop);
 	float *weights = BLI_array_alloca(weights, source_poly->totloop);
 	int i;
 	int target_vert_index = target_mloop[target_loop_index].v;
@@ -74,6 +75,7 @@
 		MLoop *mloop = &source_mloops[source_poly->loopstart + i];
 		source_indices[i] = source_poly->loopstart + i;
 		copy_v3_v3(cos_3d[i], source_mverts[mloop->v].co);
+		source_vert_indices[i] = mloop->v;
 	}
 
 	if (transform) {
@@ -87,6 +89,10 @@
 
 	DM_interp_loop_data(source_dm, target_dm, source_indices, weights,
 	                    source_poly->totloop, target_loop_index);
+
+	/* interpolate vertex data as well, for painted weights interpolation on fracture modifier */
+	DM_interp_vert_data(source_dm, target_dm, source_vert_indices ,weights,
+	                    source_poly->totloop, target_vert_index);	
 }
 
 typedef struct DMArrays {
@@ -384,11 +390,14 @@
 	export_data->mloop = dm->getLoopArray(dm);
 	export_data->mpoly = dm->getPolyArray(dm);
 
+
 	/* Merge custom data layers from operands.
 	 *
 	 * Will only create custom data layers for all the layers which appears in
 	 * the operand. Data for those layers will not be allocated or initialized.
 	 */
+	CustomData_merge(&dm_left->vertData, &dm->vertData, merge_mask, CD_DEFAULT, num_verts);
+	CustomData_merge(&dm_right->vertData, &dm->vertData, merge_mask, CD_DEFAULT, num_verts);
 
 	CustomData_merge(&dm_left->loopData, &dm->loopData, merge_mask, CD_DEFAULT, num_loops);
 	CustomData_merge(&dm_right->loopData, &dm->loopData, merge_mask, CD_DEFAULT, num_loops);
diff -ru --new-file blender-2.76b.old/source/blender/modifiers/intern/MOD_fracture.c blender-2.76b/source/blender/modifiers/intern/MOD_fracture.c
--- blender-2.76b.old/source/blender/modifiers/intern/MOD_fracture.c	1970-01-01 03:00:00.000000000 +0300
+++ blender-2.76b/source/blender/modifiers/intern/MOD_fracture.c	2016-01-27 22:27:06.715604501 +0300
@@ -0,0 +1,2604 @@
+/*
+ * ***** BEGIN GPL LICENSE BLOCK *****
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software  Foundation,
+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
+ *
+ * The Original Code is Copyright (C) Blender Foundation
+ * All rights reserved.
+ *
+ * The Original Code is: all of this file.
+ *
+ * Contributor(s): Martin Felke
+ *
+ * ***** END GPL LICENSE BLOCK *****
+ */
+
+/** \file blender/modifiers/intern/MOD_fracture.c
+ *  \ingroup modifiers
+ */
+
+//#include "BLI_string_utf8.h"
+#include "MEM_guardedalloc.h"
+
+#include "BLI_edgehash.h"
+#include "BLI_ghash.h"
+#include "BLI_kdtree.h"
+#include "BLI_listbase.h"
+#include "BLI_math.h"
+#include "BLI_math_matrix.h"
+#include "BLI_math_vector.h"
+#include "BLI_rand.h"
+#include "BLI_utildefines.h"
+
+
+#include "BKE_cdderivedmesh.h"
+#include "BKE_deform.h"
+#include "BKE_depsgraph.h"
+#include "BKE_fracture.h"
+#include "BKE_global.h"
+#include "BKE_group.h"
+#include "BKE_library.h"
+#include "BKE_main.h"
+#include "BKE_material.h"
+#include "BKE_modifier.h"
+#include "BKE_object.h"
+#include "BKE_particle.h"
+#include "BKE_pointcache.h"
+#include "BKE_rigidbody.h"
+#include "BKE_scene.h"
+
+#include "bmesh.h"
+
+#include "DNA_fracture_types.h"
+#include "DNA_gpencil_types.h"
+#include "DNA_group_types.h"
+#include "DNA_listBase.h"
+#include "DNA_material_types.h"
+#include "DNA_object_types.h"
+#include "DNA_particle_types.h"
+#include "DNA_rigidbody_types.h"
+#include "DNA_scene_types.h"
+
+#include "MOD_util.h"
+
+#include "../../rigidbody/RBI_api.h"
+#include "PIL_time.h"
+#include "../../bmesh/tools/bmesh_decimate.h" /* decimate_dissolve function */
+#include "depsgraph_private.h" /* for depgraph updates */
+
+static void fill_vgroup(FractureModifierData *rmd, DerivedMesh *dm, MDeformVert *dvert, Object *ob);
+static int getGroupObjects(Group *gr, Object ***obs, int g_exist);
+static void do_fracture(FractureModifierData *fracmd, ShardID id, Object *obj, DerivedMesh *dm);
+void freeMeshIsland(FractureModifierData *rmd, MeshIsland *mi, bool remove_rigidbody);
+DerivedMesh *doSimulate(FractureModifierData *fmd, Object *ob, DerivedMesh *dm, DerivedMesh *orig_dm);
+void refresh_customdata_image(Mesh *me, CustomData *pdata, int totface);
+
+static void initData(ModifierData *md)
+{
+	FractureModifierData *fmd = (FractureModifierData *) md;
+
+	fmd->cluster_count = 0;
+	fmd->extra_group = NULL;
+	fmd->frac_algorithm = MOD_FRACTURE_BOOLEAN;
+	fmd->point_source = MOD_FRACTURE_UNIFORM;
+	fmd->shard_id = -1;
+	fmd->shard_count = 10;
+	fmd->percentage = 100;;
+
+	fmd->visible_mesh = NULL;
+	fmd->visible_mesh_cached = NULL;
+	fmd->refresh = false;
+	zero_m4(fmd->origmat);
+	fmd->breaking_threshold = 10.0f;
+	fmd->use_constraints = false;
+	fmd->contact_dist = 1.0f;
+	fmd->use_mass_dependent_thresholds = false;
+	fmd->explo_shared = false;
+	fmd->constraint_limit = 0;
+	fmd->breaking_distance = 0;
+	fmd->breaking_angle = 0;
+	fmd->breaking_percentage = 0;     /* disable by default*/
+	fmd->max_vol = 0;
+	fmd->refresh_constraints = false;
+
+	fmd->cluster_breaking_threshold = 1000.0f;
+	fmd->solver_iterations_override = 0;
+	fmd->shards_to_islands = false;
+	fmd->execute_threaded = false;
+	fmd->nor_tree = NULL;
+	fmd->fix_normals = false;
+	fmd->auto_execute = false;
+	fmd->face_pairs = NULL;
+	fmd->autohide_dist = 0.0f;
+
+	fmd->breaking_percentage_weighted = false;
+	fmd->breaking_angle_weighted = false;
+	fmd->breaking_distance_weighted = false;
+
+	/* XXX needed because of messy particle cache, shows incorrect positions when start/end on frame 1
+	 * default use case is with this flag being enabled, disable at own risk */
+	fmd->use_particle_birth_coordinates = true;
+}
+
+static void freeData(ModifierData *md)
+{
+	FractureModifierData *rmd = (FractureModifierData *) md;
+	MeshIsland *mi;
+	RigidBodyShardCon *rbsc;
+	
+	if ((!rmd->refresh && !rmd->refresh_constraints) || (rmd->frac_mesh && rmd->frac_mesh->cancel == 1)) {
+		if (rmd->nor_tree != NULL) {
+			BLI_kdtree_free(rmd->nor_tree);
+			rmd->nor_tree = NULL;
+		}
+
+		if (rmd->face_pairs != NULL) {
+			BLI_ghash_free(rmd->face_pairs, NULL, NULL);
+			rmd->face_pairs = NULL;
+		}
+
+		//called on deleting modifier, object or quitting blender...
+		if (rmd->dm) {
+			rmd->dm->needsFree = 1;
+			rmd->dm->release(rmd->dm);
+			rmd->dm = NULL;
+		}
+
+		if (rmd->visible_mesh_cached) {
+			rmd->visible_mesh_cached->needsFree = 1;
+			rmd->visible_mesh_cached->release(rmd->visible_mesh_cached);
+			rmd->visible_mesh_cached = NULL;
+		}
+
+		if (rmd->frac_mesh) {
+			BKE_fracmesh_free(rmd->frac_mesh, true);
+			MEM_freeN(rmd->frac_mesh);
+			rmd->frac_mesh = NULL;
+		}
+
+		if (rmd->visible_mesh != NULL) {
+			BM_mesh_free(rmd->visible_mesh);
+			rmd->visible_mesh = NULL;
+		}
+
+		while (rmd->meshIslands.first) {
+			mi = rmd->meshIslands.first;
+			BLI_remlink(&rmd->meshIslands, mi);
+			freeMeshIsland(rmd, mi, false);
+			mi = NULL;
+		}
+
+		rmd->meshIslands.first = NULL;
+		rmd->meshIslands.last = NULL;
+
+		{
+			while (rmd->islandShards.first) {
+				Shard *s = rmd->islandShards.first;
+				BLI_remlink(&rmd->islandShards, s);
+				BKE_shard_free(s, true);
+				s = NULL;
+			}
+
+			rmd->islandShards.first = NULL;
+			rmd->islandShards.last = NULL;
+		}
+	}
+
+	if (rmd->visible_mesh_cached && !rmd->shards_to_islands &&
+	    ((!rmd->refresh && !rmd->refresh_constraints)))
+	{
+		rmd->visible_mesh_cached->needsFree = 1;
+		rmd->visible_mesh_cached->release(rmd->visible_mesh_cached);
+		rmd->visible_mesh_cached = NULL;
+	}
+
+	/* refreshing all simulation data, no refracture */
+	if (!rmd->refresh_constraints) {
+		if (rmd->shards_to_islands) {
+			while (rmd->islandShards.first) {
+				Shard *s = rmd->islandShards.first;
+				BLI_remlink(&rmd->islandShards, s);
+				BKE_shard_free(s, true);
+				s = NULL;
+			}
+
+			rmd->islandShards.first = NULL;
+			rmd->islandShards.last = NULL;
+		}
+
+		/* when freeing meshislands, we MUST get rid of constraints before too !!!! */
+		for (mi = rmd->meshIslands.first; mi; mi = mi->next) {
+			if (mi->participating_constraints != NULL) {
+				MEM_freeN(mi->participating_constraints);
+				mi->participating_constraints = NULL;
+				mi->participating_constraint_count = 0;
+			}
+		}
+
+		while (rmd->meshConstraints.first) {
+			rbsc = rmd->meshConstraints.first;
+			BLI_remlink(&rmd->meshConstraints, rbsc);
+			MEM_freeN(rbsc);
+			rbsc = NULL;
+		}
+
+		rmd->meshConstraints.first = NULL;
+		rmd->meshConstraints.last = NULL;
+
+		while (rmd->meshIslands.first) {
+			mi = rmd->meshIslands.first;
+			BLI_remlink(&rmd->meshIslands, mi);
+			freeMeshIsland(rmd, mi, true);
+			mi = NULL;
+		}
+
+		rmd->meshIslands.first = NULL;
+		rmd->meshIslands.last = NULL;
+
+		if (!rmd->explo_shared) {
+			if (rmd->visible_mesh != NULL)
+			{
+				BM_mesh_free(rmd->visible_mesh);
+				rmd->visible_mesh = NULL;
+			}
+		}
+	}
+
+	/* refresh constraints case */
+	if ((!rmd->refresh && !rmd->refresh_constraints) || (rmd->frac_mesh && rmd->frac_mesh->cancel == 1) ||
+	    rmd->refresh_constraints)
+	{
+		for (mi = rmd->meshIslands.first; mi; mi = mi->next) {
+			if (mi->participating_constraints != NULL) {
+				MEM_freeN(mi->participating_constraints);
+				mi->participating_constraints = NULL;
+				mi->participating_constraint_count = 0;
+			}
+		}
+
+		while (rmd->meshConstraints.first) {
+			rbsc = rmd->meshConstraints.first;
+			BLI_remlink(&rmd->meshConstraints, rbsc);
+			MEM_freeN(rbsc);
+			rbsc = NULL;
+		}
+
+		rmd->meshConstraints.first = NULL;
+		rmd->meshConstraints.last = NULL;
+	}
+}
+
+static void growCluster(FractureModifierData *fmd, Shard *seed, int sindex, ListBase *lbVisit, KDTree *tree, int depth)
+{
+	int i = 0, count = 0;
+	float size = 0.1f;
+	KDTreeNearest *nearest;
+
+	count = BLI_kdtree_range_search(tree, seed->centroid, &nearest, size * depth);
+	for (i = 0; i < count; i++) {
+		Shard *neighbor;
+		int index = nearest[i].index;
+		neighbor = (Shard *)BLI_findlink(&fmd->frac_mesh->shard_map, index);
+		if (neighbor->cluster_colors[0] == -1) {
+			neighbor->cluster_colors[0] = sindex;
+		}
+
+		if (BLI_findindex(lbVisit, seed) == -1) {
+			BLI_addtail(lbVisit, seed);
+		}
+	}
+	MEM_freeN(nearest);
+}
+
+static void doClusters(FractureModifierData *fmd, int levels)
+{
+	/*grow clusters from all shards */
+	ListBase lbVisit;
+	int i = 0, j = 0, k = 0, sindex = 0, counter = 0, depth = 1;
+	KDTree *tree = BLI_kdtree_new(fmd->frac_mesh->shard_count);
+
+
+	lbVisit.first = NULL;
+	lbVisit.last = NULL;
+
+	for (j = 0; j < levels; j++) {
+		Shard **seeds, *s;
+		int seed_count;
+		/*prepare shard as list*/
+		for (s = fmd->frac_mesh->shard_map.first; s; s = s->next) {
+			s->cluster_colors = MEM_mallocN(sizeof(int) * levels, "cluster_colors");
+			for (k = 0; k < levels; k++)
+			{
+				s->cluster_colors[k] = -1;
+			}
+
+			BLI_kdtree_insert(tree, i, s->centroid);
+		}
+
+		if (fmd->cluster_count < 2) {
+			BLI_kdtree_free(tree);
+			return;
+		}
+
+		BLI_kdtree_balance(tree);
+
+		seed_count = (fmd->cluster_count > fmd->frac_mesh->shard_count ? fmd->frac_mesh->shard_count : fmd->cluster_count);
+		seeds = MEM_mallocN(sizeof(Shard *) * seed_count, "seeds");
+
+		for (k = 0; k < seed_count; k++) {
+			int color = k;
+			int which_index = k * (int)(fmd->frac_mesh->shard_count / seed_count);
+			Shard *which = (Shard *)BLI_findlink(&fmd->frac_mesh->shard_map, which_index);
+			which->cluster_colors[j] = color;
+			BLI_addtail(&lbVisit, which);
+			seeds[k] = which;
+		}
+
+		while (BLI_countlist(&lbVisit) < fmd->frac_mesh->shard_count) {
+			Shard *seed;
+
+			if (sindex == seed_count)
+			{
+				sindex = 0;
+				depth++;
+			}
+
+			seed = seeds[sindex];
+			growCluster(fmd, seed, sindex, &lbVisit, tree, depth);
+			sindex++;
+
+			if (counter == 10000) {
+				/*XXX emergency stop... otherwise loop might run eternally */
+				break;
+			}
+
+			counter++;
+		}
+
+		BLI_kdtree_free(tree);
+		MEM_freeN(seeds);
+	}
+}
+
+static KDTree *build_nor_tree(DerivedMesh *dm)
+{
+	int i = 0, totvert = dm->getNumVerts(dm);
+	KDTree *tree = BLI_kdtree_new(totvert);
+	MVert *mv, *mvert = dm->getVertArray(dm);
+
+	for (i = 0, mv = mvert; i < totvert; i++, mv++) {
+		BLI_kdtree_insert(tree, i, mv->co);
+	}
+
+	BLI_kdtree_balance(tree);
+
+	return tree;
+}
+
+static void find_normal(DerivedMesh *dm, KDTree *tree, float co[3], short no[3])
+{
+	KDTreeNearest n;
+	int index = 0;
+	MVert mvert;
+
+	index = BLI_kdtree_find_nearest(tree, co, &n);
+
+	dm->getVert(dm, index, &mvert);
+
+	copy_v3_v3_short(no, mvert.no);
+}
+
+static DerivedMesh *get_clean_dm(Object *ob, DerivedMesh *dm)
+{
+	/* may have messed up meshes from conversion */
+	if (ob->type == OB_FONT || ob->type == OB_CURVE || ob->type == OB_SURF) {
+		DerivedMesh *result = NULL;
+
+		/* convert to BMesh, remove doubles, limited dissolve and convert back */
+		BMesh *bm = DM_to_bmesh(dm, true);
+
+		BMO_op_callf(bm, (BMO_FLAG_DEFAULTS & ~BMO_FLAG_RESPECT_HIDE),
+		             "remove_doubles verts=%av dist=%f", BM_VERTS_OF_MESH, 0.0001, false);
+
+		BM_mesh_decimate_dissolve(bm, 0.087f, false, 0);
+		result = CDDM_from_bmesh(bm, true);
+		BM_mesh_free(bm);
+
+		return result;
+	}
+
+	return dm;
+}
+
+static DerivedMesh *get_group_dm(FractureModifierData *fmd, DerivedMesh *dm)
+{
+	/* combine derived meshes from group objects into 1, trigger submodifiers if ob->derivedFinal is empty */
+	int totgroup = 0, i = 0;
+	int num_verts = 0, num_polys = 0, num_loops = 0;
+	int vertstart = 0, polystart = 0, loopstart = 0;
+	DerivedMesh *result;
+	MVert *mverts;
+	MPoly *mpolys;
+	MLoop *mloops;
+
+	Object **go = MEM_mallocN(sizeof(Object *), "groupdmobjects");
+	totgroup = getGroupObjects(fmd->dm_group, &go, totgroup);
+
+	if (totgroup > 0 && (fmd->refresh == true || fmd->auto_execute == true))
+	{
+		DerivedMesh *dm_ob = NULL;
+		for (i = 0; i < totgroup; i++)
+		{
+			Object *o = go[i];
+			dm_ob = o->derivedFinal;
+			if (dm_ob == NULL) continue;
+
+			num_verts += dm_ob->getNumVerts(dm_ob);
+			num_polys += dm_ob->getNumPolys(dm_ob);
+			num_loops += dm_ob->getNumLoops(dm_ob);
+		}
+
+		if (num_verts == 0)
+		{
+			return dm;
+		}
+
+		result = CDDM_new(num_verts, 0, 0, num_loops, num_polys);
+		mverts = CDDM_get_verts(result);
+		mloops = CDDM_get_loops(result);
+		mpolys = CDDM_get_polys(result);
+
+		/* XXX doesnt work, see below (customData copy).... but is needed for textures and weightpaints */
+		/*CustomData_add_layer(&result->vertData, CD_MDEFORMVERT, CD_CALLOC, NULL, num_verts);
+		CustomData_add_layer(&result->loopData, CD_MLOOPUV, CD_CALLOC, NULL, num_loops);
+		CustomData_add_layer(&result->polyData, CD_MTEXPOLY, CD_CALLOC, NULL, num_polys);*/
+
+		vertstart = polystart = loopstart = 0;
+		for (i = 0; i < totgroup; i++)
+		{
+			MPoly *mp;
+			MLoop *ml;
+			int j, v;
+			MVert *mv;
+
+			Object *o = go[i];
+			dm_ob = o->derivedFinal; /* not very reliable... hmm */
+
+			if (dm_ob == NULL)
+			{   /* avoid crash atleast...*/
+				return dm;
+			}
+
+			memcpy(mverts + vertstart, dm_ob->getVertArray(dm_ob), dm_ob->getNumVerts(dm_ob) * sizeof(MVert));
+			memcpy(mpolys + polystart, dm_ob->getPolyArray(dm_ob), dm_ob->getNumPolys(dm_ob) * sizeof(MPoly));
+
+
+			for (j = 0, mp = mpolys + polystart; j < dm_ob->getNumPolys(dm_ob); ++j, ++mp) {
+				/* adjust loopstart index */
+				mp->loopstart += loopstart;
+			}
+
+			memcpy(mloops + loopstart, dm_ob->getLoopArray(dm_ob), dm_ob->getNumLoops(dm_ob) * sizeof(MLoop));
+
+			for (j = 0, ml = mloops + loopstart; j < dm_ob->getNumLoops(dm_ob); ++j, ++ml) {
+				/* adjust vertex index */
+				ml->v += vertstart;
+			}
+
+			/* XXX doesnt work for moving verts to appropriate object locations... WHY ?
+			 * .... but is needed for textures and weightpaints */
+			/*CustomData_copy_data(&dm_ob->vertData, &result->vertData, 0, vertstart, dm_ob->getNumVerts(dm_ob));
+			CustomData_copy_data(&dm_ob->loopData, &result->loopData, 0, loopstart, dm_ob->getNumLoops(dm_ob));
+			CustomData_copy_data(&dm_ob->polyData, &result->polyData, 0, polystart, dm_ob->getNumPolys(dm_ob));*/
+
+			for (v = 0, mv = mverts + vertstart; v < dm_ob->getNumVerts(dm_ob); v++, mv++)
+			{
+				mul_m4_v3(o->obmat, mv->co);
+				//CustomData_set(&result->vertData, vertstart + v, CD_MVERT, mv);
+			}
+
+			vertstart += dm_ob->getNumVerts(dm_ob);
+			polystart += dm_ob->getNumPolys(dm_ob);
+			loopstart += dm_ob->getNumLoops(dm_ob);
+		}
+
+		CDDM_calc_edges(result);
+
+		result->dirty |= DM_DIRTY_NORMALS;
+		CDDM_calc_normals_mapping(result);
+		MEM_freeN(go);
+		return result;
+	}
+
+	MEM_freeN(go);
+	return dm;
+}
+
+
+static DerivedMesh *applyModifier(ModifierData *md, Object *ob,
+                                  DerivedMesh *derivedData,
+                                  ModifierApplyFlag UNUSED(flag))
+{
+
+	FractureModifierData *fmd = (FractureModifierData *) md;
+	DerivedMesh *final_dm = derivedData;
+
+	DerivedMesh *group_dm = get_group_dm(fmd, derivedData);
+	DerivedMesh *clean_dm = get_clean_dm(ob, group_dm);
+
+	/* disable that automatically if sim is started, but must be re-enabled manually */
+	if (BKE_rigidbody_check_sim_running(md->scene->rigidbody_world, BKE_scene_frame_get(md->scene))) {
+		fmd->auto_execute = false;
+	}
+
+	if (fmd->auto_execute) {
+		fmd->refresh = true;
+	}
+
+	if (fmd->frac_mesh != NULL && fmd->frac_mesh->running == 1 && fmd->execute_threaded) {
+		/* skip modifier execution when fracture job is running */
+		return final_dm;
+	}
+
+	if (fmd->refresh)
+	{
+		if (fmd->dm != NULL) {
+			fmd->dm->needsFree = 1;
+			fmd->dm->release(fmd->dm);
+			fmd->dm = NULL;
+		}
+
+		if (fmd->frac_mesh != NULL) {
+			BKE_fracmesh_free(fmd->frac_mesh, true);
+			MEM_freeN(fmd->frac_mesh);
+			fmd->frac_mesh = NULL;
+		}
+
+		if (fmd->frac_mesh == NULL) {
+			fmd->frac_mesh = BKE_create_fracture_container();
+			if (fmd->execute_threaded)
+			{
+				fmd->frac_mesh->running = 1;
+			}
+		}
+	}
+
+	{
+		if (fmd->refresh) {
+			/* build normaltree from origdm */
+			if (fmd->nor_tree != NULL) {
+				BLI_kdtree_free(fmd->nor_tree);
+				fmd->nor_tree = NULL;
+			}
+
+			fmd->nor_tree = build_nor_tree(clean_dm);
+			if (fmd->face_pairs != NULL) {
+				BLI_ghash_free(fmd->face_pairs, NULL, NULL);
+				fmd->face_pairs = NULL;
+			}
+
+			fmd->face_pairs = BLI_ghash_int_new("face_pairs");
+
+			do_fracture(fmd, -1, ob, clean_dm);
+
+			if (!fmd->refresh) { /* might have been changed from outside, job cancel*/
+				return derivedData;
+			}
+		}
+		if (fmd->dm && fmd->frac_mesh && (fmd->dm->getNumPolys(fmd->dm) > 0) && (fmd->dm_group == NULL)) {
+			final_dm = doSimulate(fmd, ob, fmd->dm, clean_dm);
+		}
+		else {
+			final_dm = doSimulate(fmd, ob, clean_dm, clean_dm);
+		}
+	}
+
+	/* free newly created derivedmeshes only, but keep derivedData and final_dm*/
+	if ((clean_dm != group_dm) && (clean_dm != derivedData) && (clean_dm != final_dm))
+	{
+		clean_dm->needsFree = 1;
+		clean_dm->release(clean_dm);
+	}
+
+	if ((group_dm != derivedData) && (group_dm != final_dm))
+	{
+		group_dm->needsFree = 1;
+		group_dm->release(group_dm);
+	}
+
+	return final_dm;
+}
+
+static DerivedMesh *applyModifierEM(ModifierData *md, Object *ob,
+                                    struct BMEditMesh *UNUSED(editData),
+                                    DerivedMesh *derivedData,
+                                    ModifierApplyFlag UNUSED(flag))
+{
+	FractureModifierData *fmd = (FractureModifierData *) md;
+	DerivedMesh *final_dm = derivedData;
+
+	DerivedMesh *group_dm = get_group_dm(fmd, derivedData);
+	DerivedMesh *clean_dm = get_clean_dm(ob, group_dm);
+
+	if (BKE_rigidbody_check_sim_running(md->scene->rigidbody_world, BKE_scene_frame_get(md->scene))) {
+		fmd->auto_execute = false;
+	}
+
+	if (fmd->auto_execute) {
+		fmd->refresh = true;
+	}
+
+	if (fmd->frac_mesh != NULL && fmd->frac_mesh->running == 1 && fmd->execute_threaded)
+	{
+		/* skip modifier execution when fracture job is running */
+		return final_dm;
+	}
+
+	if (fmd->refresh) {
+		if (fmd->dm != NULL) {
+			fmd->dm->needsFree = 1;
+			fmd->dm->release(fmd->dm);
+			fmd->dm = NULL;
+		}
+
+		if (fmd->frac_mesh != NULL) {
+			BKE_fracmesh_free(fmd->frac_mesh, true /*fmd->frac_algorithm != MOD_FRACTURE_VORONOI*/);
+			MEM_freeN(fmd->frac_mesh);
+			fmd->frac_mesh = NULL;
+		}
+
+		if (fmd->frac_mesh == NULL) {
+			fmd->frac_mesh = BKE_create_fracture_container();
+			if (fmd->execute_threaded) {
+				fmd->frac_mesh->running = 1;
+			}
+		}
+	}
+
+	{
+		if (fmd->refresh) {
+			/* build normaltree from origdm */
+			if (fmd->nor_tree != NULL) {
+				BLI_kdtree_free(fmd->nor_tree);
+				fmd->nor_tree = NULL;
+			}
+
+			fmd->nor_tree = build_nor_tree(clean_dm);
+			if (fmd->face_pairs != NULL) {
+				BLI_ghash_free(fmd->face_pairs, NULL, NULL);
+				fmd->face_pairs = NULL;
+			}
+
+			fmd->face_pairs = BLI_ghash_int_new("face_pairs");
+
+			do_fracture(fmd, -1, ob, clean_dm);
+
+			if (!fmd->refresh) { /*might have been changed from outside, job cancel*/
+				return derivedData;
+			}
+		}
+
+		if (fmd->dm && fmd->frac_mesh && (fmd->dm->getNumPolys(fmd->dm) > 0) && (fmd->dm_group == NULL)) {
+			final_dm = doSimulate(fmd, ob, fmd->dm, clean_dm);
+		}
+		else {
+			final_dm = doSimulate(fmd, ob, clean_dm, clean_dm);
+		}
+	}
+
+	/* free newly created derivedmeshes only, but keep derivedData and final_dm*/
+	if ((clean_dm != group_dm) && (clean_dm != derivedData) && (clean_dm != final_dm))
+	{
+		clean_dm->needsFree = 1;
+		clean_dm->release(clean_dm);
+	}
+
+	if ((group_dm != derivedData) && (group_dm != final_dm))
+	{
+		group_dm->needsFree = 1;
+		group_dm->release(group_dm);
+	}
+
+	return final_dm;
+}
+
+static void points_from_verts(Object **ob, int totobj, FracPointCloud *points, float mat[4][4], float thresh, FractureModifierData *emd, DerivedMesh *dm, Object *obj)
+{
+	int v, o, pt = points->totpoints;
+	float co[3];
+
+	for (o = 0; o < totobj; o++) {
+		if (ob[o]->type == OB_MESH) {
+			/* works for mesh objects only, curves, surfaces, texts have no verts */
+			float imat[4][4];
+			DerivedMesh *d;
+			MVert *vert;
+
+			if (ob[o] == obj) {
+				/* same object, use given derivedmesh */
+				d = dm;
+			}
+			else {
+				d = mesh_get_derived_final(emd->modifier.scene, ob[o], 0);
+			}
+
+			invert_m4_m4(imat, mat);
+			vert = d->getVertArray(d);
+
+			for (v = 0; v < d->getNumVerts(d); v++) {
+				if (BLI_frand() < thresh) {
+					points->points = MEM_reallocN((*points).points, (pt + 1) * sizeof(FracPoint));
+
+					copy_v3_v3(co, vert[v].co);
+
+
+					if (emd->point_source & MOD_FRACTURE_EXTRA_VERTS) {
+						mul_m4_v3(ob[o]->obmat, co);
+					}
+
+					mul_m4_v3(imat, co);
+
+					copy_v3_v3(points->points[pt].co, co);
+					pt++;
+				}
+			}
+		}
+	}
+
+	points->totpoints = pt;
+}
+
+static void points_from_particles(Object **ob, int totobj, Scene *scene, FracPointCloud *points, float mat[4][4],
+                                  float thresh, FractureModifierData *fmd)
+{
+	int o, p, pt = points->totpoints;
+	ParticleSystemModifierData *psmd;
+	ParticleData *pa;
+	ParticleSimulationData sim = {NULL};
+	ParticleKey birth;
+	ModifierData *mod;
+
+	for (o = 0; o < totobj; o++) {
+		for (mod = ob[o]->modifiers.first; mod; mod = mod->next) {
+			if (mod->type == eModifierType_ParticleSystem) {
+				float imat[4][4];
+				psmd = (ParticleSystemModifierData *)mod;
+				sim.scene = scene;
+				sim.ob = ob[o];
+				sim.psys = psmd->psys;
+				sim.psmd = psmd;
+				invert_m4_m4(imat, mat);
+
+				for (p = 0, pa = psmd->psys->particles; p < psmd->psys->totpart; p++, pa++) {
+					/* XXX was previously there to choose a particle with a certain state */
+					bool particle_unborn = pa->alive == PARS_UNBORN;
+					bool particle_alive = pa->alive == PARS_ALIVE;
+					bool particle_dead = pa->alive == PARS_DEAD;
+					bool particle_mask = particle_unborn || particle_alive || particle_dead;
+
+					if ((BLI_frand() < thresh) && particle_mask) {
+						float co[3];
+
+						/* birth coordinates are not sufficient in case we did pre-simulate the particles, so they are not
+						 * aligned with the emitter any more BUT as the particle cache is messy and shows initially wrong
+						 * positions "sabotaging" fracture, default use case is using birth coordinates, let user decide... */
+						if (fmd->use_particle_birth_coordinates)
+						{
+							psys_get_birth_coordinates(&sim, pa, &birth, 0, 0);
+						}
+						else {
+							psys_get_particle_state(&sim, p, &birth, 1);
+						}
+
+						points->points = MEM_reallocN(points->points, (pt + 1) * sizeof(FracPoint));
+						copy_v3_v3(co, birth.co);
+
+
+						mul_m4_v3(imat, co);
+
+						copy_v3_v3(points->points[pt].co, co);
+						pt++;
+					}
+				}
+			}
+		}
+	}
+
+	points->totpoints = pt;
+}
+
+static void points_from_greasepencil(Object **ob, int totobj, FracPointCloud *points, float mat[4][4], float thresh)
+{
+	bGPDlayer *gpl;
+	bGPDframe *gpf;
+	bGPDstroke *gps;
+	int pt = points->totpoints, p, o;
+
+	for (o = 0; o < totobj; o++) {
+		if ((ob[o]->gpd) && (ob[o]->gpd->layers.first)) {
+			float imat[4][4];
+			invert_m4_m4(imat, mat);
+			for (gpl = ob[o]->gpd->layers.first; gpl; gpl = gpl->next) {
+				for (gpf = gpl->frames.first; gpf; gpf = gpf->next) {
+					for (gps = gpf->strokes.first; gps; gps = gps->next) {
+						for (p = 0; p < gps->totpoints; p++) {
+							if (BLI_frand() < thresh) {
+								float point[3] = {0, 0, 0};
+								points->points = MEM_reallocN(points->points, (pt + 1) * sizeof(FracPoint));
+
+								point[0] = gps->points[p].x;
+								point[1] = gps->points[p].y;
+								point[2] = gps->points[p].z;
+
+								mul_m4_v3(imat, point);
+
+								copy_v3_v3(points->points[pt].co, point);
+								pt++;
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+
+	points->totpoints = pt;
+}
+
+static int getGroupObjects(Group *gr, Object ***obs, int g_exist)
+{
+	int ctr = g_exist;
+	GroupObject *go;
+	if (gr == NULL) return ctr;
+
+	for (go = gr->gobject.first; go; go = go->next) {
+
+		*obs = MEM_reallocN(*obs, sizeof(Object *) * (ctr + 1));
+		(*obs)[ctr] = go->ob;
+		ctr++;
+	}
+
+	return ctr;
+}
+
+static FracPointCloud get_points_global(FractureModifierData *emd, Object *ob, DerivedMesh *fracmesh)
+{
+	Scene *scene = emd->modifier.scene;
+	FracPointCloud points;
+
+	/* global settings, for first fracture only, or global secondary and so on fracture, apply to entire fracmesh */
+	int totgroup = 0;
+	Object **go = MEM_mallocN(sizeof(Object *), "groupobjects");
+	float thresh = (float)emd->percentage / 100.0f;
+	float min[3], max[3];
+	int i;
+
+	points.points = MEM_mallocN(sizeof(FracPoint), "points");
+	points.totpoints = 0;
+
+	if (emd->point_source & (MOD_FRACTURE_EXTRA_PARTICLES | MOD_FRACTURE_EXTRA_VERTS)) {
+		if (((emd->point_source & MOD_FRACTURE_OWN_PARTICLES) && (emd->point_source & MOD_FRACTURE_EXTRA_PARTICLES)) ||
+		    ((emd->point_source & MOD_FRACTURE_OWN_VERTS) && (emd->point_source & MOD_FRACTURE_EXTRA_VERTS)) ||
+		    ((emd->point_source & MOD_FRACTURE_GREASEPENCIL) && (emd->point_source & MOD_FRACTURE_EXTRA_PARTICLES)) ||
+		    ((emd->point_source & MOD_FRACTURE_GREASEPENCIL) && (emd->point_source & MOD_FRACTURE_EXTRA_VERTS)))
+		{
+			go = MEM_reallocN(go, sizeof(Object *) * (totgroup + 1));
+			go[totgroup] = ob;
+			totgroup++;
+		}
+
+		totgroup = getGroupObjects(emd->extra_group, &go, totgroup);
+	}
+	else {
+		totgroup = 1;
+		go[0] = ob;
+	}
+
+	if (emd->point_source & (MOD_FRACTURE_OWN_PARTICLES | MOD_FRACTURE_EXTRA_PARTICLES)) {
+		points_from_particles(go, totgroup, scene, &points, ob->obmat, thresh, emd);
+	}
+
+	if (emd->point_source & (MOD_FRACTURE_OWN_VERTS | MOD_FRACTURE_EXTRA_VERTS)) {
+		points_from_verts(go, totgroup, &points, ob->obmat, thresh, emd, fracmesh, ob);
+	}
+
+	if (emd->point_source & MOD_FRACTURE_GREASEPENCIL) {
+		points_from_greasepencil(go, totgroup, &points, ob->obmat, thresh);
+	}
+
+
+	/* local settings, apply per shard!!! Or globally too first. */
+	if (emd->point_source & MOD_FRACTURE_UNIFORM)
+	{
+		int count = emd->shard_count;
+		INIT_MINMAX(min, max);
+		BKE_get_shard_minmax(emd->frac_mesh, -1, min, max, fracmesh); //id 0 should be entire mesh
+
+		if (emd->frac_algorithm == MOD_FRACTURE_BISECT_FAST || emd->frac_algorithm == MOD_FRACTURE_BISECT_FAST_FILL) {
+			/* XXX need double amount of shards, because we create 2 islands at each cut... so this matches the input count */
+			count *= 2;
+		}
+
+		BLI_srandom(emd->point_seed);
+		for (i = 0; i < count; ++i) {
+			if (BLI_frand() < thresh) {
+				float *co;
+				points.points = MEM_reallocN(points.points, sizeof(FracPoint) * (points.totpoints + 1));
+				co = points.points[points.totpoints].co;
+				co[0] = min[0] + (max[0] - min[0]) * BLI_frand();
+				co[1] = min[1] + (max[1] - min[1]) * BLI_frand();
+				co[2] = min[2] + (max[2] - min[2]) * BLI_frand();
+				points.totpoints++;
+			}
+		}
+	}
+
+	MEM_freeN(go);
+	return points;
+}
+
+static void do_fracture(FractureModifierData *fracmd, ShardID id, Object *obj, DerivedMesh *dm)
+{
+	/* dummy point cloud, random */
+	FracPointCloud points;
+
+	points = get_points_global(fracmd, obj, dm);
+
+	if (points.totpoints > 0) {
+		bool temp = fracmd->shards_to_islands;
+		short mat_index = 0;
+
+		if (fracmd->inner_material) {
+			/* assign inner material as secondary mat to ob if not there already */
+			mat_index = find_material_index(obj, fracmd->inner_material);
+			if (mat_index == 0) {
+				object_add_material_slot(obj);
+				assign_material(obj, fracmd->inner_material, obj->totcol, BKE_MAT_ASSIGN_OBDATA);
+			}
+
+			/* get index again */
+			mat_index = find_material_index(obj, fracmd->inner_material);
+		}
+
+		mat_index = mat_index > 0 ? mat_index - 1 : mat_index;
+		BKE_fracture_shard_by_points(fracmd->frac_mesh, id, &points, fracmd->frac_algorithm, obj, dm, mat_index);
+
+		/* job has been cancelled, throw away all data */
+		if (fracmd->frac_mesh->cancel == 1)
+		{
+			fracmd->frac_mesh->running = 0;
+			fracmd->refresh = true;
+			freeData((ModifierData *)fracmd);
+			fracmd->frac_mesh = NULL;
+			fracmd->refresh = false;
+			MEM_freeN(points.points);
+			return;
+		}
+
+		if (fracmd->frac_mesh->shard_count > 0)
+		{
+			doClusters(fracmd, 1);
+		}
+
+		/* here we REALLY need to fracture so deactivate the shards to islands flag and activate afterwards */
+		fracmd->shards_to_islands = false;
+		BKE_fracture_create_dm(fracmd, true);
+		fracmd->shards_to_islands = temp;
+	}
+	MEM_freeN(points.points);
+}
+
+
+static void copyData(ModifierData *md, ModifierData *target)
+{
+	FractureModifierData *rmd  = (FractureModifierData *)md;
+	FractureModifierData *trmd = (FractureModifierData *)target;
+
+	/*todo -> copy fracture stuff as well, and dont forget readfile / writefile...*/
+
+	zero_m4(trmd->origmat);
+	trmd->breaking_threshold = rmd->breaking_threshold;
+	trmd->use_constraints = rmd->use_constraints;
+	trmd->contact_dist = rmd->contact_dist;
+	trmd->use_mass_dependent_thresholds = rmd->use_mass_dependent_thresholds;
+	trmd->explo_shared = rmd->explo_shared;
+
+	trmd->visible_mesh = NULL;
+	trmd->visible_mesh_cached = NULL;
+	trmd->meshIslands.first = NULL;
+	trmd->meshIslands.last = NULL;
+	trmd->meshConstraints.first = NULL;
+	trmd->meshConstraints.last = NULL;
+
+	trmd->refresh = false;
+	trmd->constraint_limit = rmd->constraint_limit;
+	trmd->breaking_angle = rmd->breaking_angle;
+	trmd->breaking_distance = rmd->breaking_distance;
+	trmd->breaking_percentage = rmd->breaking_percentage;
+	trmd->use_experimental = rmd->use_experimental;
+	trmd->refresh_constraints = false;
+
+	trmd->cluster_count = rmd->cluster_count;
+	trmd->cluster_breaking_threshold = rmd->cluster_breaking_threshold;
+	trmd->solver_iterations_override = rmd->solver_iterations_override;
+	trmd->shards_to_islands = rmd->shards_to_islands;
+
+	trmd->shard_count = rmd->shard_count;
+	trmd->frac_algorithm = rmd->frac_algorithm;
+
+	trmd->auto_execute = rmd->auto_execute;
+	trmd->autohide_dist = rmd->autohide_dist;
+
+	trmd->solver_iterations_override = rmd->solver_iterations_override;
+
+	trmd->breaking_angle_weighted = rmd->breaking_angle_weighted;
+	trmd->breaking_distance_weighted = rmd->breaking_distance_weighted;
+	trmd->breaking_percentage_weighted = rmd->breaking_percentage_weighted;
+
+	trmd->execute_threaded = rmd->execute_threaded;
+	trmd->point_seed = rmd->point_seed;
+	trmd->point_source = rmd->point_source;
+
+	/* vgroups  XXX TODO non ascii strings ?*/
+	strncpy(trmd->thresh_defgrp_name, rmd->thresh_defgrp_name, strlen(rmd->thresh_defgrp_name));
+	strncpy(trmd->ground_defgrp_name, rmd->ground_defgrp_name, strlen(rmd->ground_defgrp_name));
+	strncpy(trmd->inner_defgrp_name, rmd->inner_defgrp_name, strlen(rmd->inner_defgrp_name));
+
+	/*id refs ?*/
+	trmd->inner_material = rmd->inner_material;
+	trmd->extra_group = rmd->extra_group;
+
+	/* sub object group  XXX Do we keep this ?*/
+	/* trmd->dm_group = rmd->dm_group;*/
+
+	trmd->use_particle_birth_coordinates = rmd->use_particle_birth_coordinates;
+}
+
+void freeMeshIsland(FractureModifierData *rmd, MeshIsland *mi, bool remove_rigidbody)
+{
+
+	if (mi->physics_mesh) {
+		mi->physics_mesh->needsFree = 1;
+		mi->physics_mesh->release(mi->physics_mesh);
+		mi->physics_mesh = NULL;
+	}
+	if (mi->rigidbody) {
+		if (remove_rigidbody)
+			BKE_rigidbody_remove_shard(rmd->modifier.scene, mi);
+		MEM_freeN(mi->rigidbody);
+		mi->rigidbody = NULL;
+	}
+
+	{
+		if (mi->vertco) {
+			MEM_freeN(mi->vertco);
+			mi->vertco = NULL;
+		}
+
+		if (mi->vertno) {
+			MEM_freeN(mi->vertno);
+			mi->vertno = NULL;
+		}
+
+		if (mi->vertices) {
+			MEM_freeN(mi->vertices);
+			mi->vertices = NULL; /*borrowed only !!!*/
+		}
+	}
+
+	if (mi->vertices_cached) {
+		MEM_freeN(mi->vertices_cached);
+		mi->vertices_cached = NULL;
+	}
+
+	if (mi->bb != NULL) {
+		MEM_freeN(mi->bb);
+		mi->bb = NULL;
+	}
+
+	if (mi->participating_constraints != NULL) {
+		MEM_freeN(mi->participating_constraints);
+		mi->participating_constraints = NULL;
+		mi->participating_constraint_count = 0;
+	}
+
+	if (mi->vertex_indices) {
+		MEM_freeN(mi->vertex_indices);
+		mi->vertex_indices = NULL;
+	}
+
+	MEM_freeN(mi);
+	mi = NULL;
+}
+
+/* mi->bb, its for volume fraction calculation.... */
+float bbox_vol(BoundBox *bb);
+float bbox_vol(BoundBox *bb)
+{
+	float x[3], y[3], z[3];
+
+	sub_v3_v3v3(x, bb->vec[4], bb->vec[0]);
+	sub_v3_v3v3(y, bb->vec[3], bb->vec[0]);
+	sub_v3_v3v3(z, bb->vec[1], bb->vec[0]);
+
+	return len_v3(x) * len_v3(y) * len_v3(z);
+}
+void bbox_dim(BoundBox *bb, float dim[]);
+void bbox_dim(BoundBox *bb, float dim[3])
+{
+	float x[3], y[3], z[3];
+
+	sub_v3_v3v3(x, bb->vec[4], bb->vec[0]);
+	sub_v3_v3v3(y, bb->vec[3], bb->vec[0]);
+	sub_v3_v3v3(z, bb->vec[1], bb->vec[0]);
+
+	dim[0] = len_v3(x);
+	dim[1] = len_v3(y);
+	dim[2] = len_v3(z);
+}
+
+int BM_calc_center_centroid(BMesh *bm, float cent[3], int tagged);
+int BM_calc_center_centroid(BMesh *bm, float cent[3], int tagged)
+{
+	BMFace *f;
+	BMIter iter;
+	float face_area;
+	float total_area = 0.0f;
+	float face_cent[3];
+
+	zero_v3(cent);
+
+	/* calculate a weighted average of face centroids */
+	BM_ITER_MESH (f, &iter, bm, BM_FACES_OF_MESH) {
+		if (BM_elem_flag_test(f, BM_ELEM_TAG) || !tagged) {
+			BM_face_calc_center_mean(f, face_cent);
+			face_area = BM_face_calc_area(f);
+
+			madd_v3_v3fl(cent, face_cent, face_area);
+			total_area += face_area;
+		}
+	}
+	/* otherwise we get NAN for 0 polys */
+	if (bm->totface) {
+		mul_v3_fl(cent, 1.0f / total_area);
+	}
+	else if (bm->totvert == 1) {
+		copy_v3_v3(cent, BM_vert_at_index_find(bm, 0)->co);
+	}
+
+	return (bm->totface != 0);
+}
+
+
+static int BM_mesh_minmax(BMesh *bm, float r_min[3], float r_max[3], int tagged)
+{
+	BMVert *v;
+	BMIter iter;
+	INIT_MINMAX(r_min, r_max);
+	BM_ITER_MESH (v, &iter, bm, BM_VERTS_OF_MESH) {
+		if ((tagged && BM_elem_flag_test(v, BM_ELEM_SELECT)) || (!tagged)) {
+			minmax_v3v3_v3(r_min, r_max, v->co);
+		}
+	}
+
+	return (bm->totvert != 0);
+}
+
+static float mesh_separate_tagged(FractureModifierData *rmd, Object *ob, BMVert **v_tag, int v_count, float **startco, BMesh *bm_work, short **startno, DerivedMesh *orig_dm)
+{
+	BMesh *bm_new;
+	BMesh *bm_old = bm_work;
+	MeshIsland *mi;
+	float centroid[3], dummyloc[3], rot[4], min[3], max[3], vol = 0;
+	BMVert *v;
+	BMIter iter;
+	DerivedMesh *dm = NULL, *dmtemp = NULL;
+	Shard *s;
+	int i = 0;
+
+	if (rmd->frac_mesh->cancel == 1)
+		return 0.0f;
+
+	bm_new = BM_mesh_create(&bm_mesh_allocsize_default);
+	BM_mesh_elem_toolflags_ensure(bm_new);  /* needed for 'duplicate' bmo */
+
+	CustomData_copy(&bm_old->vdata, &bm_new->vdata, CD_MASK_BMESH, CD_CALLOC, 0);
+	CustomData_copy(&bm_old->edata, &bm_new->edata, CD_MASK_BMESH, CD_CALLOC, 0);
+	CustomData_copy(&bm_old->ldata, &bm_new->ldata, CD_MASK_BMESH, CD_CALLOC, 0);
+	CustomData_copy(&bm_old->pdata, &bm_new->pdata, CD_MASK_BMESH, CD_CALLOC, 0);
+
+	CustomData_bmesh_init_pool(&bm_new->vdata, bm_mesh_allocsize_default.totvert, BM_VERT);
+	CustomData_bmesh_init_pool(&bm_new->edata, bm_mesh_allocsize_default.totedge, BM_EDGE);
+	CustomData_bmesh_init_pool(&bm_new->ldata, bm_mesh_allocsize_default.totloop, BM_LOOP);
+	CustomData_bmesh_init_pool(&bm_new->pdata, bm_mesh_allocsize_default.totface, BM_FACE);
+
+	BMO_op_callf(bm_old, (BMO_FLAG_DEFAULTS & ~BMO_FLAG_RESPECT_HIDE),
+	             "duplicate geom=%hvef dest=%p", BM_ELEM_TAG, bm_new);
+
+	BM_calc_center_centroid(bm_new, centroid, false);
+	BM_mesh_elem_index_ensure(bm_new, BM_VERT | BM_EDGE | BM_FACE);
+
+	if (rmd->shards_to_islands || rmd->frac_mesh->shard_count < 2) {
+		/* store temporary shards for each island */
+		dmtemp = CDDM_from_bmesh(bm_new, true);
+		s = BKE_create_fracture_shard(dmtemp->getVertArray(dmtemp), dmtemp->getPolyArray(dmtemp), dmtemp->getLoopArray(dmtemp),
+		                              dmtemp->getNumVerts(dmtemp), dmtemp->getNumPolys(dmtemp), dmtemp->getNumLoops(dmtemp), true);
+		s = BKE_custom_data_to_shard(s, dmtemp);
+		BLI_addtail(&rmd->islandShards, s);
+
+		dmtemp->needsFree = 1;
+		dmtemp->release(dmtemp);
+		dmtemp = NULL;
+	}
+
+	BM_ITER_MESH (v, &iter, bm_new, BM_VERTS_OF_MESH) {
+		/* eliminate centroid in vertex coords */
+		sub_v3_v3(v->co, centroid);
+	}
+
+	mi = MEM_callocN(sizeof(MeshIsland), "meshIsland");
+	BLI_addtail(&rmd->meshIslands, mi);
+
+	mi->thresh_weight = 0;
+	mi->vertices = v_tag;
+	mi->vertco = *startco;
+	mi->vertno = *startno;
+	zero_v3(mi->start_co);
+
+	BM_mesh_normals_update(bm_new);
+	BM_mesh_minmax(bm_new, min, max, false);
+	dm = CDDM_from_bmesh(bm_new, true);
+	BM_mesh_free(bm_new);
+	bm_new = NULL;
+
+	mi->physics_mesh = dm;
+	mi->vertex_count = v_count;
+
+	mi->vertex_indices = MEM_mallocN(sizeof(int) * mi->vertex_count, "mi->vertex_indices");
+	for (i = 0; i < mi->vertex_count; i++) {
+		mi->vertex_indices[i] = mi->vertices[i]->head.index;
+	}
+
+	/* copy fixed normals to physicsmesh too, for convert to objects */
+	if (rmd->fix_normals) {
+		MVert *verts, *mv;
+		int j = 0, totvert = 0;
+		totvert = mi->vertex_count;
+		verts = mi->physics_mesh->getVertArray(mi->physics_mesh);
+		for (mv = verts, j = 0; j < totvert; mv++, j++) {
+			short no[3];
+			no[0] = mi->vertno[j * 3];
+			no[1] = mi->vertno[j * 3 + 1];
+			no[2] = mi->vertno[j * 3 + 2];
+
+			copy_v3_v3_short(mv->no, no);
+		}
+	}
+
+	copy_v3_v3(mi->centroid, centroid);
+	mat4_to_loc_quat(dummyloc, rot, ob->obmat);
+	copy_v3_v3(mi->rot, rot);
+	mi->bb = BKE_boundbox_alloc_unit();
+	BKE_boundbox_init_from_minmax(mi->bb, min, max);
+	mi->participating_constraints = NULL;
+	mi->participating_constraint_count = 0;
+
+	vol = bbox_vol(mi->bb);
+	if (vol > rmd->max_vol) {
+		rmd->max_vol = vol;
+	}
+
+	mi->rigidbody = NULL;
+	mi->vertices_cached = NULL;
+
+	mi->rigidbody = BKE_rigidbody_create_shard(rmd->modifier.scene, ob, mi);
+	BKE_rigidbody_calc_shard_mass(ob, mi, orig_dm);
+
+
+	/* deselect loose data - this used to get deleted,
+	 * we could de-select edges and verts only, but this turns out to be less complicated
+	 * since de-selecting all skips selection flushing logic */
+	BM_mesh_elem_hflag_disable_all(bm_old, BM_VERT | BM_EDGE | BM_FACE, BM_ELEM_TAG, false);
+
+	return vol;
+}
+
+/* flush a hflag to from verts to edges/faces */
+static void bm_mesh_hflag_flush_vert(BMesh *bm, const char hflag)
+{
+	BMEdge *e;
+	BMLoop *l_iter;
+	BMLoop *l_first;
+	BMFace *f;
+
+	BMIter eiter;
+	BMIter fiter;
+
+	int ok;
+
+	BM_ITER_MESH (e, &eiter, bm, BM_EDGES_OF_MESH) {
+		if (BM_elem_flag_test(e->v1, hflag) &&
+		    BM_elem_flag_test(e->v2, hflag))
+		{
+			BM_elem_flag_enable(e, hflag);
+		}
+		else {
+			BM_elem_flag_disable(e, hflag);
+		}
+	}
+	BM_ITER_MESH (f, &fiter, bm, BM_FACES_OF_MESH) {
+		ok = true;
+		l_iter = l_first = BM_FACE_FIRST_LOOP(f);
+		do {
+			if (!BM_elem_flag_test(l_iter->v, hflag)) {
+				ok = false;
+				break;
+			}
+		} while ((l_iter = l_iter->next) != l_first);
+
+		BM_elem_flag_set(f, hflag, ok);
+	}
+}
+
+static void mesh_separate_loose_partition(FractureModifierData *rmd, Object *ob, BMesh *bm_work, BMVert **orig_work, DerivedMesh *dm)
+{
+	int i, tag_counter = 0;
+	BMEdge *e;
+	BMVert *v_seed, **v_tag;
+	BMWalker walker;
+	int tot = 0;
+	BMesh *bm_old = bm_work;
+	int max_iter = bm_old->totvert;
+	BMIter iter;
+	float *startco;
+	short *startno;
+
+
+	if (max_iter > 0) {
+		rmd->frac_mesh->progress_counter++;
+	}
+
+	/* Clear all selected vertices */
+	BM_mesh_elem_hflag_disable_all(bm_old, BM_VERT | BM_EDGE | BM_FACE, BM_ELEM_INTERNAL_TAG | BM_ELEM_TAG, false);
+
+
+	/* A "while (true)" loop should work here as each iteration should
+	 * select and remove at least one vertex and when all vertices
+	 * are selected the loop will break out. But guard against bad
+	 * behavior by limiting iterations to the number of vertices in the
+	 * original mesh.*/
+	for (i = 0; i < max_iter; i++) {
+		tag_counter = 0;
+
+		BM_ITER_MESH (v_seed, &iter, bm_old, BM_VERTS_OF_MESH) {
+			/* Hrm need to look at earlier verts to for unused ones.*/
+			if (!BM_elem_flag_test(v_seed, BM_ELEM_TAG) && !BM_elem_flag_test(v_seed, BM_ELEM_INTERNAL_TAG)) {
+				break;
+			}
+		}
+
+		/* No vertices available, can't do anything */
+		if (v_seed == NULL) {
+			break;
+		}
+		/* Select the seed explicitly, in case it has no edges */
+		if (!BM_elem_flag_test(v_seed, BM_ELEM_TAG) && !BM_elem_flag_test(v_seed, BM_ELEM_INTERNAL_TAG)) {
+
+			short no[3];
+
+			v_tag = MEM_callocN(sizeof(BMVert *), "v_tag");
+			startco = MEM_callocN(sizeof(float), "mesh_separate_loose->startco");
+			startno = MEM_callocN(sizeof(short), "mesh_separate_loose->startno");
+
+			BM_elem_flag_enable(v_seed, BM_ELEM_TAG);
+			BM_elem_flag_enable(v_seed, BM_ELEM_INTERNAL_TAG);
+			v_tag = MEM_reallocN(v_tag, sizeof(BMVert *) * (tag_counter + 1));
+			v_tag[tag_counter] = orig_work[v_seed->head.index];
+
+			startco = MEM_reallocN(startco, (tag_counter + 1) * 3 * sizeof(float));
+			startco[3 * tag_counter] = v_seed->co[0];
+			startco[3 * tag_counter + 1] = v_seed->co[1];
+			startco[3 * tag_counter + 2] = v_seed->co[2];
+
+			startno = MEM_reallocN(startno, (tag_counter + 1) * 3 * sizeof(short));
+
+			find_normal(dm, rmd->nor_tree, v_seed->co, no);
+			startno[3 * tag_counter] = no[0];
+			startno[3 * tag_counter + 1] = no[1];
+			startno[3 * tag_counter + 2] = no[2];
+
+
+			tot++;
+			tag_counter++;
+		}
+
+		/* Walk from the single vertex, selecting everything connected
+		 * to it */
+		BMW_init(&walker, bm_old, BMW_VERT_SHELL,
+		         BMW_MASK_NOP, BMW_MASK_NOP, BMW_MASK_NOP,
+		         BMW_FLAG_NOP,
+		         BMW_NIL_LAY);
+
+		e = BMW_begin(&walker, v_seed);
+		for (; e; e = BMW_step(&walker)) {
+			if (!BM_elem_flag_test(e->v1, BM_ELEM_TAG) && !BM_elem_flag_test(e->v1, BM_ELEM_INTERNAL_TAG)) {
+				short no[3];
+
+				BM_elem_flag_enable(e->v1, BM_ELEM_TAG);
+				BM_elem_flag_enable(e->v1, BM_ELEM_INTERNAL_TAG);
+				v_tag = MEM_reallocN(v_tag, sizeof(BMVert *) * (tag_counter + 1));
+				v_tag[tag_counter] = orig_work[e->v1->head.index];
+
+				startco = MEM_reallocN(startco, (tag_counter + 1) * 3 * sizeof(float));
+				startco[3 * tag_counter] = e->v1->co[0];
+				startco[3 * tag_counter + 1] = e->v1->co[1];
+				startco[3 * tag_counter + 2] = e->v1->co[2];
+
+
+				startno = MEM_reallocN(startno, (tag_counter + 1) * 3 * sizeof(short));
+
+				find_normal(dm, rmd->nor_tree, e->v1->co, no);
+				startno[3 * tag_counter] = no[0];
+				startno[3 * tag_counter + 1] = no[1];
+				startno[3 * tag_counter + 2] = no[2];
+
+				tot++;
+				tag_counter++;
+			}
+			if (!BM_elem_flag_test(e->v2, BM_ELEM_TAG) && !BM_elem_flag_test(e->v2, BM_ELEM_INTERNAL_TAG)) {
+				short no[3];
+
+				BM_elem_flag_enable(e->v2, BM_ELEM_TAG);
+				BM_elem_flag_enable(e->v2, BM_ELEM_INTERNAL_TAG);
+
+				v_tag = MEM_reallocN(v_tag, sizeof(BMVert *) * (tag_counter + 1));
+				v_tag[tag_counter] = orig_work[e->v2->head.index];
+
+				startco = MEM_reallocN(startco, (tag_counter + 1) * 3 * sizeof(float));
+				startco[3 * tag_counter] = e->v2->co[0];
+				startco[3 * tag_counter + 1] = e->v2->co[1];
+				startco[3 * tag_counter + 2] = e->v2->co[2];
+
+				startno = MEM_reallocN(startno, (tag_counter + 1) * 3 * sizeof(short));
+
+				find_normal(dm, rmd->nor_tree, e->v2->co, no);
+				startno[3 * tag_counter] = no[0];
+				startno[3 * tag_counter + 1] = no[1];
+				startno[3 * tag_counter + 2] = no[2];
+
+				tot++;
+				tag_counter++;
+			}
+		}
+		BMW_end(&walker);
+
+		/* Flush the selection to get edge/face selections matching
+		 * the vertex selection */
+		bm_mesh_hflag_flush_vert(bm_old, BM_ELEM_TAG);
+
+		/* Move selection into a separate object */
+		mesh_separate_tagged(rmd, ob, v_tag, tag_counter, &startco, bm_old, &startno, dm);
+		if (tot >= bm_old->totvert) {
+			break;
+		}
+
+	}
+
+}
+
+/* inlined select_linked functionality here, because not easy to reach without modifications */
+static void select_linked(BMesh **bm_in)
+{
+	BMIter iter;
+	BMVert *v;
+	BMEdge *e;
+	BMWalker walker;
+	BMesh *bm_work = *bm_in;
+
+
+	BM_ITER_MESH (v, &iter, bm_work, BM_VERTS_OF_MESH) {
+		if (BM_elem_flag_test(v, BM_ELEM_SELECT)) {
+			BM_elem_flag_enable(v, BM_ELEM_TAG);
+		}
+		else {
+			BM_elem_flag_disable(v, BM_ELEM_TAG);
+		}
+	}
+
+	BMW_init(&walker, bm_work, BMW_VERT_SHELL,
+	         BMW_MASK_NOP, BMW_MASK_NOP, BMW_MASK_NOP,
+	         BMW_FLAG_TEST_HIDDEN,
+	         BMW_NIL_LAY);
+
+	BM_ITER_MESH (v, &iter, bm_work, BM_VERTS_OF_MESH) {
+		if (BM_elem_flag_test(v, BM_ELEM_TAG)) {
+			for (e = BMW_begin(&walker, v); e; e = BMW_step(&walker)) {
+				BM_edge_select_set(bm_work, e, true);
+			}
+		}
+	}
+	BMW_end(&walker);
+
+	BM_mesh_select_flush(bm_work);
+}
+
+static void mesh_separate_selected(BMesh **bm_work, BMesh **bm_out, BMVert **orig_work, BMVert ***orig_out1, BMVert ***orig_out2)
+{
+	BMesh *bm_old = *bm_work;
+	BMesh *bm_new = *bm_out;
+	BMVert *v, **orig_new = *orig_out1, **orig_mod = *orig_out2;
+	BMIter iter;
+	int new_index = 0, mod_index = 0;
+
+	BM_mesh_elem_hflag_disable_all(bm_old, BM_FACE | BM_EDGE | BM_VERT, BM_ELEM_TAG, false);
+	/* sel -> tag */
+	BM_mesh_elem_hflag_enable_test(bm_old, BM_FACE | BM_EDGE | BM_VERT, BM_ELEM_TAG, true, false, BM_ELEM_SELECT);
+
+	BM_mesh_elem_toolflags_ensure(bm_new);  /* needed for 'duplicate' bmo */
+
+	CustomData_copy(&bm_old->vdata, &bm_new->vdata, CD_MASK_BMESH, CD_CALLOC, 0);
+	CustomData_copy(&bm_old->edata, &bm_new->edata, CD_MASK_BMESH, CD_CALLOC, 0);
+	CustomData_copy(&bm_old->ldata, &bm_new->ldata, CD_MASK_BMESH, CD_CALLOC, 0);
+	CustomData_copy(&bm_old->pdata, &bm_new->pdata, CD_MASK_BMESH, CD_CALLOC, 0);
+
+	CustomData_bmesh_init_pool(&bm_new->vdata, bm_mesh_allocsize_default.totvert, BM_VERT);
+	CustomData_bmesh_init_pool(&bm_new->edata, bm_mesh_allocsize_default.totedge, BM_EDGE);
+	CustomData_bmesh_init_pool(&bm_new->ldata, bm_mesh_allocsize_default.totloop, BM_LOOP);
+	CustomData_bmesh_init_pool(&bm_new->pdata, bm_mesh_allocsize_default.totface, BM_FACE);
+
+	BMO_op_callf(bm_old, (BMO_FLAG_DEFAULTS & ~BMO_FLAG_RESPECT_HIDE),
+	             "duplicate geom=%hvef dest=%p", BM_ELEM_TAG, bm_new);
+
+	/* lets hope the order of elements in new mesh is the same as it was in old mesh */
+	BM_ITER_MESH (v, &iter, bm_old, BM_VERTS_OF_MESH) {
+		if (BM_elem_flag_test(v, BM_ELEM_TAG)) {
+			orig_new[new_index] = orig_work[v->head.index];
+			new_index++;
+		}
+		else {
+			orig_mod[mod_index] = orig_work[v->head.index];
+			mod_index++;
+		}
+	}
+
+	new_index = 0;
+	BM_ITER_MESH (v, &iter, bm_new, BM_VERTS_OF_MESH) {
+		v->head.index = new_index;
+		new_index++;
+	}
+
+	BMO_op_callf(bm_old, (BMO_FLAG_DEFAULTS & ~BMO_FLAG_RESPECT_HIDE),
+	             "delete geom=%hvef context=%i", BM_ELEM_TAG, DEL_FACES);
+
+	/* deselect loose data - this used to get deleted,
+	 * we could de-select edges and verts only, but this turns out to be less complicated
+	 * since de-selecting all skips selection flushing logic */
+	BM_mesh_elem_hflag_disable_all(bm_old, BM_VERT | BM_EDGE | BM_FACE, BM_ELEM_SELECT | BM_ELEM_TAG, false);
+
+	BM_mesh_normals_update(bm_new);
+}
+
+static void halve(FractureModifierData *rmd, Object *ob, int minsize, BMesh **bm_work, BMVert ***orig_work, bool separated, DerivedMesh *dm)
+{
+
+	int half;
+	int i = 0, new_count = 0;
+	BMIter iter;
+	BMVert **orig_old = *orig_work, **orig_new, **orig_mod;
+	BMVert *v;
+	BMesh *bm_old = *bm_work;
+	BMesh *bm_new = NULL;
+	separated = false;
+
+	if (rmd->frac_mesh->cancel == 1) {
+		return;
+	}
+
+	bm_new = BM_mesh_create(&bm_mesh_allocsize_default);
+	{
+		{
+			BM_mesh_elem_hflag_disable_all(bm_old, BM_VERT | BM_EDGE | BM_FACE, BM_ELEM_SELECT | BM_ELEM_TAG, false);
+		}
+
+		{
+			half = bm_old->totvert / 2;
+			BM_ITER_MESH (v, &iter, bm_old, BM_VERTS_OF_MESH) {
+				if (i >= half) {
+					break;
+				}
+				BM_elem_select_set(bm_old, (BMElem *)v, true);
+				i++;
+			}
+		}
+
+		bm_mesh_hflag_flush_vert(bm_old, BM_ELEM_SELECT);
+		select_linked(&bm_old);
+
+		new_count = bm_old->totvertsel;
+		printf("Halving...%d => %d %d\n", bm_old->totvert, new_count, bm_old->totvert - new_count);
+
+		orig_new = MEM_callocN(sizeof(BMVert *) * new_count, "orig_new");
+		orig_mod = MEM_callocN(sizeof(BMVert *) * bm_old->totvert - new_count, "orig_mod");
+		mesh_separate_selected(&bm_old, &bm_new, orig_old, &orig_new, &orig_mod);
+	}
+
+	printf("Old New: %d %d\n", bm_old->totvert, bm_new->totvert);
+	if ((bm_old->totvert <= minsize && bm_old->totvert > 0) || (bm_new->totvert == 0)) {
+
+		mesh_separate_loose_partition(rmd, ob, bm_old, orig_mod, dm);
+		separated = true;
+
+	}
+
+	if ((bm_new->totvert <= minsize && bm_new->totvert > 0) || (bm_old->totvert == 0)) {
+		mesh_separate_loose_partition(rmd, ob, bm_new, orig_new, dm);
+		separated = true;
+	}
+
+	if ((bm_old->totvert > minsize && bm_new->totvert > 0) || (bm_new->totvert == 0 && !separated)) {
+		halve(rmd, ob, minsize, &bm_old, &orig_mod, separated, dm);
+	}
+
+	if ((bm_new->totvert > minsize && bm_old->totvert > 0) || (bm_old->totvert == 0 && !separated)) {
+		halve(rmd, ob, minsize, &bm_new, &orig_new, separated, dm);
+	}
+
+
+	MEM_freeN(orig_mod);
+	MEM_freeN(orig_new);
+	BM_mesh_free(bm_new);
+	bm_new = NULL;
+}
+
+static void mesh_separate_loose(FractureModifierData *rmd, Object *ob, DerivedMesh *dm)
+{
+	int minsize = 1000;
+	BMesh *bm_work;
+	BMVert *vert, **orig_start;
+	BMIter iter;
+
+	BM_mesh_elem_hflag_disable_all(rmd->visible_mesh, BM_VERT | BM_EDGE | BM_FACE, BM_ELEM_SELECT | BM_ELEM_TAG, false);
+	bm_work = BM_mesh_copy(rmd->visible_mesh);
+
+	orig_start = MEM_callocN(sizeof(BMVert *) * rmd->visible_mesh->totvert, "orig_start");
+	/* associate new verts with old verts, here indexes should match still */
+	BM_ITER_MESH (vert, &iter, rmd->visible_mesh, BM_VERTS_OF_MESH)
+	{
+		orig_start[vert->head.index] = vert;
+	}
+
+	BM_mesh_elem_index_ensure(bm_work, BM_VERT);
+	BM_mesh_elem_table_ensure(bm_work, BM_VERT);
+
+	/* free old islandshards first, if any */
+	while (rmd->islandShards.first) {
+		Shard *s = rmd->islandShards.first;
+		BLI_remlink(&rmd->islandShards, s);
+		BKE_shard_free(s, true);
+		s = NULL;
+	}
+
+	rmd->islandShards.first = NULL;
+	rmd->islandShards.last = NULL;
+
+
+	halve(rmd, ob, minsize, &bm_work, &orig_start, false, dm);
+
+
+	MEM_freeN(orig_start);
+	orig_start = NULL;
+	BM_mesh_free(bm_work);
+	bm_work = NULL;
+
+}
+
+static void connect_meshislands(FractureModifierData *rmd, MeshIsland *mi1, MeshIsland *mi2, int con_type, float thresh)
+{
+	int con_found = false;
+	RigidBodyShardCon *con, *rbsc;
+	bool ok = mi1 && mi1->rigidbody;
+	ok = ok && mi2 && mi2->rigidbody;
+
+	if (ok) {
+		/* search local constraint list instead of global one !!! saves lots of time */
+		int i;
+		for (i = 0; i < mi1->participating_constraint_count; i++) {
+			con = mi1->participating_constraints[i];
+			if ((con->mi1 == mi2) || (con->mi2 == mi2)) {
+				con_found = true;
+				break;
+			}
+		}
+
+		if (!con_found) {
+			for (i = 0; i < mi2->participating_constraint_count; i++) {
+				con = mi2->participating_constraints[i];
+				if ((con->mi1 == mi1) || (con->mi2 == mi1)) {
+					con_found = true;
+					break;
+				}
+			}
+		}
+	}
+
+	if (!con_found && ok) {
+		if (rmd->use_constraints) {
+			rbsc = BKE_rigidbody_create_shard_constraint(rmd->modifier.scene, con_type);
+			rbsc->mi1 = mi1;
+			rbsc->mi2 = mi2;
+			if (thresh == 0) {
+				rbsc->flag &= ~RBC_FLAG_USE_BREAKING;
+			}
+
+			rbsc->flag |= RBC_FLAG_DISABLE_COLLISIONS;
+
+			if ((mi1->particle_index != -1) && (mi2->particle_index != -1) &&
+			    (mi1->particle_index == mi2->particle_index))
+			{
+				if (rmd->cluster_count > 1) {
+					rbsc->breaking_threshold = rmd->cluster_breaking_threshold;
+				}
+				else {
+					rbsc->breaking_threshold = thresh;
+				}
+			}
+			else {
+				rbsc->breaking_threshold = thresh;
+			}
+
+			if (rmd->thresh_defgrp_name[0]) {
+				/* modify maximum threshold by minimum weight */
+				rbsc->breaking_threshold = thresh * MIN2(mi1->thresh_weight, mi2->thresh_weight);
+			}
+
+			BLI_addtail(&rmd->meshConstraints, rbsc);
+
+			/* store constraints per meshisland too, to allow breaking percentage */
+			if (mi1->participating_constraints == NULL) {
+				mi1->participating_constraints = MEM_callocN(sizeof(RigidBodyShardCon *), "part_constraints_mi1");
+				mi1->participating_constraint_count = 0;
+			}
+			mi1->participating_constraints = MEM_reallocN(mi1->participating_constraints, sizeof(RigidBodyShardCon *) * (mi1->participating_constraint_count + 1));
+			mi1->participating_constraints[mi1->participating_constraint_count] = rbsc;
+			mi1->participating_constraint_count++;
+
+			if (mi2->participating_constraints == NULL) {
+				mi2->participating_constraints = MEM_callocN(sizeof(RigidBodyShardCon *), "part_constraints_mi2");
+				mi2->participating_constraint_count = 0;
+			}
+			mi2->participating_constraints = MEM_reallocN(mi2->participating_constraints, sizeof(RigidBodyShardCon *) * (mi2->participating_constraint_count + 1));
+			mi2->participating_constraints[mi2->participating_constraint_count] = rbsc;
+			mi2->participating_constraint_count++;
+		}
+	}
+}
+
+static void search_centroid_based(FractureModifierData *rmd, MeshIsland *mi, MeshIsland **meshIslands, KDTree **combined_tree)
+{
+	int r = 0, limit = 0, i = 0;
+	KDTreeNearest *n3 = NULL;
+	float dist, obj_centr[3];
+
+	limit = rmd->constraint_limit;
+	dist = rmd->contact_dist;
+
+	mul_v3_m4v3(obj_centr, rmd->origmat, mi->centroid);
+
+	r = BLI_kdtree_range_search(*combined_tree, obj_centr, &n3, dist);
+
+	/* use centroid dist based approach here, together with limit */
+	for (i = 0; i < r; i++) {
+		MeshIsland *mi2 = meshIslands[(n3 + i)->index];
+		if ((mi != mi2) && (mi2 != NULL)) {
+			float thresh = rmd->breaking_threshold;
+			int con_type = RBC_TYPE_FIXED;
+
+			if ((i >= limit) && (limit > 0)) {
+				break;
+			}
+
+			connect_meshislands(rmd, mi, mi2, con_type, thresh);
+		}
+	}
+
+	if (n3 != NULL) {
+		MEM_freeN(n3);
+		n3 = NULL;
+	}
+}
+
+static int prepareConstraintSearch(FractureModifierData *rmd, MeshIsland ***mesh_islands, KDTree **combined_tree)
+{
+	MeshIsland *mi;
+	int i = 0, islands = 0;
+
+	islands = BLI_countlist(&rmd->meshIslands);
+	*mesh_islands = MEM_reallocN(*mesh_islands, islands * sizeof(MeshIsland *));
+	for (mi = rmd->meshIslands.first; mi; mi = mi->next) {
+		(*mesh_islands)[i] = mi;
+		i++;
+	}
+
+	*combined_tree = BLI_kdtree_new(islands);
+	for (i = 0; i < islands; i++) {
+		float obj_centr[3];
+		mul_v3_m4v3(obj_centr, rmd->origmat, (*mesh_islands)[i]->centroid);
+		BLI_kdtree_insert(*combined_tree, i, obj_centr);
+	}
+
+	BLI_kdtree_balance(*combined_tree);
+
+	return islands;
+}
+
+static void create_constraints(FractureModifierData *rmd)
+{
+	KDTree *centroid_tree = NULL;
+	MeshIsland **mesh_islands = MEM_mallocN(sizeof(MeshIsland *), "mesh_islands");
+	int count, i = 0;
+
+	if (rmd->visible_mesh && rmd->contact_dist == 0.0f) {
+		/* extend contact dist to bbox max dimension here, in case we enter 0 */
+		float min[3], max[3], dim[3];
+		BoundBox *bb = BKE_boundbox_alloc_unit();
+		BM_mesh_minmax(rmd->visible_mesh, min, max, 0);
+		BKE_boundbox_init_from_minmax(bb, min, max);
+		bbox_dim(bb, dim);
+		rmd->contact_dist = MAX3(dim[0], dim[1], dim[2]);
+		MEM_freeN(bb);
+	}
+
+	count = prepareConstraintSearch(rmd, &mesh_islands, &centroid_tree);
+
+	for (i = 0; i < count; i++) {
+		search_centroid_based(rmd, mesh_islands[i], mesh_islands, &centroid_tree);
+	}
+
+	if (centroid_tree != NULL) {
+		BLI_kdtree_free(centroid_tree);
+		centroid_tree = NULL;
+	}
+
+	MEM_freeN(mesh_islands);
+}
+
+static void fill_vgroup(FractureModifierData *rmd, DerivedMesh *dm, MDeformVert *dvert, Object *ob)
+{
+	/* use fallback over inner material (no more, now directly via tagged verts) */
+	if (rmd->inner_defgrp_name[0]) {
+		int ind = 0;
+		MPoly *mp = dm->getPolyArray(dm);
+		MLoop *ml = dm->getLoopArray(dm);
+		MVert *mv = dm->getVertArray(dm);
+		int count = dm->getNumPolys(dm);
+		int totvert = dm->getNumVerts(dm);
+		const int inner_defgrp_index = defgroup_name_index(ob, rmd->inner_defgrp_name);
+
+		if (dvert != NULL) {
+			CustomData_free_layers(&dm->vertData, CD_MDEFORMVERT, totvert);
+			dvert = NULL;
+		}
+
+		dvert = CustomData_add_layer(&dm->vertData, CD_MDEFORMVERT, CD_CALLOC,
+		                             NULL, totvert);
+
+		for (ind = 0; ind < count; ind++) {
+			int j = 0;
+			for (j = 0; j < (mp + ind)->totloop; j++) {
+				MLoop *l;
+				MVert *v;
+				int l_index = (mp + ind)->loopstart + j;
+				l = ml + l_index;
+				v = mv + l->v;
+				if (v->flag & ME_VERT_TMP_TAG) {
+					defvert_add_index_notest(dvert + l->v, inner_defgrp_index, 1.0f);
+					v->flag &= ~ME_VERT_TMP_TAG;
+				}
+			}
+		}
+	}
+}
+
+static DerivedMesh *createCache(FractureModifierData *rmd, Object *ob, DerivedMesh *origdm)
+{
+	MeshIsland *mi;
+	DerivedMesh *dm;
+	MVert *verts;
+	MDeformVert *dvert = NULL;
+	int vertstart = 0;
+	const int thresh_defgrp_index = defgroup_name_index(ob, rmd->thresh_defgrp_name);
+	const int ground_defgrp_index = defgroup_name_index(ob, rmd->ground_defgrp_name);
+	bool orig_chosen = false;
+
+	if (rmd->dm && !rmd->shards_to_islands && (rmd->dm->getNumPolys(rmd->dm) > 0)) {
+		dm = CDDM_copy(rmd->dm);
+	}
+	else if (rmd->visible_mesh && (rmd->visible_mesh->totface > 0) && BLI_countlist(&rmd->meshIslands) > 1) {
+		dm = CDDM_from_bmesh(rmd->visible_mesh, true);
+	}
+
+	else if (origdm != NULL) {
+		dm = CDDM_copy(origdm);
+		orig_chosen = true;
+	}
+	else {
+		return NULL;
+	}
+
+	DM_ensure_tessface(dm);
+	DM_ensure_normals(dm);
+	DM_update_tessface_data(dm);
+
+	verts = dm->getVertArray(dm);
+
+	if (dvert == NULL)
+		dvert = dm->getVertDataArray(dm, CD_MDEFORMVERT);
+
+	/* we reach this code when we fracture without "split shards to islands", but NOT when we load such a file...
+	 * readfile.c has separate code for dealing with this XXX WHY ? there were problems with the mesh...*/
+	for (mi = rmd->meshIslands.first; mi; mi = mi->next) {
+		int i = 0;
+		if (mi->vertices_cached) {
+			MEM_freeN(mi->vertices_cached);
+			mi->vertices_cached = NULL;
+		}
+
+		if (rmd->thresh_defgrp_name[0]) {
+			mi->thresh_weight = 0;
+		}
+
+		mi->vertices_cached = MEM_mallocN(sizeof(MVert *) * mi->vertex_count, "mi->vertices_cached");
+		if (rmd->dm != NULL && !rmd->shards_to_islands && !orig_chosen) {
+			for (i = 0; i < mi->vertex_count; i++) {
+				mi->vertices_cached[i] = verts + vertstart + i;
+
+				/* sum up vertexweights and divide by vertcount to get islandweight*/
+				if (dvert && (dvert + vertstart + i)->dw && rmd->thresh_defgrp_name[0]) {
+					float vweight = defvert_find_weight(dvert + vertstart + i, thresh_defgrp_index);
+					mi->thresh_weight += vweight;
+				}
+
+				if (dvert && (dvert + vertstart + i)->dw && rmd->ground_defgrp_name[0]) {
+					float gweight = defvert_find_weight(dvert + vertstart + i, ground_defgrp_index);
+					mi->ground_weight += gweight;
+				}
+
+				if (mi->vertno != NULL && rmd->fix_normals) {
+					float no[3];
+					short sno[3];
+					no[0] = mi->vertno[i * 3];
+					no[1] = mi->vertno[i * 3 + 1];
+					no[2] = mi->vertno[i * 3 + 2];
+					normal_float_to_short_v3(sno, no);
+					copy_v3_v3_short(mi->vertices_cached[i]->no, sno);
+				}
+			}
+
+			vertstart += mi->vertex_count;
+		}
+		else {  /* halving case... */
+			for (i = 0; i < mi->vertex_count; i++) {
+				float no[3];
+				int index = mi->vertex_indices[i];
+				if (index >= 0 && index <= rmd->visible_mesh->totvert) {
+					mi->vertices_cached[i] = verts + index;
+				}
+				else {
+					mi->vertices_cached[i] = NULL;
+				}
+
+				if (dvert && (dvert + index)->dw && rmd->thresh_defgrp_name[0]) {
+					float vweight = defvert_find_weight(dvert + index, thresh_defgrp_index);
+					mi->thresh_weight += vweight;
+				}
+
+				if (dvert && (dvert + index)->dw && rmd->ground_defgrp_name[0]) {
+					float gweight = defvert_find_weight(dvert + index, ground_defgrp_index);
+					mi->ground_weight += gweight;
+				}
+
+
+				if (mi->vertno != NULL && rmd->fix_normals) {
+					short sno[3];
+					no[0] = mi->vertno[i * 3];
+					no[1] = mi->vertno[i * 3 + 1];
+					no[2] = mi->vertno[i * 3 + 2];
+					normal_float_to_short_v3(sno, no);
+					copy_v3_v3_short(mi->vertices_cached[i]->no, sno);
+				}
+			}
+		}
+
+		if (mi->vertex_count > 0) {
+			mi->thresh_weight /= mi->vertex_count;
+			mi->ground_weight /= mi->vertex_count;
+		}
+
+		if (mi->rigidbody != NULL) {
+			mi->rigidbody->type = mi->ground_weight > 0.5f ? RBO_TYPE_PASSIVE : RBO_TYPE_ACTIVE;
+		}
+
+		/* use fallback over inner material*/
+		fill_vgroup(rmd, dm, dvert, ob);
+	}
+
+	return dm;
+}
+
+void refresh_customdata_image(Mesh *me, CustomData *pdata, int totface)
+{
+	int i;
+
+	for (i = 0; i < pdata->totlayer; i++) {
+		CustomDataLayer *layer = &pdata->layers[i];
+
+		if (layer->type == CD_MTEXPOLY && me->mtpoly) {
+			MTexPoly *tf = layer->data;
+			int j;
+
+			for (j = 0; j < totface; j++, tf++) {
+				//simply use first image here...
+				tf->tpage = me->mtpoly->tpage;
+				tf->mode = me->mtpoly->mode;
+				tf->flag = me->mtpoly->flag;
+				tf->tile = me->mtpoly->tile;
+				tf->transp = me->mtpoly->transp;
+
+				if (tf->tpage && tf->tpage->id.us == 0) {
+					tf->tpage->id.us = 1;
+				}
+			}
+		}
+	}
+}
+
+/* inline face center calc here */
+static void DM_face_calc_center_mean(DerivedMesh *dm, MPoly *mp, float r_cent[3])
+{
+	MLoop *ml = NULL;
+	MLoop *mloop = dm->getLoopArray(dm);
+	MVert *mvert = dm->getVertArray(dm);
+	int i = 0;
+
+	zero_v3(r_cent);
+
+	for (i = mp->loopstart; i < mp->loopstart + mp->totloop; i++) {
+		MVert *mv = NULL;
+		ml = mloop + i;
+		mv = mvert + ml->v;
+
+		add_v3_v3(r_cent, mv->co);
+
+	}
+
+	mul_v3_fl(r_cent, 1.0f / (float) mp->totloop);
+}
+
+static void make_face_pairs(FractureModifierData *fmd, DerivedMesh *dm)
+{
+	/* make kdtree of all faces of dm, then find closest face for each face*/
+	MPoly *mp = NULL;
+	MPoly *mpoly = dm->getPolyArray(dm);
+	int totpoly = dm->getNumPolys(dm);
+	KDTree *tree = BLI_kdtree_new(totpoly);
+	int i = 0;
+
+	for (i = 0, mp = mpoly; i < totpoly; mp++, i++) {
+		float co[3];
+		DM_face_calc_center_mean(dm, mp, co);
+		BLI_kdtree_insert(tree, i, co);
+	}
+
+	BLI_kdtree_balance(tree);
+
+	/*now find pairs of close faces*/
+
+	for (i = 0, mp = mpoly; i < totpoly; mp++, i++)
+	{
+		int index = -1, j = 0, r = 0;
+		KDTreeNearest *n;
+		float co[3];
+
+		DM_face_calc_center_mean(dm, mp, co);
+		r = BLI_kdtree_range_search(tree, co, &n, fmd->autohide_dist * 4);
+		/*2nd nearest means not ourselves...*/
+		if (r == 0)
+			continue;
+
+		index = n[0].index;
+		while ((j < r) && i == index) {
+			index = n[j].index;
+			j++;
+		}
+
+		if (!BLI_ghash_haskey(fmd->face_pairs, SET_INT_IN_POINTER(index))) {
+			BLI_ghash_insert(fmd->face_pairs, SET_INT_IN_POINTER(i), SET_INT_IN_POINTER(index));
+		}
+
+		if (n != NULL) {
+			MEM_freeN(n);
+		}
+	}
+
+	BLI_kdtree_free(tree);
+}
+
+static DerivedMesh *do_autoHide(FractureModifierData *fmd, DerivedMesh *dm)
+{
+	float f_centr[3], f_centr_other[3];
+
+	int totpoly = dm->getNumPolys(dm);
+	int i = 0, other = 0;
+	BMesh *bm = DM_to_bmesh(dm, true);
+	DerivedMesh *result;
+	BMFace **faces = MEM_mallocN(sizeof(BMFace *), "faces");
+	int del_faces = 0;
+
+	BM_mesh_elem_index_ensure(bm, BM_FACE);
+	BM_mesh_elem_table_ensure(bm, BM_FACE);
+	BM_mesh_elem_toolflags_ensure(bm);
+
+	for (i = 0; i < totpoly; i++) {
+		BMFace *f1, *f2;
+		other = GET_INT_FROM_POINTER(BLI_ghash_lookup(fmd->face_pairs, SET_INT_IN_POINTER(i)));
+
+		if (other == i)
+		{
+			continue;
+		}
+
+		f1 = BM_face_at_index_find(bm, i);
+		f2 = BM_face_at_index_find(bm, other);
+
+		if ((f1 == NULL) || (f2 == NULL)) {
+			continue;
+		}
+
+		BM_face_calc_center_mean(f1, f_centr);
+		BM_face_calc_center_mean(f2, f_centr_other);
+
+
+		if (len_squared_v3v3(f_centr, f_centr_other) < fmd->autohide_dist && f1 != f2) {
+			faces = MEM_reallocN(faces, sizeof(BMFace *) * (del_faces + 2));
+			faces[del_faces] = f1;
+			faces[del_faces + 1] = f2;
+			del_faces += 2;
+		}
+	}
+
+	for (i = 0; i < del_faces; i++) {
+		BMFace *f = faces[i];
+		if (f->l_first->e != NULL) { /* a lame check.... */
+			BM_face_kill(bm, f);
+		}
+	}
+
+	result = CDDM_from_bmesh(bm, true);
+	BM_mesh_free(bm);
+	MEM_freeN(faces);
+
+	return result;
+}
+
+
+DerivedMesh *doSimulate(FractureModifierData *fmd, Object *ob, DerivedMesh *dm, DerivedMesh *orig_dm)
+{
+	bool exploOK = false; /* doFracture */
+	double start;
+
+	if ((fmd->refresh) || (fmd->refresh_constraints && !fmd->execute_threaded) ||
+	    (fmd->refresh_constraints && fmd->execute_threaded && fmd->frac_mesh && fmd->frac_mesh->running == 0))
+	{
+		/* if we changed the fracture parameters */
+
+		freeData((ModifierData *)fmd);
+
+		/* 2 cases, we can have a visible mesh or a cached visible mesh, the latter primarily when loading blend from file or using halving */
+
+		/* free cached mesh in case of "normal refracture here if we have a visible mesh, does that mean REfracture ?*/
+		if (fmd->visible_mesh != NULL && !fmd->shards_to_islands && fmd->frac_mesh->shard_count > 0 && fmd->refresh) {
+			if (fmd->visible_mesh_cached) {
+				fmd->visible_mesh_cached->needsFree = 1;
+				fmd->visible_mesh_cached->release(fmd->visible_mesh_cached);
+			}
+			fmd->visible_mesh_cached = NULL;
+		}
+
+		if (fmd->refresh)
+		{
+			copy_m4_m4(fmd->origmat, ob->obmat);
+
+			/* refracture, convert the fracture shards to new meshislands here *
+			 * shards = fracture datastructure
+			 * meshisland = simulation datastructure */
+			if (fmd->frac_mesh && fmd->frac_mesh->shard_count > 0 && fmd->dm && fmd->dm->numVertData > 0 &&
+			    !fmd->shards_to_islands && !fmd->dm_group)
+			{
+				Shard *s;
+				MeshIsland *mi; /* can be created without shards even, when using fracturemethod = NONE (re-using islands)*/
+
+				int j, vertstart = 0, polystart = 0;
+
+				float dummyloc[3], rot[4];
+				MDeformVert *dvert = fmd->dm->getVertDataArray(fmd->dm, CD_MDEFORMVERT);
+				MDeformVert *ivert;
+				const int thresh_defgrp_index = defgroup_name_index(ob, fmd->thresh_defgrp_name);
+				const int ground_defgrp_index = defgroup_name_index(ob, fmd->ground_defgrp_name);
+
+				/*XXX should rename this... this marks the fracture case, to distinguish from halving case */
+				fmd->explo_shared = true;
+
+				/* exchange cached mesh after fracture, XXX looks like double code */
+				if (fmd->visible_mesh_cached) {
+					fmd->visible_mesh_cached->needsFree = 1;
+					fmd->visible_mesh_cached->release(fmd->visible_mesh_cached);
+					fmd->visible_mesh_cached = NULL;
+				}
+
+				fmd->visible_mesh_cached = CDDM_copy(fmd->dm);
+
+				/* to write to a vgroup (inner vgroup) use the copied cached mesh */
+				ivert = fmd->visible_mesh_cached->getVertDataArray(fmd->visible_mesh_cached, CD_MDEFORMVERT);
+
+				if (ivert == NULL) {    /* add, if not there */
+					int totvert = fmd->visible_mesh_cached->getNumVerts(fmd->visible_mesh_cached);
+					ivert = CustomData_add_layer(&fmd->visible_mesh_cached->vertData, CD_MDEFORMVERT, CD_CALLOC,
+					                             NULL, totvert);
+				}
+
+				for (s = fmd->frac_mesh->shard_map.first; s; s = s->next) {
+					MVert *mv, *verts, *mverts;
+					int totvert, k;
+
+					if (s->totvert == 0) {
+						continue;
+					}
+
+					fmd->frac_mesh->progress_counter++;
+
+					mi = MEM_callocN(sizeof(MeshIsland), "meshIsland");
+					BLI_addtail(&fmd->meshIslands, mi);
+
+					mi->participating_constraints = NULL;
+					mi->participating_constraint_count = 0;
+
+					mi->thresh_weight = 0;
+					mi->vertices_cached = MEM_mallocN(sizeof(MVert *) * s->totvert, "vert_cache");
+					mverts = CDDM_get_verts(fmd->visible_mesh_cached);
+					for (k = 0; k < s->totvert; k++) {
+						mi->vertices_cached[k] = mverts + vertstart + k;
+						/* sum up vertexweights and divide by vertcount to get islandweight*/
+						if (dvert && fmd->thresh_defgrp_name[0]) {
+							float vweight = defvert_find_weight(dvert + vertstart + k, thresh_defgrp_index);
+							mi->thresh_weight += vweight;
+						}
+
+						if (dvert && fmd->ground_defgrp_name[0]) {
+							float gweight = defvert_find_weight(dvert + vertstart + k, ground_defgrp_index);
+							mi->ground_weight += gweight;
+						}
+					}
+					vertstart += s->totvert;
+					mi->physics_mesh = BKE_shard_create_dm(s, true);
+					totvert = mi->physics_mesh->numVertData;
+					verts = mi->physics_mesh->getVertArray(mi->physics_mesh);
+					mi->vertco = MEM_mallocN(sizeof(float) * 3 * totvert, "vertco");
+					mi->vertno = MEM_mallocN(sizeof(short) * 3 * totvert, "vertno");
+					for (mv = verts, j = 0; j < totvert; mv++, j++) {
+						short no[3];
+
+						mi->vertco[j * 3] = mv->co[0];
+						mi->vertco[j * 3 + 1] = mv->co[1];
+						mi->vertco[j * 3 + 2] = mv->co[2];
+
+						/* either take orignormals or take ones from fractured mesh */
+						find_normal(orig_dm, fmd->nor_tree, mv->co, no);
+
+						mi->vertno[j * 3] = no[0];
+						mi->vertno[j * 3 + 1] = no[1];
+						mi->vertno[j * 3 + 2] = no[2];
+
+						if (fmd->fix_normals) {
+							copy_v3_v3_short(mi->vertices_cached[j]->no, no);
+							copy_v3_v3_short(mv->no, no);
+						}
+
+						/* then eliminate centroid in vertex coords*/
+						sub_v3_v3(mv->co, s->centroid);
+					}
+
+					/*copy fixed normals to physics mesh too (needed for convert to objects)*/
+
+					BKE_shard_calc_minmax(s);
+					mi->vertex_count = s->totvert;
+					copy_v3_v3(mi->centroid, s->centroid);
+					mat4_to_loc_quat(dummyloc, rot, ob->obmat);
+					copy_v3_v3(mi->rot, rot);
+
+					mi->bb = BKE_boundbox_alloc_unit();
+					BKE_boundbox_init_from_minmax(mi->bb, s->min, s->max);
+
+					mi->id = s->shard_id;
+					mi->particle_index = s->cluster_colors[0];
+					mi->neighbor_ids = s->neighbor_ids;
+					mi->neighbor_count = s->neighbor_count;
+
+					if (mi->vertex_count > 0) {
+						mi->thresh_weight /= mi->vertex_count;
+						mi->ground_weight /= mi->vertex_count;
+					}
+
+					mi->rigidbody = BKE_rigidbody_create_shard(fmd->modifier.scene, ob, mi);
+					BKE_rigidbody_calc_shard_mass(ob, mi, orig_dm);
+					mi->vertex_indices = NULL;
+
+					polystart += s->totpoly;
+
+				}
+
+				fill_vgroup(fmd, fmd->visible_mesh_cached, ivert, ob);
+			}
+			else {
+				if (fmd->visible_mesh == NULL) {
+					if (fmd->dm && fmd->shards_to_islands) {
+						fmd->visible_mesh = DM_to_bmesh(fmd->dm, true);
+					}
+					else {
+						/* split to meshislands now */
+						fmd->visible_mesh = DM_to_bmesh(dm, true); /* ensures indexes automatically*/
+					}
+
+					start = PIL_check_seconds_timer();
+					printf("Steps: %d \n", fmd->frac_mesh->progress_counter);
+					mesh_separate_loose(fmd, ob, orig_dm);
+					printf("Splitting to islands done, %g  Steps: %d \n", PIL_check_seconds_timer() - start, fmd->frac_mesh->progress_counter);
+				}
+
+				fmd->explo_shared = false;
+			}
+
+			printf("Islands: %d\n", BLI_countlist(&fmd->meshIslands));
+		}
+
+		start = PIL_check_seconds_timer();
+
+		if ((fmd->visible_mesh != NULL && fmd->refresh && (!fmd->explo_shared)) || (fmd->visible_mesh_cached == NULL)) {
+			start = PIL_check_seconds_timer();
+			/*post process ... convert to DerivedMesh only at refresh times, saves permanent conversion during execution */
+			if (fmd->visible_mesh_cached != NULL) {
+				fmd->visible_mesh_cached->needsFree = 1;
+				fmd->visible_mesh_cached->release(fmd->visible_mesh_cached);
+				fmd->visible_mesh_cached = NULL;
+			}
+
+			if (fmd->refresh_images && fmd->dm) {
+				/*need to ensure images are correct after loading... */
+				refresh_customdata_image(ob->data, &fmd->dm->polyData,
+				                         fmd->dm->getNumPolys(fmd->dm));
+				fmd->refresh_images = false;
+			}
+
+			fmd->visible_mesh_cached = createCache(fmd, ob, dm);
+			printf("Building cached DerivedMesh done, %g\n", PIL_check_seconds_timer() - start);
+		}
+
+		if (fmd->refresh_images && fmd->visible_mesh_cached) {
+			/* need to ensure images are correct after loading... */
+			refresh_customdata_image(ob->data, &fmd->visible_mesh_cached->polyData,
+			                         fmd->visible_mesh_cached->getNumPolys(fmd->visible_mesh_cached));
+			fmd->refresh_images = false;
+			DM_update_tessface_data(fmd->visible_mesh_cached);
+		}
+
+		fmd->refresh = false;
+		fmd->refresh_constraints = true;
+
+		/*HERE make a kdtree of the fractured derivedmesh,
+		 * store pairs of faces (MPoly) here (will be most likely the inner faces) */
+		if (fmd->face_pairs != NULL) {
+			BLI_ghash_free(fmd->face_pairs, NULL, NULL);
+			fmd->face_pairs = NULL;
+		}
+
+		fmd->face_pairs = BLI_ghash_int_new("face_pairs");
+		make_face_pairs(fmd, fmd->visible_mesh_cached);
+
+		if (fmd->execute_threaded) {
+			/* job done */
+			fmd->frac_mesh->running = 0;
+		}
+	}
+
+	if (fmd->refresh_constraints) {
+		start = PIL_check_seconds_timer();
+
+		if ((fmd->visible_mesh != NULL || fmd->visible_mesh_cached != NULL)  && (fmd->use_constraints)) {
+			if (fmd->visible_mesh == NULL) {    /* ugh, needed to build constraints... */
+				fmd->visible_mesh = DM_to_bmesh(fmd->visible_mesh_cached, true);
+				BM_mesh_elem_index_ensure(fmd->visible_mesh, BM_VERT | BM_EDGE | BM_FACE);
+				BM_mesh_elem_table_ensure(fmd->visible_mesh, BM_VERT | BM_EDGE | BM_FACE);
+				BM_mesh_elem_toolflags_ensure(fmd->visible_mesh);
+			}
+			create_constraints(fmd); /* check for actually creating the constraints inside*/
+
+			if (fmd->visible_mesh_cached != NULL) {
+				/* if we had a cached visible mesh, throw away this temp visible mesh again */
+				BM_mesh_free(fmd->visible_mesh);
+				fmd->visible_mesh = NULL;
+			}
+		}
+
+		fmd->refresh_constraints = false;
+
+		printf("Building constraints done, %g\n", PIL_check_seconds_timer() - start);
+		printf("Constraints: %d\n", BLI_countlist(&fmd->meshConstraints));
+	}
+
+	/*XXX better rename this, it checks whether we have a valid fractured mesh */
+	exploOK = !fmd->explo_shared || (fmd->explo_shared && fmd->dm && fmd->frac_mesh);
+
+	if ((!exploOK) || (fmd->visible_mesh == NULL && fmd->visible_mesh_cached == NULL))
+	{
+		MeshIsland *mi;
+		/* nullify invalid data */
+		for (mi = fmd->meshIslands.first; mi; mi = mi->next) {
+			mi->vertco = NULL;
+			mi->vertex_count = 0;
+			mi->vertices = NULL;
+			if (mi->vertices_cached)
+			{
+				MEM_freeN(mi->vertices_cached);
+				mi->vertices_cached = NULL;
+			}
+		}
+
+		if (fmd->visible_mesh_cached) {
+			fmd->visible_mesh_cached->needsFree = 1;
+			fmd->visible_mesh_cached->release(fmd->visible_mesh_cached);
+			fmd->visible_mesh_cached = NULL;
+		}
+	}
+
+	if ((fmd->visible_mesh != NULL) && exploOK) {
+		DerivedMesh *dm_final;
+		/* HERE Hide facepairs closer than dist X*/
+
+		if (fmd->autohide_dist > 0) {
+			dm_final = do_autoHide(fmd, fmd->visible_mesh_cached);
+		}
+		else {
+			dm_final = CDDM_copy(fmd->visible_mesh_cached);
+		}
+		return dm_final;
+	}
+	else if ((fmd->visible_mesh_cached != NULL) && exploOK) {
+		DerivedMesh *dm_final;
+
+		if (fmd->autohide_dist > 0) {
+			dm_final = do_autoHide(fmd, fmd->visible_mesh_cached);
+		}
+		else {
+			dm_final = CDDM_copy(fmd->visible_mesh_cached);
+		}
+		return dm_final;
+	}
+	else {
+		if (fmd->visible_mesh == NULL && fmd->visible_mesh_cached == NULL) {
+			/* oops, something went definitely wrong... */
+			fmd->refresh = true;
+			freeData((ModifierData *)fmd);
+			fmd->visible_mesh_cached = NULL;
+			fmd->refresh = false;
+		}
+
+		return dm;
+	}
+
+	return dm;
+}
+
+static bool dependsOnTime(ModifierData *UNUSED(md))
+{
+	return true;
+}
+
+static bool dependsOnNormals(ModifierData *UNUSED(md))
+{
+	return true;
+}
+
+static void foreachIDLink(ModifierData *md, Object *ob,
+                          IDWalkFunc walk, void *userData)
+{
+	FractureModifierData *fmd = (FractureModifierData *) md;
+
+	walk(userData, ob, (ID **)&fmd->inner_material);
+	walk(userData, ob, (ID **)&fmd->extra_group);
+	walk(userData, ob, (ID **)&fmd->dm_group);
+}
+
+static CustomDataMask requiredDataMask(Object *UNUSED(ob), ModifierData *UNUSED(md))
+{
+	CustomDataMask dataMask = 0;
+	dataMask |= CD_MASK_MDEFORMVERT;
+	return dataMask;
+}
+
+static void updateDepgraph(ModifierData *md, DagForest *forest,
+                           struct Scene *UNUSED(scene),
+                           Object *UNUSED(ob),
+                           DagNode *obNode)
+{
+	FractureModifierData *fmd = (FractureModifierData *) md;
+
+	if (fmd->extra_group) {
+		GroupObject *go;
+		for (go = fmd->extra_group->gobject.first; go; go = go->next) {
+			if (go->ob)
+			{
+				DagNode *curNode = dag_get_node(forest, go->ob);
+				dag_add_relation(forest, curNode, obNode,
+				                 DAG_RL_DATA_DATA | DAG_RL_OB_DATA, "Fracture Modifier");
+			}
+		}
+	}
+}
+
+static void foreachObjectLink(
+    ModifierData *md, Object *ob,
+    void (*walk)(void *userData, Object *ob, Object **obpoin),
+    void *userData)
+{
+	FractureModifierData *fmd = (FractureModifierData *) md;
+
+	if (fmd->extra_group) {
+		GroupObject *go;
+		for (go = fmd->extra_group->gobject.first; go; go = go->next) {
+			if (go->ob) {
+				walk(userData, ob, &go->ob);
+			}
+		}
+	}
+}
+
+
+ModifierTypeInfo modifierType_Fracture = {
+	/* name */ "Fracture",
+	/* structName */ "FractureModifierData",
+	/* structSize */ sizeof(FractureModifierData),
+	/* type */ eModifierTypeType_Constructive,                 //eModifierTypeType_OnlyDeform,
+	/* flags */ eModifierTypeFlag_AcceptsMesh |
+	eModifierTypeFlag_AcceptsCVs |
+	eModifierTypeFlag_Single |
+	eModifierTypeFlag_SupportsEditmode |
+	eModifierTypeFlag_SupportsMapping |
+	eModifierTypeFlag_UsesPreview,
+	/* copyData */ copyData,
+	/* deformVerts */ NULL,
+	/* deformMatrices */ NULL,
+	/* deformVertsEM */ NULL,
+	/* deformMatricesEM */ NULL,
+	/* applyModifier */ applyModifier,
+	/* applyModifierEM */ applyModifierEM,
+	/* initData */ initData,
+	/* requiredDataMask */ requiredDataMask,
+	/* freeData */ freeData,
+	/* isDisabled */ NULL,
+	/* updateDepgraph */ updateDepgraph,
+	/* dependsOnTime */ dependsOnTime,
+	/* dependsOnNormals */ dependsOnNormals,
+	/* foreachObjectLink */ foreachObjectLink,
+	/* foreachIDLink */ foreachIDLink,
+};
diff -ru --new-file blender-2.76b.old/source/blender/modifiers/intern/MOD_util.c blender-2.76b/source/blender/modifiers/intern/MOD_util.c
--- blender-2.76b.old/source/blender/modifiers/intern/MOD_util.c	2015-10-30 23:31:41.000000000 +0300
+++ blender-2.76b/source/blender/modifiers/intern/MOD_util.c	2016-01-27 22:27:32.789419863 +0300
@@ -307,5 +307,6 @@
 	INIT_TYPE(DataTransfer);
 	INIT_TYPE(NormalEdit);
 	INIT_TYPE(CorrectiveSmooth);
+	INIT_TYPE(Fracture);
 #undef INIT_TYPE
 }
diff -ru --new-file blender-2.76b.old/source/blender/modifiers/MOD_modifiertypes.h blender-2.76b/source/blender/modifiers/MOD_modifiertypes.h
--- blender-2.76b.old/source/blender/modifiers/MOD_modifiertypes.h	2015-10-30 23:31:41.000000000 +0300
+++ blender-2.76b/source/blender/modifiers/MOD_modifiertypes.h	2016-01-27 22:12:26.555864597 +0300
@@ -81,6 +81,7 @@
 extern ModifierTypeInfo modifierType_MeshCache;
 extern ModifierTypeInfo modifierType_LaplacianDeform;
 extern ModifierTypeInfo modifierType_Wireframe;
+extern ModifierTypeInfo modifierType_Fracture;
 extern ModifierTypeInfo modifierType_DataTransfer;
 extern ModifierTypeInfo modifierType_NormalEdit;
 extern ModifierTypeInfo modifierType_CorrectiveSmooth;
diff -ru --new-file blender-2.76b.old/source/blender/modifiers/SConscript blender-2.76b/source/blender/modifiers/SConscript
--- blender-2.76b.old/source/blender/modifiers/SConscript	2015-11-02 16:25:38.000000000 +0300
+++ blender-2.76b/source/blender/modifiers/SConscript	2016-01-27 22:13:00.182624865 +0300
@@ -67,6 +67,10 @@
 if env['WITH_BF_OCEANSIM']:
     defs.append('WITH_OCEANSIM')
 
+if env['WITH_BF_VORONOI']:
+    incs += ' #/extern/voro++'
+    defs.append('WITH_VORO')
+
 if env['WITH_BF_BULLET']:
     defs.append('WITH_BULLET')
 
diff -ru --new-file blender-2.76b.old/source/blender/windowmanager/intern/wm_jobs.c blender-2.76b/source/blender/windowmanager/intern/wm_jobs.c
--- blender-2.76b.old/source/blender/windowmanager/intern/wm_jobs.c	2015-11-02 16:25:38.000000000 +0300
+++ blender-2.76b/source/blender/windowmanager/intern/wm_jobs.c	2016-01-27 22:30:06.587329799 +0300
@@ -90,7 +90,7 @@
 	void (*startjob)(void *, short *stop, short *do_update, float *progress);
 	/* update gets called if thread defines so, and max once per timerstep */
 	/* it runs outside thread, blocking blender, no drawing! */
-	void (*update)(void *);
+	float (*update)(void *);
 	/* free entire customdata, doesn't run in thread */
 	void (*free)(void *);
 	/* gets called when job is stopped, not in thread */
@@ -564,14 +564,25 @@
 				
 				/* always call note and update when ready */
 				if (wm_job->do_update || wm_job->ready) {
-					if (wm_job->update)
-						wm_job->update(wm_job->run_customdata);
+					if (wm_job->update) {
+						if (wm_job->job_type == WM_JOB_TYPE_OBJECT_FRACTURE) {
+							/* sigh, need to get progress from somewhere... */
+							wm_job->progress = wm_job->update(wm_job->run_customdata);
+						}
+						else {
+							wm_job->update(wm_job->run_customdata);
+						}
+					}
 					if (wm_job->note)
 						WM_event_add_notifier(C, wm_job->note, NULL);
 
 					if (wm_job->flag & WM_JOB_PROGRESS)
 						WM_event_add_notifier(C, NC_WM | ND_JOB, NULL);
-					wm_job->do_update = false;
+
+					if (wm_job->job_type != WM_JOB_TYPE_OBJECT_FRACTURE) {
+						/* why on earth is this set to false here ? need the timer update... or not ?*/
+						wm_job->do_update = false;
+					}
 				}
 				
 				if (wm_job->ready) {
diff -ru --new-file blender-2.76b.old/source/blender/windowmanager/WM_api.h blender-2.76b/source/blender/windowmanager/WM_api.h
--- blender-2.76b.old/source/blender/windowmanager/WM_api.h	2015-11-04 13:02:15.000000000 +0300
+++ blender-2.76b/source/blender/windowmanager/WM_api.h	2016-01-27 22:28:18.037099334 +0300
@@ -425,6 +425,7 @@
 	WM_JOB_TYPE_CLIP_PREFETCH,
 	WM_JOB_TYPE_SEQ_BUILD_PROXY,
 	WM_JOB_TYPE_SEQ_BUILD_PREVIEW,
+	WM_JOB_TYPE_OBJECT_FRACTURE,
 	/* add as needed, screencast, seq proxy build
 	 * if having hard coded values is a problem */
 };
diff -ru --new-file blender-2.76b.old/source/blenderplayer/CMakeLists.txt blender-2.76b/source/blenderplayer/CMakeLists.txt
--- blender-2.76b.old/source/blenderplayer/CMakeLists.txt	2016-01-27 18:39:43.642008199 +0300
+++ blender-2.76b/source/blenderplayer/CMakeLists.txt	2016-01-27 22:30:40.994085715 +0300
@@ -216,7 +216,11 @@
 		list(APPEND BLENDER_SORTED_LIBS bf_intern_opensubdiv)
 	endif()
 
-	foreach(SORTLIB ${BLENDER_SORTED_LIBS})
+	if(WITH_VORO)
+		list(APPEND BLENDER_SORTED_LIBS extern_voro)
+	endif()
+	
+    foreach(SORTLIB ${BLENDER_SORTED_LIBS})
 		set(REMLIB ${SORTLIB})
 		foreach(SEARCHLIB ${BLENDER_LINK_LIBS})
 			if(${SEARCHLIB} STREQUAL ${SORTLIB})
