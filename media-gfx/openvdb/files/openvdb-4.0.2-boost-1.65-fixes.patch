diff -ru ../openvdb-4.0.2.old/openvdb/python/pyFloatGrid.cc ./openvdb/python/pyFloatGrid.cc
--- ../openvdb-4.0.2.old/openvdb/python/pyFloatGrid.cc	2017-07-31 21:16:32.000000000 +0300
+++ ./openvdb/python/pyFloatGrid.cc	2017-09-05 18:35:46.449739633 +0300
@@ -45,10 +45,6 @@
     // Add a module-level list that gives the types of all supported Grid classes.
     py::scope().attr("GridTypes") = py::list();
 
-    // Specify that py::numeric::array should refer to the Python type numpy.ndarray
-    // (rather than the older Numeric.array).
-    py::numeric::array::set_module_and_type("numpy", "ndarray");
-
     pyGrid::exportGrid<FloatGrid>();
 #ifdef PY_OPENVDB_WRAP_ALL_GRID_TYPES
     pyGrid::exportGrid<DoubleGrid>();
diff -ru ../openvdb-4.0.2.old/openvdb/python/pyGrid.h ./openvdb/python/pyGrid.h
--- ../openvdb-4.0.2.old/openvdb/python/pyGrid.h	2017-07-31 21:16:32.000000000 +0300
+++ ./openvdb/python/pyGrid.h	2017-09-05 18:40:54.578523991 +0300
@@ -820,7 +820,7 @@
 
         // Extract a reference to (not a copy of) the NumPy array,
         // or throw an exception if arrObj is not a NumPy array object.
-        const py::numeric::array arrayObj = pyutil::extractArg<py::numeric::array>(
+        const py::numpy::ndarray arrayObj = pyutil::extractArg<py::numpy::ndarray>(
             arrObj, opName[toGrid], pyutil::GridTraits<GridType>::name(),
             /*argIdx=*/1, "numpy.ndarray");
 
@@ -1113,7 +1113,7 @@
 // and sizes from NumPy arrays to STL vectors
 template<typename VecT>
 inline void
-copyVecArray(py::numeric::array& arrayObj, std::vector<VecT>& vec)
+copyVecArray(py::numpy::ndarray& arrayObj, std::vector<VecT>& vec)
 {
     typedef typename VecT::ValueType ValueT;
 
@@ -1156,7 +1156,7 @@
 
         // Raise a Python exception if the given NumPy array does not have dimensions M x N
         // or does not have an integer or floating-point data type.
-        static void validate2DNumPyArray(py::numeric::array arrayObj,
+        static void validate2DNumPyArray(py::numpy::ndarray arrayObj,
             const int N, const char* desiredType)
         {
             PyArrayObject* arrayObjPtr = reinterpret_cast<PyArrayObject*>(arrayObj.ptr());
@@ -1222,7 +1222,7 @@
     if (!pointsObj.is_none()) {
         // Extract a reference to (not a copy of) a NumPy array argument,
         // or throw an exception if the argument is not a NumPy array object.
-        py::numeric::array arrayObj = extractValueArg<GridType, py::numeric::array>(
+        py::numpy::ndarray arrayObj = extractValueArg<GridType, py::numpy::ndarray>(
             pointsObj, Local::methodName(), /*argIdx=*/1, "numpy.ndarray");
 
         // Throw an exception if the array has the wrong type or dimensions.
@@ -1235,7 +1235,7 @@
     // Extract the list of triangle indices from the arguments to this method.
     std::vector<Vec3I> triangles;
     if (!trianglesObj.is_none()) {
-        py::numeric::array arrayObj = extractValueArg<GridType, py::numeric::array>(
+        py::numpy::ndarray arrayObj = extractValueArg<GridType, py::numpy::ndarray>(
             trianglesObj, Local::methodName(), /*argIdx=*/2, "numpy.ndarray");
         Local::validate2DNumPyArray(arrayObj, /*N=*/3, /*desiredType=*/"int");
         copyVecArray(arrayObj, triangles);
@@ -1244,7 +1244,7 @@
     // Extract the list of quad indices from the arguments to this method.
     std::vector<Vec4I> quads;
     if (!quadsObj.is_none()) {
-        py::numeric::array arrayObj = extractValueArg<GridType, py::numeric::array>(
+        py::numpy::ndarray arrayObj = extractValueArg<GridType, py::numpy::ndarray>(
             quadsObj, Local::methodName(), /*argIdx=*/3, "numpy.ndarray");
         Local::validate2DNumPyArray(arrayObj, /*N=*/4, /*desiredType=*/"int");
         copyVecArray(arrayObj, quads);
@@ -1268,7 +1268,7 @@
     tools::volumeToMesh(grid, points, quads, isovalue);
 
     // Copy vertices into an N x 3 NumPy array.
-    py::object pointArrayObj = py::numeric::array(py::list(), "float32");
+    py::object pointArrayObj = py::numpy::ndarray(py::list(), "float32");
     if (!points.empty()) {
         npy_intp dims[2] = { npy_intp(points.size()), 3 };
         // Construct a NumPy array that wraps the point vector.
@@ -1282,7 +1282,7 @@
     }
 
     // Copy face indices into an N x 4 NumPy array.
-    py::object quadArrayObj = py::numeric::array(py::list(), "uint32");
+    py::object quadArrayObj = py::numpy::ndarray(py::list(), "uint32");
     if (!quads.empty()) {
         npy_intp dims[2] = { npy_intp(quads.size()), 4 };
         if (PyArrayObject* arrayObj = reinterpret_cast<PyArrayObject*>(
@@ -1312,7 +1312,7 @@
     tools::volumeToMesh(grid, points, triangles, quads, isovalue, adaptivity);
 
     // Copy vertices into an N x 3 NumPy array.
-    py::object pointArrayObj = py::numeric::array(py::list(), "float32");
+    py::object pointArrayObj = py::numpy::ndarray(py::list(), "float32");
     if (!points.empty()) {
         npy_intp dims[2] = { npy_intp(points.size()), 3 };
         // Construct a NumPy array that wraps the point vector.
@@ -1326,7 +1326,7 @@
     }
 
     // Copy triangular face indices into an N x 3 NumPy array.
-    py::object triangleArrayObj = py::numeric::array(py::list(), "uint32");
+    py::object triangleArrayObj = py::numpy::ndarray(py::list(), "uint32");
     if (!triangles.empty()) {
         npy_intp dims[2] = { npy_intp(triangles.size()), 3 };
         if (PyArrayObject* arrayObj = reinterpret_cast<PyArrayObject*>(
@@ -1337,7 +1337,7 @@
     }
 
     // Copy quadrilateral face indices into an N x 4 NumPy array.
-    py::object quadArrayObj = py::numeric::array(py::list(), "uint32");
+    py::object quadArrayObj = py::numpy::ndarray(py::list(), "uint32");
     if (!quads.empty()) {
         npy_intp dims[2] = { npy_intp(quads.size()), 4 };
         if (PyArrayObject* arrayObj = reinterpret_cast<PyArrayObject*>(
